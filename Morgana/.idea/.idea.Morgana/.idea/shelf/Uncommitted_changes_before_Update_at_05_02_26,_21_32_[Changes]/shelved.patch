Index: Morgana.Framework/Actors/ConversationSupervisorActor.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Akka.Actor;\nusing Akka.Event;\nusing Morgana.Framework.Abstractions;\nusing Morgana.Framework.Extensions;\nusing Morgana.Framework.Interfaces;\nusing System.Text.Json;\n\nnamespace Morgana.Framework.Actors;\n\n/// <summary>\n/// <para>\n/// Main orchestration actor that supervises the conversation flow through a finite state machine.\n/// Coordinates guard checks, intent classification, agent routing and follow-up handling.\n/// Manages presentation generation and tracks active agent state for multi-turn conversations.\n/// </para>\n/// <para>\n/// Every UserMessage (new request or follow-up) passes through GuardActor first.\n/// Guard check failure keeps FSM in current state, allowing user to retry without state change.\n/// </para>\n/// </summary>\n/// <remarks>\n/// <para><strong>State Machine:</strong></para>\n/// <list type=\"bullet\">\n/// <item><term>Idle</term><description>Waiting for user messages. All messages are routed to guard check first.</description></item>\n/// <item><term>AwaitingGuardCheck</term><description>Waiting for content moderation result from GuardActor. Can transition to Classification or FollowUp based on activeAgent state.</description></item>\n/// <item><term>AwaitingClassification</term><description>Waiting for intent classification result from ClassifierActor (only for new requests).</description></item>\n/// <item><term>AwaitingAgentResponse</term><description>Waiting for specialized agent to process the request.</description></item>\n/// <item><term>AwaitingFollowUpResponse</term><description>Waiting for active agent to process follow-up message.</description></item>\n/// </list>\n/// <para><strong>Active Agent Tracking:</strong></para>\n/// <para>When an agent signals incomplete processing (IsCompleted = false), the supervisor remembers the active agent\n/// and routes subsequent messages directly to it (after guard check) until the agent signals completion.</para>\n/// </remarks>\npublic class ConversationSupervisorActor : MorganaActor\n{\n    private readonly ISignalRBridgeService signalRBridgeService;\n    private readonly IAgentConfigurationService agentConfigService;\n\n    /* Actors directly orchestrated by the supervisor */\n    private readonly IActorRef guard;\n    private readonly IActorRef classifier;\n    private readonly IActorRef router;\n\n    /// <summary>\n    /// Reference to the currently active agent (for multi-turn conversations).\n    /// Null when no agent is active.\n    /// </summary>\n    private IActorRef? activeAgent;\n\n    /// <summary>\n    /// Intent name of the currently active agent.\n    /// Used for agent name display and tracking.\n    /// </summary>\n    private string? activeAgentIntent;\n\n    /// <summary>\n    /// Flag indicating whether the presentation message has been sent.\n    /// Prevents duplicate presentation on subsequent messages.\n    /// </summary>\n    private bool hasPresented;\n\n    /// <summary>\n    /// Initializes a new instance of the ConversationSupervisorActor.\n    /// Creates child actors (guard, classifier, router) and enters Idle state.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier for this conversation</param>\n    /// <param name=\"llmService\">LLM service for AI completions</param>\n    /// <param name=\"promptResolverService\">Service for resolving prompt templates</param>\n    /// <param name=\"signalRBridgeService\">Service for sending messages to clients via SignalR</param>\n    /// <param name=\"agentConfigService\">Service for loading intent and agent configurations</param>\n    public ConversationSupervisorActor(\n        string conversationId,\n        ILLMService llmService,\n        IPromptResolverService promptResolverService,\n        ISignalRBridgeService signalRBridgeService,\n        IAgentConfigurationService agentConfigService) : base(conversationId, llmService, promptResolverService)\n    {\n        this.signalRBridgeService = signalRBridgeService;\n        this.agentConfigService = agentConfigService;\n\n        guard = Context.System.GetOrCreateActor<GuardActor>(\n            \"guard\", conversationId).GetAwaiter().GetResult();\n\n        classifier = Context.System.GetOrCreateActor<ClassifierActor>(\n            \"classifier\", conversationId).GetAwaiter().GetResult();\n\n        router = Context.System.GetOrCreateActor<RouterActor>(\n            \"router\", conversationId).GetAwaiter().GetResult();\n\n        Idle();\n    }\n\n    #region State Behaviors\n\n    /// <summary>\n    /// Idle state: waiting for user messages or presentation requests.\n    /// ALL user messages route through guard check first (whether new request or follow-up).\n    /// </summary>\n    private void Idle()\n    {\n        actorLogger.Info(\"↗ State: Idle\");\n\n        // Clear any lingering timeout from previous states\n        Context.SetReceiveTimeout(null);\n\n        // Generate and send welcome message with quick reply buttons on conversation start\n        ReceiveAsync<Records.GeneratePresentationMessage>(HandlePresentationRequestAsync);\n        ReceiveAsync<Records.PresentationContext>(HandlePresentationGenerated);\n\n        // Handle incoming user messages - route through guard check using Tell pattern\n        Receive<Records.UserMessage>(msg =>\n        {\n            IActorRef originalSender = Sender;\n\n            actorLogger.Info(\"User message received, routing through guard check\");\n\n            Records.ProcessingContext ctx = new Records.ProcessingContext(msg, originalSender);\n\n            // Become FIRST, then Tell\n            Become(() => AwaitingGuardCheck(ctx));\n\n            guard.Tell(new Records.GuardCheckRequest(msg.ConversationId, msg.Text));\n        });\n\n        // Re-register common handlers for FSM behavior consistency\n        RegisterCommonHandlers();\n    }\n\n    /// <summary>\n    /// Handles presentation generation requests.\n    /// Generates a welcome message with quick replies using LLM or falls back to static template.\n    /// </summary>\n    /// <param name=\"_\">Presentation request message (unused)</param>\n    /// <remarks>\n    /// <para>Presentation flow:</para>\n    /// <list type=\"number\">\n    /// <item>Load presentation prompt from framework configuration</item>\n    /// <item>Load available intents from domain configuration</item>\n    /// <item>Call LLM to generate dynamic welcome message with quick replies</item>\n    /// <item>On LLM failure, use fallback static message</item>\n    /// <item>Send message to client via SignalR</item>\n    /// </list>\n    /// <para>Skips if presentation was already shown.</para>\n    /// </remarks>\n    private async Task HandlePresentationRequestAsync(Records.GeneratePresentationMessage _)\n    {\n        if (hasPresented)\n        {\n            actorLogger.Info(\"Presentation already shown, skipping\");\n            return;\n        }\n\n        hasPresented = true;\n        actorLogger.Info(\"Generating LLM-driven presentation message\");\n\n        try\n        {\n            // Load presentation prompt from morgana.json (framework)\n            Records.Prompt presentationPrompt = await promptResolverService.ResolveAsync(\"Presentation\");\n\n            // Load intents from domain\n            List<Records.IntentDefinition> allIntents = await agentConfigService.GetIntentsAsync();\n\n            Records.IntentCollection intentCollection = new Records.IntentCollection(allIntents);\n            List<Records.IntentDefinition> displayableIntents = intentCollection.GetDisplayableIntents();\n\n            if (displayableIntents.Count == 0)\n            {\n                actorLogger.Warning(\"No displayable intents available, sending presentation without quick replies\");\n\n                await Task.Delay(750); // Give SignalR time to join conversation\n\n                await signalRBridgeService.SendStructuredMessageAsync(\n                    conversationId,\n                    presentationPrompt.GetAdditionalProperty<string>(\"NoAgentsMessage\"),\n                    \"presentation\",\n                    [], // No quick replies\n                    null,\n                    \"Morgana\",\n                    false);\n\n                return;\n            }\n\n            // Format intents for LLM\n            string formattedIntents = string.Join(\"\\n\",\n                displayableIntents.Select(i => $\"- {i.Name}: {i.Description}\"));\n\n            // Build LLM prompt\n            string systemPrompt = $\"{presentationPrompt.Target}\\n\\n{presentationPrompt.Instructions}\"\n                .Replace(\"((intents))\", formattedIntents);\n\n            actorLogger.Info(\"Invoking LLM to generate presentation message\");\n\n            string llmResponse = await llmService.CompleteWithSystemPromptAsync(\n                conversationId,\n                systemPrompt,\n                \"Generate the presentation\");\n\n            actorLogger.Info(\"LLM presentation generated successfully\");\n\n            Records.PresentationResponse? presentation =\n                JsonSerializer.Deserialize<Records.PresentationResponse>(llmResponse);\n\n            if (presentation != null)\n            {\n                actorLogger.Info($\"LLM generated {presentation.QuickReplies.Count} quick replies\");\n\n                Self.Tell(new Records.PresentationContext(presentation.Message, displayableIntents)\n                {\n                    LLMQuickReplies = presentation.QuickReplies\n                });\n            }\n            else\n            {\n                throw new InvalidOperationException(\"LLM returned null presentation\");\n            }\n        }\n        catch (Exception ex)\n        {\n            actorLogger.Error(ex, \"LLM presentation generation failed, using fallback\");\n\n            // Fallback: use static message\n            Records.Prompt fallbackPrompt = await promptResolverService.ResolveAsync(\"Presentation\");\n            string fallbackMessage = fallbackPrompt.GetAdditionalProperty<string>(\"FallbackMessage\");\n\n            List<Records.IntentDefinition> allIntents = await agentConfigService.GetIntentsAsync();\n\n            Records.IntentCollection intentCollection = new Records.IntentCollection(allIntents);\n            List<Records.IntentDefinition> displayableIntents = intentCollection.GetDisplayableIntents();\n\n            List<Records.QuickReply> fallbackReplies = displayableIntents\n                .ConvertAll(intent => new Records.QuickReply(\n                    intent.Name,\n                    intent.Label ?? intent.Name,\n                    intent.DefaultValue ?? $\"Help me with {intent.Name}\"));\n\n            actorLogger.Info($\"Using fallback presentation with {fallbackReplies.Count} quick replies\");\n\n            Self.Tell(new Records.PresentationContext(fallbackMessage, displayableIntents)\n            {\n                LLMQuickReplies = fallbackReplies\n            });\n        }\n    }\n\n    /// <summary>\n    /// Handles the generated presentation and sends it to the client via SignalR.\n    /// </summary>\n    /// <param name=\"ctx\">Context containing the presentation message and quick replies</param>\n    private async Task HandlePresentationGenerated(Records.PresentationContext ctx)\n    {\n        actorLogger.Info(\"Sending presentation to client via SignalR\");\n\n        // Convert LLM-generated quick replies to SignalR format\n        List<Records.QuickReply> quickReplies = ctx.LLMQuickReplies?\n            .Select(qr => new Records.QuickReply(qr.Id, qr.Label, qr.Value))\n            .ToList() ?? [];\n\n        try\n        {\n            await Task.Delay(750); // Give SignalR time to join conversation\n\n            await signalRBridgeService.SendStructuredMessageAsync(\n                conversationId,\n                ctx.Message,\n                \"presentation\",\n                quickReplies,\n                null,\n                \"Morgana\",\n                false);\n\n            actorLogger.Info(\"Presentation sent successfully\");\n        }\n        catch (Exception ex)\n        {\n            actorLogger.Error(ex, \"Failed to send presentation via SignalR\");\n        }\n    }\n\n    /// <summary>\n    /// <para>\n    /// AwaitingGuardCheck state: waiting for content moderation result from GuardActor.\n    /// This state is reached from BOTH new requests AND follow-ups.\n    /// </para>\n    /// <para>\n    /// On pass: transitions to next appropriate state (Classification for new, FollowUp for active agent)\n    /// On fail: sends violation message to client and returns to Idle (user can retry)\n    /// </para>\n    /// </summary>\n    /// <param name=\"ctx\">Processing context containing original message and sender</param>\n    private void AwaitingGuardCheck(Records.ProcessingContext ctx)\n    {\n        actorLogger.Info(\"→ State: AwaitingGuardCheck\");\n\n        // Handle content moderation result from GuardActor:\n        // - If compliant AND activeAgent exists: route to active agent (follow-up flow)\n        // - If compliant AND no activeAgent: route to classifier (new request flow)\n        // - If violation: send rejection message and return to Idle (allow user retry)\n        ReceiveAsync<Records.GuardCheckResponse>(async response =>\n        {\n            if (!response.Compliant)\n            {\n                actorLogger.Warning($\"Message rejected by guard: {response.Violation}\");\n\n                Records.Prompt guardPrompt = await promptResolverService.ResolveAsync(\"Guard\");\n                string guardAnswer = guardPrompt.GetAdditionalProperty<string>(\"GuardAnswer\")\n                    .Replace(\"((violation))\", response.Violation ?? \"Content policy violation\");\n\n                string currentAgentName = activeAgentIntent != null ? GetAgentDisplayName(activeAgentIntent) : \"Morgana\";\n                ctx.OriginalSender.Tell(new Records.ConversationResponse(\n                    guardAnswer, ctx.Classification?.Intent, null, currentAgentName, false));\n\n                // Return to Idle - user can retry the message\n                Become(Idle);\n                return;\n            }\n\n            actorLogger.Info(\"Message passed guard check\");\n\n            if (activeAgent != null)\n            {\n                actorLogger.Info($\"Active agent exists, routing to follow-up flow with agent {activeAgent.Path}\");\n\n                // Become BEFORE Tell so we're ready to receive streaming chunks\n                Become(() => AwaitingFollowUpResponse(ctx.OriginalSender));\n\n                // Route directly to active agent (follow-up) using Tell\n                activeAgent.Tell(new Records.AgentRequest(\n                    ctx.OriginalMessage.ConversationId,\n                    ctx.OriginalMessage.Text,\n                    null));\n            }\n            else\n            {\n                actorLogger.Info(\"No active agent, proceeding to classification for new request\");\n\n                // Become FIRST, then Tell classifier\n                Become(() => AwaitingClassification(ctx));\n\n                classifier.Tell(ctx.OriginalMessage);\n            }\n        });\n\n        Receive<Status.Failure>(failure =>\n        {\n            actorLogger.Error(failure.Cause, \"Guard check failed\");\n\n            // Fail-open: allow message through on guard error\n            actorLogger.Warning(\"Guard check failed, failing open (allowing message)\");\n\n            if (activeAgent != null)\n            {\n                // Become FIRST, then Tell active agent\n                Become(() => AwaitingFollowUpResponse(ctx.OriginalSender));\n\n                activeAgent.Tell(new Records.AgentRequest(\n                    ctx.OriginalMessage.ConversationId,\n                    ctx.OriginalMessage.Text,\n                    null));\n            }\n            else\n            {\n                // Become FIRST, then Tell classifier\n                Become(() => AwaitingClassification(ctx));\n\n                classifier.Tell(ctx.OriginalMessage);\n            }\n        });\n\n        // Re-register common handlers for FSM behavior consistency\n        RegisterCommonHandlers();\n    }\n\n    /// <summary>\n    /// AwaitingClassification state: waiting for intent classification result from ClassifierActor.\n    /// Only reached after guard check passes for NEW requests (no active agent).\n    /// On success: forwards to RouterActor and transitions to AwaitingAgentResponse.\n    /// On failure: falls back to \"other\" intent to maintain conversation flow.\n    /// </summary>\n    /// <param name=\"ctx\">Processing context containing original message and sender</param>\n    private void AwaitingClassification(Records.ProcessingContext ctx)\n    {\n        actorLogger.Info(\"→ State: AwaitingClassification\");\n\n        // Handle intent classification result from ClassifierActor:\n        // - Classification successful: forward to RouterActor to find appropriate agent → AwaitingAgentResponse\n        // - Updates processing context with classification metadata for agent routing\n        Receive<Records.ClassificationResult>(classification =>\n        {\n            actorLogger.Info($\"Classification result: {classification.Intent}\");\n\n            Records.ProcessingContext updatedCtx = ctx with { Classification = classification };\n\n            // Become BEFORE Tell so we're ready to receive streaming chunks\n            Become(() => AwaitingAgentResponse(updatedCtx));\n\n            // Route to router using Tell (not Ask) to support streaming\n            router.Tell(new Records.AgentRequest(\n                ctx.OriginalMessage.ConversationId,\n                ctx.OriginalMessage.Text,\n                classification));\n        });\n\n        Receive<Status.Failure>(failure =>\n        {\n            actorLogger.Error(failure.Cause, \"Classification failed\");\n\n            // Fallback to \"other\" intent to maintain conversation flow\n            Records.ClassificationResult fallbackClassification = new Records.ClassificationResult(\n                \"other\",\n                new Dictionary<string, string>\n                {\n                    [\"confidence\"] = \"0.00\",\n                    [\"error\"] = $\"classification_failed: {failure.Cause.Message}\"\n                });\n\n            actorLogger.Info(\"Falling back to 'other' intent\");\n            Records.ProcessingContext updatedCtx = ctx with { Classification = fallbackClassification };\n\n            // Become FIRST, then Tell router\n            Become(() => AwaitingAgentResponse(updatedCtx));\n\n            router.Tell(new Records.AgentRequest(\n                ctx.OriginalMessage.ConversationId,\n                ctx.OriginalMessage.Text,\n                fallbackClassification));\n        });\n\n        // Re-register common handlers for FSM behavior consistency\n        RegisterCommonHandlers();\n    }\n\n    /// <summary>\n    /// AwaitingAgentResponse state: waiting for specialized agent to process the request.\n    /// Only reached after classification for NEW requests.\n    /// Handles both ActiveAgentResponse (from specialized agents) and AgentResponse (from router fallback).\n    /// Updates active agent tracking based on agent completion status.\n    /// </summary>\n    /// <param name=\"ctx\">Processing context containing original message, sender, and classification</param>\n    /// <remarks>\n    /// If agent signals incomplete (IsCompleted = false), the agent becomes \"active\" and subsequent messages\n    /// are routed directly to it (after guard check) until it signals completion.\n    /// </remarks>\n    private void AwaitingAgentResponse(Records.ProcessingContext ctx)\n    {\n        actorLogger.Info(\"→ State: AwaitingAgentResponse\");\n\n        // Set timeout for agent response (90 seconds)\n        Context.SetReceiveTimeout(TimeSpan.FromSeconds(90));\n\n        // Handle timeout if agent doesn't respond\n        Receive<ReceiveTimeout>(_ =>\n        {\n            actorLogger.Error($\"Timeout waiting for agent response (classification: {ctx.Classification?.Intent})\");\n\n            Context.SetReceiveTimeout(null); // Clear timeout\n\n            ctx.OriginalSender.Tell(new Records.ConversationResponse(\n                \"I apologize, but the request took too long to process. Please try again.\",\n                ctx.Classification?.Intent,\n                ctx.Classification?.Metadata,\n                GetAgentDisplayName(ctx.Classification?.Intent),\n                false,\n                null,\n                ctx.OriginalMessage.Timestamp));\n\n            Become(Idle);\n        });\n\n        // Forward streaming chunks from agent to manager (and then to client)\n        // Reset timeout on each chunk to prevent timeout during active streaming\n        Receive<Records.AgentStreamChunk>(chunk =>\n        {\n            // Reset timeout - we're getting data, agent is alive\n            Context.SetReceiveTimeout(TimeSpan.FromSeconds(90));\n            ctx.OriginalSender.Tell(chunk);\n        });\n\n        // Handle specialized agent response with active agent tracking (direct Tell from router)\n        Receive<Records.ActiveAgentResponse>(response =>\n        {\n            // Clear timeout immediately upon receiving response\n            Context.SetReceiveTimeout(null);\n\n            try\n            {\n                string agentName = GetAgentDisplayName(ctx.Classification?.Intent);\n                int quickRepliesCount = response.QuickReplies?.Count ?? 0;\n                \n                actorLogger.Info($\"Received ActiveAgentResponse from {response.AgentRef.Path}, completed: {response.IsCompleted}, quickReplies: {quickRepliesCount}\");\n\n                if (response.IsCompleted)\n                {\n                    actorLogger.Info(\"Agent signaled completion, clearing active agent\");\n\n                    activeAgent = null;\n                    activeAgentIntent = null;\n                }\n                else\n                {\n                    actorLogger.Info($\"Agent signaled incomplete, setting as active agent: {response.AgentRef.Path}\");\n\n                    activeAgent = response.AgentRef;\n                    activeAgentIntent = ctx.Classification?.Intent; // Store intent from classification\n                }\n\n                ctx.OriginalSender.Tell(new Records.ConversationResponse(\n                    response.Response,\n                    ctx.Classification?.Intent,\n                    ctx.Classification?.Metadata,\n                    agentName,\n                    response.IsCompleted,\n                    response.QuickReplies,\n                    ctx.OriginalMessage.Timestamp));\n\n                Become(Idle);\n            }\n            catch (Exception ex)\n            {\n                actorLogger.Error(ex, \"Error processing ActiveAgentResponse\");\n\n                // Clear active agent on error\n                activeAgent = null;\n                activeAgentIntent = null;\n\n                // Send error response to manager\n                ctx.OriginalSender.Tell(new Records.ConversationResponse(\n                    \"An error occurred while processing the response. Please try again.\",\n                    ctx.Classification?.Intent,\n                    ctx.Classification?.Metadata,\n                    GetAgentDisplayName(ctx.Classification?.Intent),\n                    false,\n                    null,\n                    ctx.OriginalMessage.Timestamp));\n\n                Become(Idle);\n            }\n        });\n\n        // Handle fallback response from router (no specialized agent available)\n        Receive<Records.AgentResponse>(response =>\n        {\n            // Clear timeout immediately upon receiving response\n            Context.SetReceiveTimeout(null);\n\n            try\n            {\n                actorLogger.Info(\"Received fallback response from router (no specialized agent)\");\n\n                ctx.OriginalSender.Tell(new Records.ConversationResponse(\n                    response.Response,\n                    ctx.Classification?.Intent,\n                    null,\n                    \"Morgana\",\n                    true,\n                    response.QuickReplies,\n                    DateTime.UtcNow));\n\n                Become(Idle);\n            }\n            catch (Exception ex)\n            {\n                actorLogger.Error(ex, \"Error processing fallback AgentResponse\");\n\n                ctx.OriginalSender.Tell(new Records.ConversationResponse(\n                    \"An error occurred while processing the response. Please try again.\",\n                    ctx.Classification?.Intent,\n                    null,\n                    \"Morgana\",\n                    false,\n                    null,\n                    DateTime.UtcNow));\n\n                Become(Idle);\n            }\n        });\n\n        // Re-register common handlers for FSM behavior consistency\n        RegisterCommonHandlers();\n    }\n\n    /// <summary>\n    /// AwaitingFollowUpResponse state: waiting for active agent to process follow-up message.\n    /// Only reached when an active agent exists (multi-turn conversation).\n    /// Routes messages directly to the active agent, bypassing classification.\n    /// </summary>\n    /// <param name=\"originalSender\">Original sender reference for response routing</param>\n    private void AwaitingFollowUpResponse(IActorRef originalSender)\n    {\n        actorLogger.Info(\"→ State: AwaitingFollowUpResponse\");\n\n        // Set timeout for follow-up agent response (90 seconds)\n        Context.SetReceiveTimeout(TimeSpan.FromSeconds(90));\n\n        // Handle timeout if agent doesn't respond\n        Receive<ReceiveTimeout>(_ =>\n        {\n            actorLogger.Error($\"Timeout waiting for follow-up response from active agent (intent: {activeAgentIntent})\");\n\n            Context.SetReceiveTimeout(null); // Clear timeout\n\n            // Clear active agent on timeout\n            activeAgent = null;\n            activeAgentIntent = null;\n\n            originalSender.Tell(new Records.ConversationResponse(\n                \"I apologize, but the request took too long to process. Please try again.\",\n                null,\n                null,\n                \"Morgana\",\n                false,\n                null,\n                DateTime.UtcNow));\n\n            Become(Idle);\n        });\n\n        // Forward streaming chunks from active agent to manager (and then to client)\n        // Reset timeout on each chunk to prevent timeout during active streaming\n        Receive<Records.AgentStreamChunk>(chunk =>\n        {\n            // Reset timeout - we're getting data, agent is alive\n            Context.SetReceiveTimeout(TimeSpan.FromSeconds(90));\n            originalSender.Tell(chunk);\n        });\n\n        // Handle follow-up response from currently active agent (direct Tell, not PipeTo)\n        Receive<Records.AgentResponse>(response =>\n        {\n            // Clear timeout immediately upon receiving response\n            Context.SetReceiveTimeout(null);\n\n            try\n            {\n                string agentName = activeAgentIntent != null ? GetAgentDisplayName(activeAgentIntent) : \"Morgana\";\n\n                if (response.IsCompleted)\n                {\n                    actorLogger.Info(\"Active agent signaled completion, clearing active agent\");\n\n                    activeAgent = null;\n                    activeAgentIntent = null;\n                }\n\n                originalSender.Tell(new Records.ConversationResponse(\n                    response.Response,\n                    null,\n                    null,\n                    agentName,\n                    response.IsCompleted,\n                    response.QuickReplies,\n                    DateTime.UtcNow)); // Using UtcNow since we don't have original timestamp with Tell\n\n                Become(Idle);\n            }\n            catch (Exception ex)\n            {\n                actorLogger.Error(ex, \"Error processing follow-up AgentResponse\");\n\n                // Clear active agent on error\n                activeAgent = null;\n                activeAgentIntent = null;\n\n                // Send error response to manager\n                originalSender.Tell(new Records.ConversationResponse(\n                    \"An error occurred while processing the response. Please try again.\",\n                    null,\n                    null,\n                    \"Morgana\",\n                    false,\n                    null,\n                    DateTime.UtcNow));\n\n                Become(Idle);\n            }\n        });\n\n        // Re-register common handlers for FSM behavior consistency\n        RegisterCommonHandlers();\n    }\n\n    #endregion\n\n    #region Helper Methods\n\n    /// <summary>\n    /// Gets the display name for an agent based on its intent.\n    /// Returns \"Morgana\" for the \"other\" intent or missing intents.\n    /// Returns \"Morgana (Intent)\" for specialized intents.\n    /// </summary>\n    /// <param name=\"intent\">Intent name to format</param>\n    /// <returns>Formatted agent display name</returns>\n    private string GetAgentDisplayName(string? intent)\n    {\n        if (string.IsNullOrEmpty(intent) || string.Equals(intent, \"other\", StringComparison.OrdinalIgnoreCase))\n            return \"Morgana\";\n\n        // Capitalize first letter of intent for display\n        string capitalizedIntent = char.ToUpper(intent[0]) + intent[1..];\n\n        return $\"Morgana ({capitalizedIntent})\";\n    }\n\n    /// <summary>\n    /// Handles unexpected failures in the Idle state.\n    /// Sends error message to sender and remains in Idle state.\n    /// </summary>\n    /// <param name=\"failure\">Failure information</param>\n    private void HandleUnexpectedFailure(Records.FailureContext failure)\n    {\n        actorLogger.Error(failure.Failure.Cause, \"Unexpected failure in ConversationSupervisorActor\");\n\n        failure.OriginalSender.Tell(\n            new Records.ConversationResponse(\"An internal error occurred.\", null, null, \"Morgana\", false));\n    }\n\n    /// <summary>\n    /// Restores the active agent state when resuming a conversation from persistence.\n    /// This allows multi-turn conversations to continue seamlessly after application restart.\n    /// Registered as common handler across all FSM states.\n    /// </summary>\n    /// <param name=\"msg\">Restoration request containing the agent intent</param>\n    private void HandleRestoreActiveAgent(Records.RestoreActiveAgent msg)\n    {\n        actorLogger.Info($\"Restoring active agent: {msg.AgentIntent}\");\n\n        // No active agent -> Fallback to Morgana\n        if (string.Equals(msg.AgentIntent, \"Morgana\", StringComparison.OrdinalIgnoreCase))\n        {\n            // Fallback: clear active agent, next message will reclassify\n            activeAgent = null;\n            activeAgentIntent = null;\n\n            actorLogger.Info($\"No active agent detected: fallback to Morgana\");\n            return;\n        }\n\n        // Delegate to router for agent resolution and caching using Tell pattern\n        router.Tell(new Records.RestoreAgentRequest(msg.AgentIntent));\n    }\n\n    /// <summary>\n    /// Handles the response from RouterActor after agent restoration request.\n    /// Sets or clears the active agent based on resolution success.\n    /// </summary>\n    /// <param name=\"response\">Response containing resolved agent reference or null</param>\n    private void HandleRestoreAgentResponse(Records.RestoreAgentResponse response)\n    {\n        if (response.AgentRef != null)\n        {\n            activeAgent = response.AgentRef;\n            activeAgentIntent = response.AgentIntent;\n\n            actorLogger.Info($\"Active agent restored: {activeAgent.Path} with intent {activeAgentIntent}\");\n        }\n        else\n        {\n            // Intent not recognized or agent not available\n            // Fallback: clear active agent, next message will reclassify\n            activeAgent = null;\n            activeAgentIntent = null;\n\n            actorLogger.Warning($\"Could not restore agent for intent '{response.AgentIntent}' - clearing active agent\");\n        }\n    }\n\n    /// <inheritdoc/>\n    protected override void RegisterCommonHandlers()\n    {\n        base.RegisterCommonHandlers();\n\n        // Specific handlers for supervisor\n        Receive<Records.RestoreActiveAgent>(HandleRestoreActiveAgent);\n        Receive<Records.RestoreAgentResponse>(HandleRestoreAgentResponse);\n        Receive<Records.FailureContext>(HandleUnexpectedFailure);\n    }\n\n    #endregion\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Actors/ConversationSupervisorActor.cs b/Morgana.Framework/Actors/ConversationSupervisorActor.cs
--- a/Morgana.Framework/Actors/ConversationSupervisorActor.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Actors/ConversationSupervisorActor.cs	(date 1770321345960)
@@ -177,7 +177,8 @@
                     [], // No quick replies
                     null,
                     "Morgana",
-                    false);
+                    false,
+                    null); // No rich card
 
                 return;
             }
@@ -268,7 +269,8 @@
                 quickReplies,
                 null,
                 "Morgana",
-                false);
+                false,
+                null); // No rich card
 
             actorLogger.Info("Presentation sent successfully");
         }
@@ -462,8 +464,9 @@
                 ctx.Classification?.Metadata,
                 GetAgentDisplayName(ctx.Classification?.Intent),
                 false,
-                null,
-                ctx.OriginalMessage.Timestamp));
+                null, // No quick replies
+                ctx.OriginalMessage.Timestamp,
+                null)); // No rich card
 
             Become(Idle);
         });
@@ -512,7 +515,8 @@
                     agentName,
                     response.IsCompleted,
                     response.QuickReplies,
-                    ctx.OriginalMessage.Timestamp));
+                    ctx.OriginalMessage.Timestamp,
+                    response.RichCard));
 
                 Become(Idle);
             }
@@ -531,8 +535,9 @@
                     ctx.Classification?.Metadata,
                     GetAgentDisplayName(ctx.Classification?.Intent),
                     false,
-                    null,
-                    ctx.OriginalMessage.Timestamp));
+                    null, // No quick replies
+                    ctx.OriginalMessage.Timestamp,
+                    null)); // No rich card
 
                 Become(Idle);
             }
@@ -555,7 +560,8 @@
                     "Morgana",
                     true,
                     response.QuickReplies,
-                    DateTime.UtcNow));
+                    DateTime.UtcNow,
+                    response.RichCard));
 
                 Become(Idle);
             }
@@ -569,8 +575,9 @@
                     null,
                     "Morgana",
                     false,
-                    null,
-                    DateTime.UtcNow));
+                    null, // No quick replies
+                    DateTime.UtcNow,
+                    null)); // No rich card
 
                 Become(Idle);
             }
@@ -610,8 +617,9 @@
                 null,
                 "Morgana",
                 false,
-                null,
-                DateTime.UtcNow));
+                null, // No quick replies
+                DateTime.UtcNow,
+                null)); // No rich card
 
             Become(Idle);
         });
@@ -650,7 +658,8 @@
                     agentName,
                     response.IsCompleted,
                     response.QuickReplies,
-                    DateTime.UtcNow)); // Using UtcNow since we don't have original timestamp with Tell
+                    DateTime.UtcNow, // Using UtcNow since we don't have original timestamp with Tell
+                    response.RichCard));
 
                 Become(Idle);
             }
@@ -669,8 +678,9 @@
                     null,
                     "Morgana",
                     false,
-                    null,
-                    DateTime.UtcNow));
+                    null, // No quick replies
+                    DateTime.UtcNow,
+                    null)); // No rich card
 
                 Become(Idle);
             }
Index: Morgana.Framework/Actors/ConversationManagerActor.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Akka.Actor;\nusing Akka.Event;\nusing Morgana.Framework.Abstractions;\nusing Morgana.Framework.Extensions;\nusing Morgana.Framework.Interfaces;\n\nnamespace Morgana.Framework.Actors;\n\n/// <summary>\n/// Entry point actor for managing conversations.\n/// Responsible for conversation lifecycle (creation/termination) and message routing to the supervisor.\n/// Uses PipeTo pattern for non-blocking communication with the supervisor.\n/// </summary>\n/// <remarks>\n/// This actor serves as the primary interface between the external system (SignalR) and the internal actor hierarchy.\n/// It maintains a reference to the ConversationSupervisorActor and forwards user messages for processing.\n/// </remarks>\npublic class ConversationManagerActor : MorganaActor\n{\n    private readonly ISignalRBridgeService signalRBridgeService;\n\n    /// <summary>\n    /// Reference to the active conversation supervisor actor.\n    /// Null until a conversation is created.\n    /// </summary>\n    private IActorRef? supervisor;\n\n    /// <summary>\n    /// Initializes a new instance of the ConversationManagerActor.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier for this conversation</param>\n    /// <param name=\"signalRBridgeService\">Service for sending messages to clients via SignalR</param>\n    /// <param name=\"llmService\">LLM service for AI completions</param>\n    /// <param name=\"promptResolverService\">Service for resolving prompt templates</param>\n    public ConversationManagerActor(\n        string conversationId,\n        ISignalRBridgeService signalRBridgeService,\n        ILLMService llmService,\n        IPromptResolverService promptResolverService) : base(conversationId, llmService, promptResolverService)\n    {\n        this.signalRBridgeService = signalRBridgeService;\n\n        // Handle incoming user messages from SignalR:\n        // - Ensures supervisor exists (creates if missing)\n        // - Forwards message to supervisor using Tell to support streaming\n        ReceiveAsync<Records.UserMessage>(HandleUserMessageAsync);\n\n        // Handle conversation lifecycle requests:\n        // - CreateConversation: creates supervisor actor, triggers automatic presentation generation\n        // - TerminateConversation: stops supervisor actor and clears reference\n        ReceiveAsync<Records.CreateConversation>(HandleCreateConversationAsync);\n        ReceiveAsync<Records.TerminateConversation>(HandleTerminateConversationAsync);\n\n        // Handle supervisor responses (direct Tell, not PipeTo):\n        // - ConversationResponse: final response from supervisor → send to client via SignalR\n        ReceiveAsync<Records.ConversationResponse>(HandleConversationResponseAsync);\n        \n        // Handle streaming chunks from supervisor and forward to client via SignalR\n        ReceiveAsync<Records.AgentStreamChunk>(HandleStreamChunkAsync);\n    }\n\n    /// <summary>\n    /// Handles conversation creation requests.\n    /// Creates and watches the supervisor actor, then triggers automatic presentation generation.\n    /// </summary>\n    /// <param name=\"msg\">Conversation creation request message</param>\n    private async Task HandleCreateConversationAsync(Records.CreateConversation msg)\n    {\n        actorLogger.Info($\"Creating conversation {msg.ConversationId}\");\n\n        if (supervisor is null)\n        {\n            supervisor = await Context.System.GetOrCreateActor<ConversationSupervisorActor>(\n                \"supervisor\", msg.ConversationId);\n\n            Context.Watch(supervisor);\n\n            actorLogger.Info(\"Supervisor created: {0}\", supervisor.Path);\n\n            // Trigger automatic presentation (only in case of new conversation)\n            if (!msg.IsRestore)\n            {\n                supervisor.Tell(new Records.GeneratePresentationMessage());\n\n                actorLogger.Info(\"Presentation generation triggered\");\n            }\n        }\n    }\n\n    /// <summary>\n    /// Handles conversation termination requests.\n    /// Stops the supervisor actor and clears the reference.\n    /// </summary>\n    /// <param name=\"msg\">Conversation termination request message</param>\n    private Task HandleTerminateConversationAsync(Records.TerminateConversation msg)\n    {\n        actorLogger.Info($\"Terminating conversation {msg.ConversationId}\");\n\n        if (supervisor is not null)\n        {\n            Context.Stop(supervisor);\n\n            supervisor = null;\n\n            actorLogger.Info(\"Supervisor stopped for conversation {0}\", msg.ConversationId);\n        }\n\n        return Task.CompletedTask;\n    }\n\n    /// <summary>\n    /// Handles incoming user messages.\n    /// Ensures supervisor exists, then forwards the message using Tell to support streaming.\n    /// </summary>\n    /// <param name=\"msg\">User message to process</param>\n    /// <remarks>\n    /// Uses Tell pattern to support streaming chunks and final response separately.\n    /// </remarks>\n    private async Task HandleUserMessageAsync(Records.UserMessage msg)\n    {\n        actorLogger.Info($\"Received message in conversation {conversationId}: {msg.Text}\");\n\n        if (supervisor == null)\n        {\n            supervisor = await Context.System.GetOrCreateActor<ConversationSupervisorActor>(\n                \"supervisor\", msg.ConversationId);\n\n            Context.Watch(supervisor);\n\n            actorLogger.Warning(\"Supervisor was missing; created new supervisor: {0}\", supervisor.Path);\n        }\n\n        actorLogger.Info(\"Forwarding message to supervisor at {0}\", supervisor.Path);\n\n        // Use Tell instead of Ask to support streaming\n        supervisor.Tell(msg);\n    }\n\n    /// <summary>\n    /// Handles streaming chunks from the supervisor and forwards them to the client via SignalR.\n    /// Enables real-time progressive response rendering in the UI.\n    /// </summary>\n    /// <param name=\"chunk\">Streaming chunk containing partial response text</param>\n    private async Task HandleStreamChunkAsync(Records.AgentStreamChunk chunk)\n    {\n        // Forward chunk to client via SignalR for progressive rendering\n        try\n        {\n            await signalRBridgeService.SendStreamChunkAsync(conversationId, chunk.Text);\n        }\n        catch (Exception ex)\n        {\n            actorLogger.Error(ex, \"Failed to send stream chunk to client\");\n            // Don't propagate error - continue streaming\n        }\n    }\n\n    /// <summary>\n    /// Handles final response from supervisor (direct Tell, not PipeTo wrapper).\n    /// Sends the response to the client via SignalR with appropriate metadata.\n    /// </summary>\n    /// <param name=\"response\">ConversationResponse from supervisor</param>\n    private async Task HandleConversationResponseAsync(Records.ConversationResponse response)\n    {\n        actorLogger.Info(\n            $\"Received response from supervisor (agent: {response.AgentName ?? \"unknown\"}, completed: {response.AgentCompleted}): \" +\n            $\"{response.Response[..Math.Min(50, response.Response.Length)]}..., #quickReplies: {response.QuickReplies?.Count ?? 0}\");\n\n        // Send response to client via SignalR\n        try\n        {\n            await signalRBridgeService.SendStructuredMessageAsync(\n                conversationId,\n                response.Response,\n                \"assistant\",\n                response.QuickReplies,\n                null,\n                response.AgentName,\n                response.AgentCompleted,\n                response.OriginalTimestamp);\n\n            actorLogger.Info($\"Response sent successfully to client via SignalR (#quickReplies: {response.QuickReplies?.Count ?? 0})\");\n        }\n        catch (Exception ex)\n        {\n            actorLogger.Error(ex, \"Failed to send SignalR message to client\");\n\n            // Attempt to send error notification to client\n            try\n            {\n                await signalRBridgeService.SendStructuredMessageAsync(\n                    conversationId,\n                    \"An error occurred while sending the response.\",\n                    \"assistant\",\n                    null,\n                    $\"delivery_error: {ex.Message}\",\n                    \"Morgana\",\n                    false);\n            }\n            catch (Exception fallbackEx)\n            {\n                actorLogger.Error(fallbackEx, \"Failed to send error notification to client\");\n            }\n        }\n    }\n\n    /// <summary>\n    /// Actor lifecycle hook: called when actor starts.\n    /// </summary>\n    protected override void PreStart()\n    {\n        actorLogger.Info($\"ConversationManagerActor started for {conversationId}\");\n        base.PreStart();\n    }\n\n    /// <summary>\n    /// Actor lifecycle hook: called when actor stops.\n    /// </summary>\n    protected override void PostStop()\n    {\n        actorLogger.Info($\"ConversationManagerActor stopped for {conversationId}\");\n        base.PostStop();\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Actors/ConversationManagerActor.cs b/Morgana.Framework/Actors/ConversationManagerActor.cs
--- a/Morgana.Framework/Actors/ConversationManagerActor.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Actors/ConversationManagerActor.cs	(date 1770321594186)
@@ -163,8 +163,11 @@
     private async Task HandleConversationResponseAsync(Records.ConversationResponse response)
     {
         actorLogger.Info(
-            $"Received response from supervisor (agent: {response.AgentName ?? "unknown"}, completed: {response.AgentCompleted}): " +
-            $"{response.Response[..Math.Min(50, response.Response.Length)]}..., #quickReplies: {response.QuickReplies?.Count ?? 0}");
+            $"Received response from supervisor (agent: {response.AgentName ?? "unknown"}," +
+            $"completed: {response.AgentCompleted}): " +
+            $"{response.Response[..Math.Min(50, response.Response.Length)]}...," +
+            $"#quickReplies: {response.QuickReplies?.Count ?? 0}" +
+            $"#richCard: {response.RichCard != null}");
 
         // Send response to client via SignalR
         try
@@ -177,9 +180,13 @@
                 null,
                 response.AgentName,
                 response.AgentCompleted,
-                response.OriginalTimestamp);
+                response.OriginalTimestamp,
+                response.RichCard);
 
-            actorLogger.Info($"Response sent successfully to client via SignalR (#quickReplies: {response.QuickReplies?.Count ?? 0})");
+            actorLogger.Info(
+                $"Response sent successfully to client via SignalR " +
+                $"(#quickReplies: {response.QuickReplies?.Count ?? 0}," +
+                $"hasRichCard: {response.RichCard != null})");
         }
         catch (Exception ex)
         {
@@ -195,7 +202,8 @@
                     null,
                     $"delivery_error: {ex.Message}",
                     "Morgana",
-                    false);
+                    false,
+                    null);
             }
             catch (Exception fallbackEx)
             {
Index: ../Cauldron/Pages/_Host.cshtml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>@page \"/\"\n@namespace Cauldron.Pages\n@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <base href=\"~/\" />\n\n        <!-- Page title displayed in browser tab -->\n        <title>Morgana - Magical AI Assistant</title>\n\n        <!-- Favicon Configuration -->\n        <!-- Multiple formats for cross-browser and device compatibility -->\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"~/favicon.ico\" />\n        <link rel=\"shortcut icon\" href=\"~/favicon.ico\">\n        <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"~/images/morgana-avatar.png\" />\n        <link rel=\"apple-touch-icon\" href=\"~/images/morgana-avatar.png\" />\n\n        <!-- Stylesheet Imports -->\n        <!-- Loaded in order: base styles → component styles → specialized features -->\n        <link href=\"css/site.css\" rel=\"stylesheet\" />                    <!-- Base site styles and variables -->\n        <link href=\"css/cauldron.css\" rel=\"stylesheet\" />                <!-- Send button styles -->\n        <link href=\"css/quick-reply.css\" rel=\"stylesheet\" />             <!-- Quick reply button styles -->\n        <link href=\"css/sparkle-loader.css\" rel=\"stylesheet\" />          <!-- Loading animation styles -->\n        <link href=\"css/new-conversation-button.css\" rel=\"stylesheet\" /> <!-- New conversation button style -->\n        <link href=\"css/confirm-modal.css\" rel=\"stylesheet\" />           <!-- Confirmation modal styles -->\n        <link href=\"css/fading-message.css\" rel=\"stylesheet\" />          <!-- Fading message styles -->\n        <link href=\"css/typing-indicator.css\" rel=\"stylesheet\" />        <!-- Typing indicator styles -->\n    </head>\n    <body>\n        <!-- Blazor Server Root Component -->\n        <!-- The entire application is rendered as a server-side component -->\n        <!-- UI updates are sent to the browser via SignalR WebSocket connection -->\n        <component type=\"typeof(App)\" render-mode=\"Server\" />\n\n        <!-- Blazor Error UI -->\n        <!-- Displayed automatically when an unhandled exception occurs in a component -->\n        <!-- Hidden by default, shown via JavaScript when Blazor detects an error -->\n        <div id=\"blazor-error-ui\" style=\"display: none;\">\n            An error has occurred.\n            <a href=\"\" class=\"reload\">Reload</a>\n            <a class=\"dismiss\">\uD83D\uDDD9</a>\n        </div>\n\n        <!-- Blazor Server JavaScript -->\n        <!-- Establishes SignalR connection for UI updates and event handling -->\n        <!-- Automatically reconnects on connection loss -->\n        <script src=\"_framework/blazor.server.js\"></script>\n    </body>\n</html>\n\n@*\n    ============================================================================\n    _HOST.CSHTML - BLAZOR SERVER ENTRY POINT\n    ============================================================================\n\n    PURPOSE:\n    This is the root HTML page for the Cauldron Blazor Server application.\n    It provides the initial HTML shell and loads the necessary resources.\n\n    BLAZOR SERVER ARCHITECTURE:\n\n    1. Initial Request (Browser → Server)\n       - Browser requests \"/\"\n       - Server returns this _Host.cshtml HTML\n       - HTML includes <component> tag helper\n       - Server renders App component to HTML\n       - Browser receives fully-rendered page\n\n    2. SignalR Connection Establishment\n       - blazor.server.js loads and executes\n       - JavaScript establishes SignalR WebSocket connection\n       - Connection used for all subsequent UI updates\n    \n    3. Interactive Phase (Browser ↔ Server)\n       - User interactions (clicks, typing) sent via SignalR\n       - Server processes events and updates component state\n       - Server sends DOM diffs via SignalR\n       - Browser applies patches to update UI\n\n    RENDER MODE: SERVER\n    - Components execute on the server\n    - UI state maintained on server\n    - Only DOM updates sent to client\n    - Benefits: No client-side Blazor runtime, instant initial load\n    - Trade-offs: Requires persistent connection, server resources per client\n\n    ERROR HANDLING:\n    The blazor-error-ui div is shown automatically by Blazor when:\n    - Unhandled exception in component lifecycle\n    - SignalR connection lost and reconnection fails\n    - Component rendering errors\n\n    User can either:\n    - Reload: Restart the entire application\n    - Dismiss: Hide the error banner (may cause issues)\n\n    RESOURCE LOADING ORDER:\n    1. favicon.ico (browser tab icon)\n    2. CSS stylesheets (site → cauldron → quick-reply → sparkle-loader)\n    3. Blazor Server component rendering\n    4. blazor.server.js (establishes SignalR connection)\n*@
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Cauldron/Pages/_Host.cshtml b/../Cauldron/Pages/_Host.cshtml
--- a/../Cauldron/Pages/_Host.cshtml	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/../Cauldron/Pages/_Host.cshtml	(date 1770322111915)
@@ -24,6 +24,7 @@
         <link href="css/site.css" rel="stylesheet" />                    <!-- Base site styles and variables -->
         <link href="css/cauldron.css" rel="stylesheet" />                <!-- Send button styles -->
         <link href="css/quick-reply.css" rel="stylesheet" />             <!-- Quick reply button styles -->
+        <link href="css/rich-card.css" rel="stylesheet" />               <!-- Rich card styles -->
         <link href="css/sparkle-loader.css" rel="stylesheet" />          <!-- Loading animation styles -->
         <link href="css/new-conversation-button.css" rel="stylesheet" /> <!-- New conversation button style -->
         <link href="css/confirm-modal.css" rel="stylesheet" />           <!-- Confirmation modal styles -->
Index: ../Cauldron/Pages/Index.razor
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>@page \"/\"\n@using Cauldron.Services\n@inject MorganaSignalRService SignalRService\n@inject MorganaLandingMessageService LandingMessageService\n@inject IConversationStorageService StorageService\n@inject IConversationHistoryService HistoryService\n@inject NavigationManager NavigationManager\n@inject HttpClient Http\n@inject IConfiguration Configuration\n@implements IAsyncDisposable\n\n<PageTitle>Morgana - Magical AI Assistant</PageTitle>\n\n<div class=\"chat-container\">\n    <!-- Header -->\n    <div class=\"chat-header\">\n        <div class=\"header-content\">\n\n            <img src=\"images/morgana-avatar.png\" \n                 alt=\"Morgana\" \n                 class=\"header-avatar\"\n                 style=\"border: 3px solid @GetAvatarBorderColor(currentAgentName);\" />\n\n            <div class=\"header-info\">\n                <h1 style=\"color: @GetAvatarBorderColor(currentAgentName);\">@currentAgentName</h1>\n                <span class=\"status @(isConnected ? \"online\" : \"offline\")\" style=\"color: @(isConnected ? \"#10b981\" : \"#ef4444\");\">\n                    @(isConnected ? \"Online\" : \"Offline\")\n                </span>\n            </div>\n\n            <button class=\"new-conversation-btn @(IsNewConversationButtonVisible ? \"visible\" : \"hidden\")\"\n                    @onclick=\"ShowConfirmModal\"\n                    title=\"Start a new conversation with Morgana\">\n                <span class=\"btn-icon\">✨</span>\n                <span class=\"btn-text\">New Conversation</span>\n            </button>\n\n        </div>\n    </div>\n\n    <!-- Messages Area -->\n    <div class=\"messages-container\">\n\n        @* ============ TEMPORARY SYSTEM WARNINGS (always on top) ================================ *@\n        @if (temporaryMessages.Any())\n        {\n            <div class=\"temporary-messages-container\">\n                @foreach (SignalRMessage temporaryMessage in temporaryMessages)\n                {\n                    <FadingMessage Message=\"@temporaryMessage\"\n                                   DurationSeconds=\"@(temporaryMessage.FadingMessageDurationSeconds ?? 10)\"\n                                   OnDismissed=\"@HandleMessageDismissed\"/>\n                }\n            </div>\n        }\n        @* ======================================================================================= *@\n\n        @if (chatMessages.Count == 0)\n        {\n            <!-- Loading state with magical animation -->\n            <!-- Loader visible until first message arrives from backend (presentation or conversation history) -->\n            <div class=\"magical-loader\">\n                <div class=\"magic-sparkle-core\">\n                    <div class=\"glow-core\"></div>\n                    <div class=\"glow-ring ring-1\"></div>\n                    <div class=\"glow-ring ring-2\"></div>\n                    <div class=\"glow-ring ring-3\"></div>\n                </div>\n                <div class=\"sparkles-container\">\n                    <div class=\"sparkle sp1\"></div>\n                    <div class=\"sparkle sp2\"></div>\n                    <div class=\"sparkle sp3\"></div>\n                    <div class=\"sparkle sp4\"></div>\n                    <div class=\"sparkle sp5\"></div>\n                    <div class=\"sparkle sp6\"></div>\n                    <div class=\"sparkle sp7\"></div>\n                    <div class=\"sparkle sp8\"></div>\n                    <div class=\"sparkle sp9\"></div>\n                    <div class=\"sparkle sp10\"></div>\n                    <div class=\"sparkle sp11\"></div>\n                    <div class=\"sparkle sp12\"></div>\n                </div>\n                <p class=\"loading-text\">@(landingMessage)</p>\n            </div>\n        }\n        else\n        {\n            <!-- Message list -->\n            @foreach (ChatMessage chatMessage in chatMessages)\n            {\n                <div class=\"message @chatMessage.Role\">\n                    @if (chatMessage.Role == \"assistant\")\n                    {\n                        <!-- Agent avatar with dynamic border color -->\n                        <img src=\"images/morgana-avatar.png\"\n                             alt=\"@chatMessage.AgentName\"\n                             class=\"message-avatar\"\n                             style=\"border: 2px solid @GetAvatarBorderColor(chatMessage.AgentName);\"/>\n                    }\n                    <div class=\"message-bubble @(chatMessage.IsStreaming ? \"streaming\" : \"\")\">\n                        @if (chatMessage.IsTyping)\n                        {\n                            <!-- Typing indicator (sparkles stars) -->\n                            <div class=\"typing-indicator @(IsSpecializedAgent(chatMessage.AgentName) ? \"specialized\" : \"base\")\">\n                                <span><svg viewBox=\"0 0 24 24\"><path d=\"M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z\"/></svg></span>\n                                <span><svg viewBox=\"0 0 24 24\"><path d=\"M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z\"/></svg></span>\n                                <span><svg viewBox=\"0 0 24 24\"><path d=\"M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z\"/></svg></span>\n                            </div>\n                        }\n                        else\n                        {\n                            <!-- Message content -->\n                            <div class=\"message-text @(chatMessage.Type == MessageType.Presentation ? \"completion-text\" : \"\")\">\n                                @chatMessage.Text\n                            </div>\n\n                            @if (chatMessage is { QuickReplies: { Count: > 0 }, IsStreaming: false })\n                            {\n                                <QuickReplyButton Replies=\"@chatMessage.QuickReplies\"\n                                                  OnSelect=\"@((reply) => SelectQuickReplyAsync(reply, chatMessage))\"\n                                                  IsDisabled=\"@(chatMessage.SelectedQuickReplyId != null || chatMessage.IsLastHistoryMessage == false)\"\n                                                  SelectedReplyId=\"@chatMessage.SelectedQuickReplyId\"/>\n                            }\n\n                            <!-- Message timestamp -->\n                            <div class=\"message-time\">@chatMessage.Timestamp.ToString(\"HH:mm\")</div>\n                        }\n                    </div>\n                </div>\n            }\n        }\n    </div>\n\n    <!-- Input Area -->\n    <div class=\"input-container\">\n        <textarea\n            @bind=\"inputText\"\n            @bind:event=\"oninput\"\n            @onkeyup=\"HandleKeyPressAsync\"\n            placeholder=\"Consult @(currentAgentName)...\"\n            rows=\"1\"\n            disabled=\"@IsTextareaDisabled\"\n            class=\"message-input @(IsSpecializedAgent(currentAgentName) ? \"agent\" : \"morgana\")\"></textarea>\n        <button\n            @onclick=\"SendMessageAsync\"\n            disabled=\"@IsSendButtonDisabled\"\n            class=\"send-button @(isSending ? \"sending\" : \"\") @(IsSpecializedAgent(currentAgentName) ? \"agent\" : \"morgana\")\">\n            <!-- Animated cauldron icon with magical effects -->\n            <span class=\"cauldron-wrapper\">\n                <span class=\"cauldron-icon\">\n                    <span class=\"cauldron-body @(IsSpecializedAgent(currentAgentName) ? \"agent\" : \"morgana\")\"></span>\n                    <span class=\"brew-surface\"></span>\n                    <span class=\"bubble b1\"></span>\n                    <span class=\"bubble b2\"></span>\n                    <span class=\"bubble b3\"></span>\n                    <span class=\"bubble b4\"></span>\n                    <span class=\"steam st1\"></span>\n                    <span class=\"steam st2\"></span>\n                    <span class=\"steam st3\"></span>\n                </span>\n                <span class=\"magic-glow\"></span>\n                <span class=\"magic-ring\"></span>\n                <span class=\"sparkle s1\"></span>\n                <span class=\"sparkle s2\"></span>\n                <span class=\"sparkle s3\"></span>\n                <span class=\"sparkle s4\"></span>\n                <span class=\"sparkle s5\"></span>\n                <span class=\"sparkle s6\"></span>\n            </span>\n        </button>\n    </div>\n</div>\n\n<!-- Confirmation Modal for New Conversation -->\n<ConfirmModal IsVisible=\"@showConfirmModal\"\n              Title=\"Start New Conversation?\"\n              Message=\"This will start a new conversation with Morgana. Your chat history will be lost. Are you sure you want to continue?\"\n              ConfirmText=\"Yes, start new\"\n              CancelText=\"No, stay here\"\n              OnConfirm=\"@ConfirmNewConversationAsync\"\n              OnCancel=\"@HideConfirmModal\" />\n\n@code {\n    // =========================================================================\n    // STATE VARIABLES\n    // =========================================================================\n\n    /// <summary>\n    /// List of all chat messages in the current conversation.\n    /// Includes user messages, agent responses, typing indicators, and presentation messages.\n    /// </summary>\n    private List<ChatMessage> chatMessages = [];\n\n    /// <summary>\n    /// List of active temporary system warnings (rate limit errors, etc.).\n    /// Rendered as auto-dismissing banners via FadingMessage component.\n    /// </summary>\n    private List<SignalRMessage> temporaryMessages = [];\n\n    /// <summary>\n    /// Current text input from the user (two-way bound to textarea).\n    /// </summary>\n    private string inputText = string.Empty;\n\n    /// <summary>\n    /// Unique identifier for the current conversation.\n    /// Generated on conversation start and used for message routing.\n    /// </summary>\n    private string conversationId = string.Empty;\n\n    /// <summary>\n    /// SignalR connection state indicator.\n    /// True when connected and ready to receive messages.\n    /// </summary>\n    private bool isConnected;\n\n    /// <summary>\n    /// Message send operation in progress indicator.\n    /// True during HTTP POST to prevent duplicate sends.\n    /// </summary>\n    private bool isSending;\n\n    /// <summary>\n    /// Initialization complete indicator.\n    /// True after SignalR connection and conversation start succeed.\n    /// </summary>\n    private bool isInitialized;\n\n    /// <summary>\n    /// Controls visibility of the new conversation confirmation modal.\n    /// </summary>\n    private bool showConfirmModal;\n\n    /// <summary>\n    /// Name of the currently active agent.\n    /// Updates dynamically when agents take control: \"Morgana\", \"Morgana (Billing)\", etc.\n    /// Displayed in header and used for avatar border color.\n    /// </summary>\n    private string currentAgentName = \"Morgana\";\n\n    /// <summary>\n    /// Landing message (waiting for Morgana presentation).\n    /// </summary>\n    private string landingMessage = string.Empty;\n\n    /// <summary>\n    /// Flag to track if storage has been checked (prevents multiple checks on re-renders).\n    /// </summary>\n    private bool hasCheckedStorage;\n\n    // =========================================================================\n    // STREAMING STATE VARIABLES\n    // =========================================================================\n\n    /// <summary>\n    /// Buffer containing chunks received from backend that haven't been displayed yet.\n    /// Used by the typewriter effect to progressively render text.\n    /// </summary>\n    private string streamingBuffer = string.Empty;\n\n    /// <summary>\n    /// Timer for typewriter effect animation.\n    /// Fires every 50ms to display next character from streaming buffer.\n    /// </summary>\n    private Timer? typewriterTimer;\n\n    /// <summary>\n    /// Reference to the message currently being streamed.\n    /// Null when no streaming is in progress.\n    /// </summary>\n    private ChatMessage? currentStreamingMessage;\n\n    // =========================================================================\n    // LIFECYCLE METHODS\n    // =========================================================================\n\n    /// <summary>\n    /// Blazor lifecycle method called when component is initialized.\n    /// Sets up SignalR connection and subscribes to events.\n    /// Note: ProtectedLocalStorage check moved to OnAfterRenderAsync for JavaScript interop availability.\n    /// </summary>\n    /// <returns>Task representing the async initialization</returns>\n    protected override async Task OnInitializedAsync()\n    {\n        try\n        {\n            Console.WriteLine(\"\uD83D\uDD35 OnInitializedAsync: Starting...\");\n\n            // Initialize landing message\n            landingMessage = LandingMessageService.GetRandomLandingMessage();\n\n            // Start SignalR connection\n            await SignalRService.StartAsync();\n            isConnected = SignalRService.IsConnected;\n            Console.WriteLine($\"\uD83D\uDD35 SignalR connected: {isConnected}\");\n\n            // Subscribe to message received events\n            SignalRService.OnMessageReceived += HandleMessageReceivedAsync;\n\n            // Subscribe to streaming chunks for progressive rendering\n            SignalRService.OnStreamChunkReceived += HandleStreamChunkReceivedAsync;\n\n            // Subscribe to connection state changes\n            SignalRService.OnConnectionStateChanged += (connected) =>\n            {\n                isConnected = connected;\n                Console.WriteLine($\"\uD83D\uDD35 Connection state changed: {connected}\");\n                InvokeAsync(StateHasChanged);\n            };\n\n            Console.WriteLine(\"\uD83D\uDD35 Initialization complete. Checking storage for existing conversation...\");\n\n            if (!hasCheckedStorage)\n            {\n                hasCheckedStorage = true;\n\n                try\n                {\n                    // Check ProtectedLocalStorage for saved conversation ID\n                    string? savedConversationId = await StorageService.GetConversationIdAsync();\n\n                    if (!string.IsNullOrEmpty(savedConversationId))\n                    {\n                        Console.WriteLine($\"\uD83D\uDD35 Found saved conversation ID: {savedConversationId}\");\n                        await ResumeConversationAsync(savedConversationId);\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"\uD83D\uDD35 No saved conversation found, starting new\");\n                        await StartConversationAsync();\n                    }\n\n                    isInitialized = true;\n                    ClearErrorMessages();  // Clear any previous errors on successful init\n                    Console.WriteLine($\"\uD83D\uDD35 Initialized with conversationId: {conversationId}\");\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"❌ Storage check error: {ex.Message}\");\n                    AddErrorMessage($\"Initialization error: {ex.Message}\", \"initialization_failed\", 20);\n                }\n                finally\n                {\n                    await InvokeAsync(StateHasChanged);\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ Initialization error: {ex.Message}\");\n            AddErrorMessage($\"Critical initialization error: {ex.Message}\", \"critical_initialization_failed\", 30);\n            await InvokeAsync(StateHasChanged);\n        }\n    }\n\n    // =========================================================================\n    // CONVERSATION MANAGEMENT\n    // =========================================================================\n\n    /// <summary>\n    /// Resumes an existing conversation from ProtectedLocalStorage.\n    /// If resume fails (404), automatically falls back to starting a new conversation.\n    /// </summary>\n    /// <param name=\"savedConversationId\">The conversation ID retrieved from storage</param>\n    /// <returns>Task representing the async resume operation</returns>\n    /// <remarks>\n    /// <para><strong>Resume Flow:</strong></para>\n    /// <list type=\"number\">\n    /// <item>POST to /api/conversation/{id}/resume</item>\n    /// <item>Backend restores actor hierarchy and loads AgentThread from SQLite</item>\n    /// <item>Join SignalR group for this conversation</item>\n    /// <item>Backend may send welcome-back message via SignalR (optional)</item>\n    /// </list>\n    /// <para><strong>Fallback Scenarios:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item><term>404 Not Found</term><description>Conversation expired/deleted → Clear storage and start new</description></item>\n    /// <item><term>500 Server Error</term><description>Backend error → Clear storage and start new</description></item>\n    /// <item><term>Network Error</term><description>Connection failure → Clear storage and start new</description></item>\n    /// </list>\n    /// </remarks>\n    private async Task ResumeConversationAsync(string savedConversationId)\n    {\n        try\n        {\n            Console.WriteLine($\"\uD83D\uDFE1 ResumeConversation: Attempting to resume {savedConversationId}\");\n\n            // Call Morgana to resume the conversation\n            HttpResponseMessage response = await Http.PostAsync(\n                $\"/api/conversation/{savedConversationId}/resume\", null);\n\n            Console.WriteLine($\"\uD83D\uDFE1 Resume response status: {response.StatusCode}\");\n\n            if (response.IsSuccessStatusCode)\n            {\n                // Successfully resumed\n                ConversationResumeResponse? result = await response.Content\n                    .ReadFromJsonAsync<ConversationResumeResponse>();\n\n                conversationId = result?.ConversationId ?? savedConversationId;\n                if (string.IsNullOrEmpty(result?.ActiveAgent)\n                     || string.Equals(result.ActiveAgent, \"Morgana\", StringComparison.OrdinalIgnoreCase))\n                {\n                    currentAgentName = \"Morgana\";\n                }\n                else\n                {\n                    currentAgentName = $\"Morgana ({char.ToUpper(result.ActiveAgent[0]) + result.ActiveAgent.Substring(1)})\";\n                }\n                Console.WriteLine($\"\uD83D\uDFE1 Conversation resumed: {conversationId}, Active agent: {result?.ActiveAgent}\");\n\n                // Join SignalR group\n                await SignalRService.JoinConversation(conversationId);\n\n                Console.WriteLine($\"\uD83D\uDFE1 Loading conversation history for {conversationId}...\");\n\n                try\n                {\n                    ConversationHistoryResponse? history = await HistoryService.GetHistoryAsync(conversationId);\n\n                    if (history?.Messages is { Length: > 0 })\n                    {\n                        Console.WriteLine($\"\uD83D\uDFE1 Retrieved {history.Messages.Length} messages from history\");\n\n                        for (int i = 0; i < history.Messages.Length; i++)\n                        {\n                            #region Transient Hints\n                            if (string.Equals(history.Messages[i].Role, \"user\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                // Detect if this user message can be classified as \"agent's turn boundary\":\n                                // it is preceded by \"Agent X\" message and followed by \"Agent Y\" message\n                                bool isPrecededByAssistantMessage = i > 0 && string.Equals(history.Messages[i-1].Role, \"assistant\", StringComparison.OrdinalIgnoreCase);\n                                bool isFollowedByAssistantMessage = i + 1 < history.Messages.Length && string.Equals(history.Messages[i+1].Role, \"assistant\", StringComparison.OrdinalIgnoreCase);\n                                bool isTurnBoundaryMessage = isPrecededByAssistantMessage \n                                                              && isFollowedByAssistantMessage\n                                                              && !string.Equals(history.Messages[i-1].AgentName, history.Messages[i+1].AgentName, StringComparison.OrdinalIgnoreCase);\n                                if (isTurnBoundaryMessage)\n                                {\n                                    // Emit a transient \"Agent X has completed\" message, which is\n                                    // ephemeral and does not participate in the DB conversation\n                                    chatMessages.Add(new ChatMessage\n                                    {\n                                        ConversationId = history.Messages[i].ConversationId,\n                                        Text = GetCompletionMessage(history.Messages[i-1].AgentName!),\n                                        Role = \"assistant\",\n                                        Timestamp = history.Messages[i].Timestamp.AddMilliseconds(-5),\n                                        AgentName = \"Morgana\",\n                                        AgentCompleted = true,\n                                        Type = MessageType.Presentation\n                                    });\n                                }\n                            }\n                            #endregion\n\n                            chatMessages.Add(history.Messages[i]);\n                        }\n                        #region Transient Hints\n                        // Detect if the last history message can be classified as \"agent's turn boundary\":\n                        // it is an \"Agent X\" message, but Cauldron is back listening in \"Morgana\" mode\n                        ChatMessage lastHistoryMessage = history.Messages.Last();\n                        if (IsSpecializedAgent(lastHistoryMessage.AgentName) && !IsSpecializedAgent(currentAgentName))\n                        {\n                            // Emit a transient \"Agent X has completed\" message, which is\n                            // ephemeral and does not participate in the DB conversation\n                            chatMessages.Add(new ChatMessage\n                            {\n                                ConversationId = lastHistoryMessage.ConversationId,\n                                Text = GetCompletionMessage(lastHistoryMessage.AgentName!),\n                                Role = \"assistant\",\n                                Timestamp = lastHistoryMessage.Timestamp.AddMilliseconds(-5),\n                                AgentName = \"Morgana\",\n                                AgentCompleted = true,\n                                Type = MessageType.Presentation\n                            });\n                        }\n                        #endregion\n\n                        Console.WriteLine($\"\uD83D\uDFE1 Conversation history loaded successfully\");\n                    }\n                    else\n                    {\n                        Console.WriteLine($\"⚠\uFE0F No history found for conversation {conversationId}\");\n\n                        // Add a system message to force UI resume\n                        chatMessages.Add(new ChatMessage\n                        {\n                            ConversationId = conversationId,\n                            Text = LandingMessageService.GetRandomResumingMessage(),\n                            Role = \"assistant\",\n                            Timestamp = DateTime.UtcNow,\n                            AgentName = currentAgentName,\n                            Type = MessageType.Assistant\n                        });\n                    }\n                }\n                catch (Exception historyEx)\n                {\n                    Console.WriteLine($\"⚠\uFE0F Failed to load history: {historyEx.Message}\");\n\n                    // Add a system message to force UI resume\n                    chatMessages.Add(new ChatMessage\n                    {\n                        ConversationId = conversationId,\n                        Text = LandingMessageService.GetRandomResumingMessage(),\n                        Role = \"assistant\",\n                        Timestamp = DateTime.UtcNow,\n                        AgentName = currentAgentName,\n                        Type = MessageType.Assistant\n                    });\n                }\n\n                await InvokeAsync(StateHasChanged);\n\n                Console.WriteLine($\"\uD83D\uDFE1 Joined SignalR group, waiting for conversation history...\");\n            }\n            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                // Conversation not found in backend (expired or deleted)\n                Console.WriteLine($\"⚠\uFE0F Conversation {savedConversationId} not found, starting fresh\");\n                \n                // Clear corrupted/expired storage\n                await StorageService.ClearConversationIdAsync();\n                \n                // Fallback to new conversation\n                await StartConversationAsync();\n            }\n            else\n            {\n                // Other error (500, etc.)\n                string errorContent = await response.Content.ReadAsStringAsync();\n                Console.WriteLine($\"❌ Resume error {response.StatusCode}: {errorContent}\");\n                \n                // Clear corrupted/expired storage\n                await StorageService.ClearConversationIdAsync();\n\n                // Fallback to new conversation\n                await StartConversationAsync();\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ ResumeConversation exception: {ex.Message}\");\n            \n            // Clear corrupted/expired storage\n            await StorageService.ClearConversationIdAsync();\n\n            // Fallback to new conversation\n            await StartConversationAsync();\n        }\n    }\n\n    /// <summary>\n    /// Starts a new conversation with Morgana backend.\n    /// Sends POST request to /api/conversation/start, joins SignalR group, saves to storage, and displays presentation message.\n    /// </summary>\n    /// <returns>Task representing the async conversation start operation</returns>\n    /// <remarks>\n    /// <para><strong>Flow:</strong></para>\n    /// <list type=\"number\">\n    /// <item>Generate new conversation ID (GUID)</item>\n    /// <item>POST to /api/conversation/start</item>\n    /// <item>Extract conversationId from response</item>\n    /// <item>Join SignalR conversation group</item>\n    /// <item>Save conversationId to ProtectedLocalStorage</item>\n    /// <item>Wait for presentation message via SignalR</item>\n    /// <item>Display presentation with quick replies</item>\n    /// </list>\n    /// </remarks>\n    private async Task StartConversationAsync()\n    {\n        try\n        {\n            Console.WriteLine(\"\uD83D\uDFE2 StartConversation: Calling Morgana...\");\n\n            // Generate new conversation ID\n            HttpResponseMessage response = await Http.PostAsJsonAsync(\"/api/conversation/start\", new\n            {\n                conversationId = Guid.NewGuid().ToString(\"N\")\n            });\n\n            Console.WriteLine($\"\uD83D\uDFE2 Morgana Response Status: {response.StatusCode}\");\n\n            if (response.IsSuccessStatusCode)\n            {\n                // Parse response to get conversation ID\n                ConversationStartResponse? result = await response.Content.ReadFromJsonAsync<ConversationStartResponse>();\n                conversationId = result?.ConversationId ?? string.Empty;\n\n                Console.WriteLine($\"\uD83D\uDFE2 Conversation started: {conversationId}\");\n\n                // Join SignalR group for this conversation\n                await SignalRService.JoinConversation(conversationId);\n\n                // Save conversation ID to ProtectedLocalStorage\n                await StorageService.SaveConversationIdAsync(conversationId);\n                Console.WriteLine($\"\uD83D\uDFE2 Conversation ID saved to protected storage\");\n\n                Console.WriteLine($\"\uD83D\uDFE2 Waiting for presentation message...\");\n                // Presentation message will arrive via SignalR OnMessageReceived event\n            }\n            else\n            {\n                string errorContent = await response.Content.ReadAsStringAsync();\n                Console.WriteLine($\"❌ Morgana error: {errorContent}\");\n                AddErrorMessage($\"Failed to start conversation: {response.StatusCode}\", \"conversation_start_http_error\", 12);\n                await InvokeAsync(StateHasChanged);\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ StartConversation exception: {ex.Message}\");\n            AddErrorMessage($\"Connection error: {ex.Message}\", \"conversation_start_exception\", 20);\n            await InvokeAsync(StateHasChanged);\n        }\n    }\n\n    /// <summary>\n    /// Clears the saved conversation ID and refreshes the page to start a new conversation.\n    /// Triggered by the \"+ New Conversation\" button.\n    /// </summary>\n    /// <returns>Task representing the async new conversation operation</returns>\n    private async Task ClearConversationAsync()\n    {\n        try\n        {\n            Console.WriteLine($\"\uD83C\uDD95 {nameof(ClearConversationAsync)}: Clearing storage and refreshing...\");\n            \n            // Clear saved conversation ID from ProtectedLocalStorage\n            await StorageService.ClearConversationIdAsync();\n            \n            // Force page reload to trigger OnInitializedAsync with fresh state\n            NavigationManager.NavigateTo(\"/\", forceLoad: true);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ {nameof(ClearConversationAsync)} exception: {ex.Message}\");\n            AddErrorMessage($\"Error starting new conversation: {ex.Message}\", \"new_conversation_failed\", 12);\n            await InvokeAsync(StateHasChanged);\n        }\n    }\n\n    // =========================================================================\n    // MESSAGE HANDLING\n    // =========================================================================\n\n    /// <summary>\n    /// Sends a user message to Morgana backend via REST API.\n    /// Adds user message and typing indicator to UI, then waits for agent response via SignalR.\n    /// </summary>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// <para><strong>Flow:</strong></para>\n    /// <list type=\"number\">\n    /// <item>Validate input text</item>\n    /// <item>Add user message to messages list</item>\n    /// <item>Add typing indicator to messages list</item>\n    /// <item>Update UI</item>\n    /// <item>POST to /api/conversation/{conversationId}/message</item>\n    /// <item>Wait for response via SignalR (async)</item>\n    /// <item>HandleMessageReceived removes typing indicator and adds agent response</item>\n    /// </list>\n    /// <para><strong>Error Handling:</strong></para>\n    /// <para>On HTTP error or exception, typing indicator is removed and error message displayed.</para>\n    /// </remarks>\n    private async Task SendMessageAsync()\n    {\n        // Validate input\n        if (string.IsNullOrWhiteSpace(inputText) || isSending || !isConnected)\n            return;\n\n        string messageText = inputText.Trim();\n        inputText = string.Empty;\n        isSending = true;\n\n        // Add user message to UI\n        chatMessages.Add(new ChatMessage\n        {\n            ConversationId = conversationId,\n            Text = messageText,\n            Role = \"user\",\n            Timestamp = DateTime.UtcNow\n        });\n\n        // Add typing indicator\n        chatMessages.Add(new ChatMessage\n        {\n            ConversationId = conversationId,\n            Role = \"assistant\",\n            IsTyping = true,\n            AgentName = currentAgentName,\n            Timestamp = DateTime.UtcNow\n        });\n\n        StateHasChanged();\n\n        try\n        {\n            // Send message to backend\n            HttpResponseMessage response = await Http.PostAsJsonAsync($\"/api/conversation/{conversationId}/message\", new\n            {\n                conversationId = conversationId,\n                text = messageText\n            });\n\n            Console.WriteLine($\"\uD83D\uDFE1 Message sent, response status: {response.StatusCode}\");\n\n            if (!response.IsSuccessStatusCode)\n            {\n                Console.WriteLine($\"❌ SendMessage failed: {response.StatusCode}\");\n    \n                // Remove typing indicator\n                ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);\n                if (typingMessage != null)\n                {\n                    chatMessages.Remove(typingMessage);\n\n                    // Add temporary error banner (visible immediately, auto-dismiss after 10s)\n                    AddErrorMessage($\"Message not sent: {response.StatusCode}. Please try again.\", \"send_message_http_error\");\n\n                    // Add permanent error to chat history for debugging\n                    chatMessages.Add(new ChatMessage\n                    {\n                        ConversationId = conversationId,\n                        Text = \"Sorry, an error occurred. Please try again.\",\n                        Role = \"assistant\",\n                        Timestamp = DateTime.UtcNow,\n                        IsError = true,\n                        AgentName = currentAgentName,\n                        Type = MessageType.Error\n                    });\n\n                    await InvokeAsync(StateHasChanged);\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ SendMessage exception: {ex.Message}\");\n\n            // Remove typing indicator\n            ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);\n            if (typingMessage != null)\n            {\n                chatMessages.Remove(typingMessage);\n\n                // Add temporary error banner (visible immediately, auto-dismiss after 10s)\n                AddErrorMessage($\"Connection error: {ex.Message}. Please try again.\", \"send_message_exception\");\n\n                // Add permanent error to chat history for debugging\n                chatMessages.Add(new ChatMessage\n                {\n                    ConversationId = conversationId,\n                    Text = $\"Connection error: {ex.Message}\",\n                    Role = \"assistant\",\n                    Timestamp = DateTime.UtcNow,\n                    IsError = true,\n                    AgentName = currentAgentName,\n                    Type = MessageType.Error\n                });\n\n                await InvokeAsync(StateHasChanged);\n            }\n        }\n        finally\n        {\n            isSending = false;\n            StateHasChanged();\n        }\n    }\n\n    /// <summary>\n    /// Handles incoming messages from SignalR with strongly-typed DTO.\n    /// Removes typing indicator, updates agent state, and adds message to UI.\n    /// </summary>\n    /// <param name=\"signalrMessage\">Strongly-typed SignalR message DTO containing all message data</param>\n    /// <returns>Task representing the async message handling</returns>\n    /// <remarks>\n    /// <para><strong>Agent Lifecycle:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item><term>Agent Active</term><description>message.AgentCompleted = false, header shows agent name</description></item>\n    /// <item><term>Agent Completed</term><description>message.AgentCompleted = true, header returns to \"Morgana\"</description></item>\n    /// </list>\n    /// </remarks>\n    private async Task HandleMessageReceivedAsync(SignalRMessage signalrMessage)\n    {\n        try\n        {\n            Console.WriteLine($\"\uD83D\uDFE3 Message received for conversation: {signalrMessage.ConversationId}\");\n            Console.WriteLine($\"\uD83D\uDFE3 Agent: {signalrMessage.AgentName}, Completed: {signalrMessage.AgentCompleted}\");\n            Console.WriteLine($\"\uD83D\uDFE3 QuickReplies count: {signalrMessage.QuickReplies?.Count ?? 0}\");\n\n            #region Temporary Messages\n            if (string.Equals(signalrMessage.MessageType, \"system_warning\", StringComparison.OrdinalIgnoreCase)\n                 || string.Equals(signalrMessage.MessageType, \"error\", StringComparison.OrdinalIgnoreCase))\n            {\n                Console.WriteLine($\"⚠\uFE0F Temporary message received: {signalrMessage.MessageType}-{signalrMessage.ErrorReason}\");\n\n                temporaryMessages.Add(signalrMessage);\n                await InvokeAsync(StateHasChanged);\n\n                return;\n            }\n            #endregion\n\n            // Verify message is for this conversation\n            if (conversationId != signalrMessage.ConversationId)\n            {\n                Console.WriteLine(\"⚠\uFE0F Message for different conversation, ignoring\");\n                return;\n            }\n\n            // If streaming is active, finalize it with the complete message\n            if (currentStreamingMessage != null)\n            {\n                Console.WriteLine(\"\uD83C\uDFAC Streaming complete - finalizing message\");\n\n                // DON'T flush buffer immediately - let typewriter finish naturally\n                // The timer will continue draining the buffer at typewriter speed\n\n                // Just add metadata (text will complete via typewriter)\n                currentStreamingMessage.QuickReplies = signalrMessage.QuickReplies;\n                currentStreamingMessage.AgentName = signalrMessage.AgentName ?? \"Morgana\";\n                \n                // Mark as no longer streaming (removes cursor when typewriter finishes)\n                currentStreamingMessage.IsStreaming = false;\n\n                // DON'T stop streaming timer yet - let it finish draining buffer\n                // Timer will auto-stop when buffer is empty (check TypewriterTick)\n\n                // Update header\n                if (!string.IsNullOrEmpty(signalrMessage.AgentName))\n                {\n                    currentAgentName = signalrMessage.AgentName;\n                    Console.WriteLine($\"\uD83C\uDFA8 Header updated: {currentAgentName}\");\n                }\n\n                if (signalrMessage.AgentCompleted)\n                {\n                    currentAgentName = \"Morgana\";\n                    Console.WriteLine($\"\uD83C\uDFA8 Header reset to: {currentAgentName}\");\n                }\n\n                // If agent completed and is specialized, add completion message\n                if (signalrMessage.AgentCompleted && IsSpecializedAgent(signalrMessage.AgentName))\n                {\n                    chatMessages.Add(new ChatMessage\n                    {\n                        ConversationId = signalrMessage.ConversationId,\n                        Text = GetCompletionMessage(signalrMessage.AgentName!),\n                        Role = \"assistant\",\n                        Timestamp = signalrMessage.Timestamp.AddMilliseconds(5),\n                        AgentName = \"Morgana\",\n                        AgentCompleted = true,\n                        Type = MessageType.Presentation\n                    });\n                }\n\n                await InvokeAsync(StateHasChanged);\n                return;\n            }\n\n            // Normal message handling (non-streaming path)\n            // Remove typing indicator\n            ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);\n            if (typingMessage != null)\n                chatMessages.Remove(typingMessage);\n\n            // Update header with current agent name\n            if (!string.IsNullOrEmpty(signalrMessage.AgentName))\n            {\n                currentAgentName = signalrMessage.AgentName;\n                Console.WriteLine($\"\uD83C\uDFA8 Header updated: {currentAgentName} → Color: {GetAvatarBorderColor(currentAgentName)}\");\n            }\n\n            // If agent has completed, return header to Morgana\n            if (signalrMessage.AgentCompleted)\n            {\n                currentAgentName = \"Morgana\";\n                Console.WriteLine($\"\uD83C\uDFA8 Header reset to: {currentAgentName} → Color: {GetAvatarBorderColor(currentAgentName)}\");\n            }\n\n            // Add main agent message\n            chatMessages.Add(new ChatMessage\n            {\n                ConversationId = signalrMessage.ConversationId,\n                Text = signalrMessage.Text,\n                Role = \"assistant\",\n                Timestamp = signalrMessage.Timestamp,\n                QuickReplies = signalrMessage.QuickReplies,\n                AgentName = signalrMessage.AgentName ?? \"Morgana\",\n                AgentCompleted = false\n            });\n\n            // If agent completed and is specialized, add completion message from Morgana\n            if (signalrMessage.AgentCompleted && IsSpecializedAgent(signalrMessage.AgentName))\n            {\n                chatMessages.Add(new ChatMessage\n                {\n                    ConversationId = signalrMessage.ConversationId,\n                    Text = GetCompletionMessage(signalrMessage.AgentName!),\n                    Role = \"assistant\",\n                    Timestamp = signalrMessage.Timestamp.AddMilliseconds(5),\n                    AgentName = \"Morgana\",\n                    AgentCompleted = true,\n                    Type = MessageType.Presentation\n                });\n            }\n\n            await InvokeAsync(StateHasChanged);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ Error in HandleMessageReceived: {ex.Message}\");\n        }\n    }\n\n    /// <summary>\n    /// Callback invoked when FadingMessage component auto-dismisses.\n    /// Removes the message from the temporary messages list.\n    /// </summary>\n    /// <param name=\"message\">The message to remove</param>\n    private void HandleMessageDismissed(SignalRMessage message)\n    {\n        Console.WriteLine($\"\uD83D\uDDD1\uFE0F Dismissing temporary message: {message.MessageType}\");\n        temporaryMessages.Remove(message);\n        StateHasChanged();\n    }\n\n    // =========================================================================\n    // STREAMING HANDLERS\n    // =========================================================================\n\n    /// <summary>\n    /// Handles incoming streaming chunks from SignalR.\n    /// Starts streaming mode if needed and buffers chunks for typewriter effect.\n    /// </summary>\n    /// <param name=\"chunkText\">Partial response text to append</param>\n    /// <returns>Task representing the async chunk handling</returns>\n    /// <remarks>\n    /// <para><strong>Streaming Flow:</strong></para>\n    /// <list type=\"number\">\n    /// <item>First chunk: Remove typing indicator, create streaming message, start typewriter timer</item>\n    /// <item>Subsequent chunks: Append to streaming buffer</item>\n    /// <item>Typewriter timer: Progressively displays buffered text</item>\n    /// <item>Final message: HandleMessageReceivedAsync stops streaming and adds complete message</item>\n    /// </list>\n    /// </remarks>\n    private async Task HandleStreamChunkReceivedAsync(string chunkText)\n    {\n        try\n        {\n            // First chunk - initialize streaming\n            if (currentStreamingMessage == null)\n            {\n                // Remove typing indicator\n                ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);\n                if (typingMessage != null)\n                    chatMessages.Remove(typingMessage);\n\n                // Create new streaming message\n                currentStreamingMessage = new ChatMessage\n                {\n                    ConversationId = conversationId,\n                    Text = string.Empty,\n                    Role = \"assistant\",\n                    Timestamp = DateTime.UtcNow,\n                    AgentName = currentAgentName,\n                    IsStreaming = true\n                };\n\n                chatMessages.Add(currentStreamingMessage);\n\n                // Start typewriter timer (fires every configurable N(=25) milliseconds by consuming configurable K(=1) characters)\n                int.TryParse(Configuration[\"Morgana:StreamingResponse:TypewriterTickMilliseconds\"], out int typewriterTickMilliseconds);\n                if (typewriterTickMilliseconds <= 0)\n                    typewriterTickMilliseconds = 25;\n                int.TryParse(Configuration[\"Morgana:StreamingResponse:TypewriterTickChars\"], out int typewriterTickChars);\n                if (typewriterTickChars <= 0)\n                    typewriterTickChars = 1;\n                typewriterTimer?.Dispose();\n                typewriterTimer = new Timer(TypewriterTick, typewriterTickChars, 0, typewriterTickMilliseconds);\n\n                await InvokeAsync(StateHasChanged);\n            }\n\n            // Append chunk to buffer\n            streamingBuffer += chunkText;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"❌ Error in HandleStreamChunkReceived: {ex.Message}\");\n        }\n    }\n\n    /// <summary>\n    /// Timer callback for typewriter effect.\n    /// Consumes K characters from the streaming buffer every configurable N milliseconds.\n    /// Auto-stops when buffer is empty and streaming is complete.\n    /// </summary>\n    /// <param name=\"timerParameters\">Timer input parameters (int: the number of characters to be consumed)</param>\n    private void TypewriterTick(object? timerParameters)\n    {\n        if (currentStreamingMessage == null)\n            return;\n\n        // If buffer is empty\n        if (string.IsNullOrEmpty(streamingBuffer))\n        {\n            // If streaming is complete (IsStreaming = false), cleanup and stop\n            if (!currentStreamingMessage.IsStreaming)\n            {\n                Console.WriteLine(\"✅ Typewriter finished - buffer empty and streaming complete\");\n                StopStreaming();\n            }\n            // Otherwise, just wait for more chunks\n            return;\n        }\n\n        // Extract next N characters from buffer\n        int charsToTake = Math.Min((int)timerParameters!, streamingBuffer.Length);\n        string nextChars = streamingBuffer[..charsToTake];\n        streamingBuffer = streamingBuffer[charsToTake..];\n\n        // Append to streaming message\n        currentStreamingMessage.Text += nextChars;\n\n        // Update UI\n        InvokeAsync(StateHasChanged);\n    }\n\n    /// <summary>\n    /// Stops streaming mode and cleans up resources.\n    /// Called when final complete message arrives via HandleMessageReceivedAsync.\n    /// </summary>\n    private void StopStreaming()\n    {\n        typewriterTimer?.Dispose();\n        typewriterTimer = null;\n        streamingBuffer = string.Empty;\n        currentStreamingMessage = null;\n    }\n\n    // =========================================================================\n    // UI INTERACTION HANDLERS\n    // =========================================================================\n\n    /// <summary>\n    /// Handles keyboard events in textarea (Enter to send, Shift+Enter for newline).\n    /// </summary>\n    /// <param name=\"e\">Keyboard event args</param>\n    /// <returns>Task representing the async key handling</returns>\n    private async Task HandleKeyPressAsync(KeyboardEventArgs e)\n    {\n        // Send message on Enter (without Shift)\n        if (e is { Key: \"Enter\", ShiftKey: false })\n        {\n            await SendMessageAsync();\n        }\n    }\n\n    /// <summary>\n    /// Handles quick reply button selection.\n    /// Marks the selected reply, disables all buttons, and sends the reply value as user message.\n    /// </summary>\n    /// <param name=\"reply\">Selected quick reply definition</param>\n    /// <param name=\"message\">Message containing the quick replies</param>\n    /// <returns>Task representing the async selection handling</returns>\n    private async Task SelectQuickReplyAsync(QuickReply reply, ChatMessage message)\n    {\n        // Prevent multiple selections\n        if (message.SelectedQuickReplyId != null) return;\n\n        Console.WriteLine($\"\uD83D\uDFE1 Quick reply selected: {reply.Label}\");\n\n        // Mark as selected and update UI\n        message.SelectedQuickReplyId = reply.Id;\n        StateHasChanged();\n\n        // Visual feedback delay\n        await Task.Delay(250);\n\n        // Send the quick reply value as user message\n        inputText = reply.Value;\n        await SendMessageAsync();\n    }\n\n    /// <summary>\n    /// Shows the confirmation modal for starting a new conversation.\n    /// </summary>\n    private void ShowConfirmModal()\n    {\n        showConfirmModal = true;\n        StateHasChanged();\n    }\n\n    /// <summary>\n    /// Hides the confirmation modal without taking action.\n    /// </summary>\n    private void HideConfirmModal()\n    {\n        showConfirmModal = false;\n        StateHasChanged();\n    }\n\n    /// <summary>\n    /// Handles the confirmation action - hides modal and starts new conversation.\n    /// </summary>\n    private async Task ConfirmNewConversationAsync()\n    {\n        showConfirmModal = false;\n        StateHasChanged();\n        await ClearConversationAsync();\n    }\n\n    // =========================================================================\n    // UI STATE HELPERS\n    // =========================================================================\n\n    /// <summary>\n    /// Checks if there are any unselected quick replies in the tail of message list.\n    /// </summary>\n    /// <returns>True if any message has ending quick replies that haven't been selected yet</returns>\n    private bool HasActiveQuickReplies() =>\n        chatMessages.Any(m => m is { QuickReplies: not null, SelectedQuickReplyId: null, IsLastHistoryMessage: true });\n\n    /// <summary>\n    /// Gets a value indicating whether the send button should be disabled.\n    /// Disabled when: not connected, sending in progress, empty input, not initialized, has active quick replies, or typing indicator present.\n    /// </summary>\n    private bool IsSendButtonDisabled =>\n        !isConnected ||\n        isSending ||\n        string.IsNullOrWhiteSpace(inputText) ||\n        !isInitialized ||\n        HasActiveQuickReplies() ||\n        chatMessages.Any(m => m.IsTyping);\n\n    /// <summary>\n    /// Gets a value indicating whether the new conversation button should be visible.\n    /// </summary>\n    private bool IsNewConversationButtonVisible =>\n        isConnected\n         && isInitialized\n         && hasCheckedStorage\n         && !string.IsNullOrWhiteSpace(conversationId)\n         && chatMessages.Count > 0;\n\n    /// <summary>\n    /// Gets a value indicating whether the textarea should be disabled.\n    /// Disabled when: not connected, sending in progress, not initialized, has active quick replies, or typing indicator present.\n    /// </summary>\n    private bool IsTextareaDisabled =>\n        !isConnected ||\n        isSending ||\n        !isInitialized ||\n        HasActiveQuickReplies() ||\n        chatMessages.Any(m => m.IsTyping);\n\n    // =========================================================================\n    // CLEANUP\n    // =========================================================================\n\n    /// <summary>\n    /// Disposes component resources.\n    /// Unsubscribes from SignalR events and stops connection.\n    /// </summary>\n    /// <returns>ValueTask representing the async dispose operation</returns>\n    public async ValueTask DisposeAsync()\n    {\n        // Unsubscribe from events\n        SignalRService.OnMessageReceived -= HandleMessageReceivedAsync;\n        SignalRService.OnStreamChunkReceived -= HandleStreamChunkReceivedAsync;\n\n        // Clean up streaming resources\n        typewriterTimer?.Dispose();\n        \n        // Stop SignalR connection\n        await SignalRService.StopAsync();\n    }\n\n    // =========================================================================\n    // HELPER METHODS\n    // =========================================================================\n\n    /// <summary>\n    /// Determines if an agent name represents a specialized agent (not base Morgana).\n    /// Specialized agents have names with parentheses, e.g., \"Morgana (Billing)\".\n    /// </summary>\n    /// <param name=\"agentName\">Agent name to check</param>\n    /// <returns>True if specialized agent, false if base Morgana</returns>\n    private bool IsSpecializedAgent(string? agentName)\n    {\n        return agentName != null && agentName.Contains(\"(\") && agentName.Contains(\")\");\n    }\n\n    /// <summary>\n    /// Gets the CSS color variable for the avatar border based on agent type.\n    /// </summary>\n    /// <param name=\"agentName\">Name of the current agent</param>\n    /// <returns>\n    /// \"var(--secondary-color)\" (pink) for specialized agents,\n    /// \"var(--primary-color)\" (purple) for base Morgana\n    /// </returns>\n    private string GetAvatarBorderColor(string? agentName)\n    {\n        // Pink for specialized agents, purple for base Morgana\n        return IsSpecializedAgent(agentName ?? \"Morgana\") ? \"var(--secondary-color)\" : \"var(--primary-color)\";\n    }\n\n    /// <summary>\n    /// Gets the completion message to display when an agent finishes its task.\n    /// Uses configured template from appsettings or default message.\n    /// </summary>\n    /// <param name=\"agentName\">Name of the agent that completed</param>\n    /// <returns>Formatted completion message</returns>\n    private string GetCompletionMessage(string agentName)\n    {\n        string template = Configuration[\"Morgana:AgentExitMessage\"] ?? \"{0} has completed its spell. I'm back to you!\";\n        return string.Format(template, agentName);\n    }\n\n    /// <summary>\n    /// Adds a temporary error message displayed as FadingMessage banner.\n    /// Auto-dismisses after configurable N seconds with fade-out animation.\n    /// </summary>\n    /// <param name=\"text\">Error message text (⚠\uFE0F emoji will be prepended)</param>\n    /// <param name=\"errorReason\">Specific error reason for debugging/icon selection</param>\n    /// <param name=\"fadingMessageDurationSeconds\">Optional duration of the fading message that will be displayed</param>\n    private void AddErrorMessage(string text, string errorReason, int? fadingMessageDurationSeconds=10)\n    {\n        temporaryMessages.Add(new SignalRMessage\n        {\n            ConversationId = conversationId,\n            Text = text,\n            Timestamp = DateTime.UtcNow,\n            MessageType = \"error\",\n            ErrorReason = errorReason,\n            FadingMessageDurationSeconds = fadingMessageDurationSeconds\n        });\n    }\n\n    /// <summary>\n    /// Removes all error-type temporary messages.\n    /// Called on successful operations to clear previous errors.\n    /// </summary>\n    private void ClearErrorMessages()\n    {\n        temporaryMessages.RemoveAll(m => string.Equals(m.MessageType, \"error\", StringComparison.OrdinalIgnoreCase));\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Cauldron/Pages/Index.razor b/../Cauldron/Pages/Index.razor
--- a/../Cauldron/Pages/Index.razor	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/../Cauldron/Pages/Index.razor	(date 1770323036949)
@@ -109,11 +109,18 @@
                         }
                         else
                         {
-                            <!-- Message content -->
+                            @* Message content (text) *@
                             <div class="message-text @(chatMessage.Type == MessageType.Presentation ? "completion-text" : "")">
                                 @chatMessage.Text
                             </div>
+                            
+                            @* Rich card (if present) *@
+                            @if (chatMessage.RichCard != null)
+                            {
+                                <RichCard Card="@chatMessage.RichCard" />
+                            }
 
+                            @* Quick replies (if present) *@
                             @if (chatMessage is { QuickReplies: { Count: > 0 }, IsStreaming: false })
                             {
                                 <QuickReplyButton Replies="@chatMessage.QuickReplies"
@@ -818,6 +825,7 @@
 
                 // Just add metadata (text will complete via typewriter)
                 currentStreamingMessage.QuickReplies = signalrMessage.QuickReplies;
+                currentStreamingMessage.RichCard = signalrMessage.RichCard;
                 currentStreamingMessage.AgentName = signalrMessage.AgentName ?? "Morgana";
                 
                 // Mark as no longer streaming (removes cursor when typewriter finishes)
@@ -887,7 +895,8 @@
                 Timestamp = signalrMessage.Timestamp,
                 QuickReplies = signalrMessage.QuickReplies,
                 AgentName = signalrMessage.AgentName ?? "Morgana",
-                AgentCompleted = false
+                AgentCompleted = false,
+                RichCard = signalrMessage.RichCard
             });
 
             // If agent completed and is specialized, add completion message from Morgana
@@ -1067,7 +1076,8 @@
     private async Task SelectQuickReplyAsync(QuickReply reply, ChatMessage message)
     {
         // Prevent multiple selections
-        if (message.SelectedQuickReplyId != null) return;
+        if (message.SelectedQuickReplyId != null)
+            return;
 
         Console.WriteLine($"🟡 Quick reply selected: {reply.Label}");
 
@@ -1122,6 +1132,13 @@
     private bool HasActiveQuickReplies() =>
         chatMessages.Any(m => m is { QuickReplies: not null, SelectedQuickReplyId: null, IsLastHistoryMessage: true });
 
+    /// <summary>
+    /// Checks if there are any rich cards in the tail of message list.
+    /// </summary>
+    /// <returns>True if any message has ending rich card</returns>
+    private bool HasActiveRichCard() =>
+        chatMessages.Any(m => m is { RichCard: not null, IsLastHistoryMessage: true });
+
     /// <summary>
     /// Gets a value indicating whether the send button should be disabled.
     /// Disabled when: not connected, sending in progress, empty input, not initialized, has active quick replies, or typing indicator present.
Index: Morgana.Framework/Abstractions/MorganaAgent.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Akka.Actor;\nusing Microsoft.Agents.AI;\nusing Microsoft.Extensions.Logging;\nusing Morgana.Framework.Attributes;\nusing Morgana.Framework.Interfaces;\nusing Morgana.Framework.Providers;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.Extensions.AI;\n\nnamespace Morgana.Framework.Abstractions;\n\n/// <summary>\n/// Base class for domain-specific conversational agents in the Morgana framework.\n/// Extends MorganaActor with AI agent capabilities, conversation session, context management and inter-agent communication.\n/// </summary>\n/// <remarks>\n/// <para><strong>Purpose:</strong></para>\n/// <para>MorganaAgent provides the foundation for building specialized conversational agents that handle specific intents\n/// (e.g., BillingAgent, ContractAgent, MonkeysAgent). Each agent manages its own conversation session,\n/// context variables, and can communicate with other agents via the RouterActor.</para>\n/// <para><strong>Key Features:</strong></para>\n/// <list type=\"bullet\">\n/// <item><term>AI Agent Integration</term><description>Uses Microsoft.Agents.AI for LLM interactions with tool calling</description></item>\n/// <item><term>Conversation Session</term><description>Maintains conversation history via AgentSession for context-aware responses</description></item>\n/// <item><term>Context Management</term><description>MorganaAIContextProvider for reading/writing conversation variables</description></item>\n/// <item><term>Inter-Agent Communication</term><description>Broadcast and receive shared context variables across agents</description></item>\n/// <item><term>Interactive Token Detection</term><description>Detects #INT# token to signal multi-turn conversations</description></item>\n/// </list>\n/// <para><strong>Architecture:</strong></para>\n/// <code>\n/// MorganaActor\n///   └── MorganaAgent (adds AI agent capabilities)\n///         ├── BillingAgent [HandlesIntent(\"billing\")]\n///         ├── ContractAgent [HandlesIntent(\"contract\")]\n///         └── MonkeysAgent [HandlesIntent(\"monkeys\")]\n/// </code>\n/// <para><strong>Usage Pattern:</strong></para>\n/// <para>Agents receive AgentRequest messages, process them via ExecuteAgentAsync, and respond with AgentResponse.\n/// The #INT# token in responses signals incomplete processing, causing the supervisor to route follow-up messages\n/// directly to the same agent.</para>\n/// </remarks>\npublic class MorganaAgent : MorganaActor\n{\n    /// <summary>\n    /// Microsoft.Agents.AI agent instance for LLM interactions with tool calling support.\n    /// Configured with agent-specific prompts, personality, and available tools.\n    /// </summary>\n    protected AIAgent aiAgent;\n\n    /// <summary>\n    /// Conversation thread maintaining the history of messages with this agent.\n    /// Created lazily on first agent execution and reused for follow-up messages.\n    /// </summary>\n    protected AgentSession? aiAgentSession;\n\n    /// <summary>\n    /// AI context provider for reading and writing conversation variables.\n    /// Manages both local (agent-specific) and shared (cross-agent) context.\n    /// </summary>\n    protected MorganaAIContextProvider aiContextProvider;\n\n    /// <summary>\n    /// Service for persisting and loading conversation state (AgentSession + context) across application restarts.\n    /// Enables resuming conversations from encrypted file storage.\n    /// </summary>\n    protected readonly IConversationPersistenceService persistenceService;\n\n    /// <summary>\n    /// Logger instance for agent-level logging (separate from actorLogger).\n    /// Uses Microsoft.Extensions.Logging for consistency with agent framework.\n    /// </summary>\n    protected readonly ILogger agentLogger;\n\n    /// <summary>\n    /// Gets the intent handled by this agent instance.\n    /// Extracted from the HandlesIntentAttribute decorating the agent class.\n    /// </summary>\n    /// <remarks>\n    /// <para><strong>Example:</strong> \"billing\", \"contract\", \"monkeys\"</para>\n    /// <para><strong>Important:</strong> This property throws if HandlesIntentAttribute is not present.\n    /// All MorganaAgent subclasses MUST be decorated with [HandlesIntent(\"...\")] attribute.</para>\n    /// </remarks>\n    /// <exception cref=\"InvalidOperationException\">Thrown if HandlesIntentAttribute is not present on the agent class</exception>\n    protected string AgentIntent => GetType().GetCustomAttribute<HandlesIntentAttribute>()?.Intent\n                                     ?? throw new InvalidOperationException($\"Agent {GetType().Name} must be decorated with [HandlesIntent] attribute\");\n\n    /// <summary>\n    /// Gets the agent-specific conversation identifier combining intent and conversationId.\n    /// Used for persistence to ensure each agent type has its own isolated thread storage.\n    /// </summary>\n    /// <remarks>\n    /// <para><strong>Format:</strong> {intent}-{conversationId}</para>\n    /// <para><strong>Example:</strong> \"billing-conv_123\", \"contract-conv_456\"</para>\n    /// <para><strong>Why Needed:</strong></para>\n    /// <para>In Morgana, each agent maintains its own AgentSession within a conversation.\n    /// BillingAgent, ContractAgent, and MonkeyAgent all participate in the same\n    /// conversation but have separate message histories and context. This property ensures\n    /// each agent's state is persisted to a separate file.</para>\n    /// <code>\n    /// Conversation: \"conv_123\"\n    ///   ├─ BillingAgent     → billing-conv_123.morgana.json\n    ///   ├─ ContractAgent    → contract-conv_123.morgana.json\n    ///   └─ TroubleshootAgent → troubleshoot-conv_123.morgana.json\n    /// </code>\n    /// </remarks>\n    protected string AgentIdentifier => $\"{AgentIntent}-{conversationId}\";\n\n    /// <summary>\n    /// Initializes a new instance of MorganaAgent with AI agent infrastructure.\n    /// Sets up conversation threading, context management, and inter-agent communication.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation this agent will handle</param>\n    /// <param name=\"llmService\">LLM service for AI completions</param>\n    /// <param name=\"promptResolverService\">Service for resolving prompt templates</param>\n    /// <param name=\"persistenceService\">Service for persisting conversation state to encrypted storage</param>\n    /// <param name=\"agentLogger\">Logger instance for agent-level diagnostics</param>\n    public MorganaAgent(\n        string conversationId,\n        ILLMService llmService,\n        IPromptResolverService promptResolverService,\n        IConversationPersistenceService persistenceService,\n        ILogger agentLogger) : base(conversationId, llmService, promptResolverService)\n    {\n        this.persistenceService = persistenceService;\n        this.agentLogger = agentLogger;\n\n        ReceiveAsync<Records.AgentRequest>(ExecuteAgentAsync);\n        Receive<Records.ReceiveContextUpdate>(HandleContextUpdate);\n        ReceiveAsync<Records.FailureContext>(HandleAgentFailureAsync);\n    }\n\n    /// <summary>\n    /// Deserializes a previously serialized AgentSession, restoring conversation history and context state.\n    /// Updates the existing AI context provider instance to preserve tool closures.\n    /// </summary>\n    /// <param name=\"serializedSession\">JSON element containing the serialized session state from a previous Serialize() call</param>\n    /// <param name=\"jsonSerializerOptions\">JSON serialization options (defaults to AgentAbstractionsJsonUtilities.DefaultOptions)</param>\n    /// <returns>Fully reconstituted AgentSession with restored message history and context variables</returns>\n    /// <remarks>\n    /// <para><strong>Deserialization Process:</strong></para>\n    /// <list type=\"number\">\n    /// <item>Extract AIContextProviderState from serialized session JSON</item>\n    /// <item>Restore state into EXISTING MorganaAIContextProvider instance (preserves tool closures)</item>\n    /// <item>Reconnect OnSharedContextUpdate callback for inter-agent communication</item>\n    /// <item>Propagate shared variables to other agents</item>\n    /// <item>Delegate to underlying AIAgent.DeserializeSessionAsync to restore message history</item>\n    /// <item>Return fully functional AgentSession ready to continue the conversation</item>\n    /// </list>\n    /// <para><strong>CRITICAL - Tool Closure Preservation:</strong></para>\n    /// <para>This method UPDATES the existing contextProvider instance instead of creating a new one.\n    /// This is essential because tools are created with closures that capture the contextProvider field:\n    /// <code>\n    /// MorganaTool baseTool = new MorganaTool(logger, () => contextProvider);\n    /// </code></para>\n    /// <para>If we replaced the field with a new instance, tools would write to the old instance\n    /// while the agent reads from the new one, causing quick_replies and other ephemeral data to be lost.</para>\n    /// </remarks>\n    public virtual async Task<AgentSession> DeserializeSessionAsync(\n        JsonElement serializedSession,\n        JsonSerializerOptions? jsonSerializerOptions = null)\n    {\n        jsonSerializerOptions ??= AgentAbstractionsJsonUtilities.DefaultOptions;\n\n        // Extract AIContextProviderState\n        JsonElement aiContextProviderState = default;\n        if (serializedSession.TryGetProperty(\"aiContextProviderState\", out JsonElement stateElement))\n            aiContextProviderState = stateElement;\n\n        // Use it to restore internal state of MorganaAIContextProvider\n        if (aiContextProviderState.ValueKind != JsonValueKind.Undefined)\n            aiContextProvider.RestoreState(aiContextProviderState, jsonSerializerOptions);\n\n        // Reconnect shared context update callback\n        aiContextProvider.OnSharedContextUpdate = OnSharedContextUpdate;\n\n        // Propagate shared variables with connected callback\n        aiContextProvider.PropagateSharedVariables();\n\n        // Delegate to underlying AIAgent to complete session deserialization\n        aiAgentSession = await aiAgent.DeserializeSessionAsync(serializedSession, jsonSerializerOptions);\n\n        agentLogger.LogInformation($\"Deserialized AgentSession for conversation {conversationId}\");\n\n        return aiAgentSession;\n    }\n\n    /// <summary>\n    /// Callback invoked when a tool sets a shared context variable.\n    /// Broadcasts the variable to all other agents via RouterActor for cross-agent coordination.\n    /// </summary>\n    /// <param name=\"key\">Name of the shared context variable (e.g., \"userId\")</param>\n    /// <param name=\"value\">Value of the shared context variable</param>\n    /// <remarks>\n    /// <para><strong>Shared Context Pattern:</strong></para>\n    /// <para>When an agent discovers important information (e.g., userId from BillingAgent), it can broadcast\n    /// that information to all other agents so they don't need to ask the user again.</para>\n    /// <para><strong>Example Flow:</strong></para>\n    /// <list type=\"number\">\n    /// <item>BillingAgent tool calls SetContextVariable(\"userId\", \"P994E\", shared: true)</item>\n    /// <item>MorganaAIContextProvider detects shared variable and calls OnSharedContextUpdate</item>\n    /// <item>Agent broadcasts to RouterActor via BroadcastContextUpdate message</item>\n    /// <item>RouterActor sends ReceiveContextUpdate to all other agents</item>\n    /// <item>ContractAgent receives userId and can use it without asking user</item>\n    /// </list>\n    /// <para><strong>Actor Selection:</strong></para>\n    /// <para>Uses actor selection pattern to find RouterActor at /user/router-{conversationId}.\n    /// This is a fire-and-forget Tell operation (no response expected).</para>\n    /// </remarks>\n    protected void OnSharedContextUpdate(string key, object value)\n    {\n        agentLogger.LogInformation($\"Agent {AgentIntent} broadcasting shared context variable: {key}\");\n\n        Context.ActorSelection($\"/user/router-{conversationId}\")\n            .Tell(new Records.BroadcastContextUpdate(\n                AgentIntent,\n                new Dictionary<string, object> { [key] = value }\n            ));\n    }\n\n    /// <summary>\n    /// Handles context update broadcasts from other agents via RouterActor.\n    /// Implements intelligent merge: accepts only variables not already present (first-write-wins).\n    /// </summary>\n    /// <param name=\"msg\">Context update message containing source agent intent and updated variables</param>\n    /// <remarks>\n    /// <para><strong>First-Write-Wins Strategy:</strong></para>\n    /// <para>If an agent already has a value for a variable, it keeps its own value and ignores the broadcast.\n    /// This prevents conflicts when multiple agents independently discover the same information.</para>\n    /// <para><strong>Example Scenario:</strong></para>\n    /// <code>\n    /// // BillingAgent discovers userId\n    /// BillingAgent broadcasts: { \"userId\": \"P994E\" }\n    ///\n    /// // ContractAgent receives broadcast and merges (first write)\n    /// ContractAgent context: { \"userId\": \"P994E\" }\n    ///\n    /// // Later, ContractAgent independently asks user\n    /// ContractAgent has: { \"userId\": \"P994E\" } (already set, ignores any conflicting broadcast)\n    /// </code>\n    /// </remarks>\n    private void HandleContextUpdate(Records.ReceiveContextUpdate msg)\n    {\n        agentLogger.LogInformation(\n            $\"Agent '{AgentIntent}' received shared context from '{msg.SourceAgentIntent}': {string.Join(\", \", msg.UpdatedValues.Keys)}\");\n\n        aiContextProvider.MergeSharedContext(msg.UpdatedValues);\n    }\n\n    /// <summary>\n    /// Executes the agent using AgentSession for automatic conversation history and context management.\n    /// Handles conversation persistence, LLM interactions, interactive token detection, error handling, and response formatting.\n    /// </summary>\n    /// <param name=\"req\">Agent request containing the user's message and optional classification</param>\n    /// <returns>Task representing the async agent execution</returns>\n    /// <remarks>\n    /// <para><strong>Conversation Persistence:</strong></para>\n    /// <para>Every turn is automatically persisted to an encrypted .morgana.json file named by conversationId.\n    /// This enables resuming conversations across application restarts with full context and message history.</para>\n    /// <code>\n    /// Turn 1: User asks about billing\n    /// → Load: No file exists, create new session\n    /// → LLM processes, context saved\n    /// → Save: conversationId.morgana.json created with encrypted state\n    ///\n    /// [Application restart]\n    ///\n    /// Turn 2: User provides customer ID\n    /// → Load: conversationId.morgana.json decrypted and restored\n    /// → Agent remembers previous context\n    /// → LLM continues conversation seamlessly\n    /// → Save: Updated state persisted\n    /// </code>\n    /// <para><strong>Interactive Token (#INT#):</strong></para>\n    /// <para>Agents can emit \"#INT#\" in their responses to signal they need more information from the user.\n    /// This causes the supervisor to mark the agent as \"active\" and route follow-up messages directly to it.</para>\n    /// <code>\n    /// Agent: \"To help you with billing, could you provide your customer ID? #INT#\"\n    /// → Supervisor marks agent as active (IsCompleted = false)\n    /// → User responds: \"My ID is P994E\"\n    /// → Supervisor routes directly back to BillingAgent (skips classification)\n    /// Agent: \"Thank you! Here are your invoices...\" (no #INT#)\n    /// → Supervisor clears active agent (IsCompleted = true)\n    /// </code>\n    /// <para><strong>Error Handling:</strong></para>\n    /// <para>On exception, returns a generic error message from Morgana prompt configuration.\n    /// Always marks as completed (IsCompleted = true) to prevent stuck conversations.</para>\n    /// </remarks>\n    protected async Task ExecuteAgentAsync(Records.AgentRequest req)\n    {\n        IActorRef? senderRef = Sender;\n\n        try\n        {\n            // Load existing agent's conversation session from encrypted storage, or create new thread\n            aiAgentSession ??= await persistenceService.LoadAgentConversationAsync(AgentIdentifier, this);\n            if (aiAgentSession != null)\n            {\n                agentLogger.LogInformation($\"Loaded existing conversation session for {AgentIdentifier}\");\n            }\n            else\n            {\n                aiAgentSession = await aiAgent.GetNewSessionAsync();\n                agentLogger.LogInformation($\"Created new conversation session for {AgentIdentifier}\");\n            }\n\n            // Execute agent on its conversation session (which has context and history)\n            StringBuilder fullResponse = new StringBuilder();\n            await foreach (AgentResponseUpdate chunk in aiAgent.RunStreamingAsync(\n                new ChatMessage(ChatRole.User, req.Content!) { CreatedAt = DateTimeOffset.UtcNow }, aiAgentSession))\n            {\n                if (!string.IsNullOrEmpty(chunk.Text))\n                {\n                    fullResponse.Append(chunk.Text);\n\n                    senderRef.Tell(new Records.AgentStreamChunk(chunk.Text));\n                }\n            }\n            string llmResponseText = fullResponse.ToString();\n\n            // Detect if LLM has emitted the special token for continuing the multi-turn conversation\n            bool hasInteractiveToken = llmResponseText.Contains(\"#INT#\", StringComparison.OrdinalIgnoreCase);\n\n            // Additional multi-turn heuristic: if agent is ending with a direct question with \"?\",\n            // may it be a \"polite\" way of engaging the user in the continuation of this intent,\n            // or an intentional question finalized to obtain further informations\n            bool endsWithQuestion = llmResponseText.EndsWith('?');\n\n            // Retrieve quick replies from tools (if any tools set them during execution)\n            List<Records.QuickReply>? quickReplies = GetQuickRepliesFromContext();\n            bool hasQuickReplies = quickReplies?.Count > 0;\n\n            // Drop immediately them from context to prevent serialization (they're ephemeral UI hints)\n            if (hasQuickReplies)\n            {\n                aiContextProvider.DropVariable(\"quick_replies\");\n                agentLogger.LogInformation($\"Dropped {quickReplies!.Count} quick replies from context (ephemeral data)\");\n            }\n\n            // Request is completed when no further user engagement has been requested.\n            // If agent offers QuickReplies, it MUST remain active to handle clicks\n            // Otherwise, clicks would go through Classifier and risk \"other\" intent fallback\n            bool isCompleted = !hasInteractiveToken && !endsWithQuestion && !hasQuickReplies;\n\n            agentLogger.LogInformation(\n                $\"Agent response analysis: HasINT={hasInteractiveToken}, EndsWithQuestion={endsWithQuestion}, HasQR={hasQuickReplies}, IsCompleted={isCompleted}\");\n\n            // Persist updated agent's conversation state\n            await persistenceService.SaveAgentConversationAsync(AgentIdentifier, aiAgentSession, isCompleted);\n            agentLogger.LogInformation($\"Saved conversation state for {AgentIdentifier}\");\n\n            #if DEBUG\n                senderRef.Tell(new Records.AgentResponse(llmResponseText, isCompleted, quickReplies));\n            #else\n                senderRef.Tell(new Records.AgentResponse(llmResponseText.Replace(\"#INT#\", \"\", StringComparison.OrdinalIgnoreCase).Trim(), isCompleted, quickReplies));\n            #endif\n        }\n        catch (Exception ex)\n        {\n            agentLogger.LogError(ex, $\"Error in {GetType().Name}\");\n\n            Self.Tell(new Records.FailureContext(new Status.Failure(ex), senderRef));\n        }\n    }\n\n    /// <summary>\n    /// Handles agent execution failures that occur during message processing.\n    /// Sends a generic error response to the original sender to maintain conversation flow.\n    /// </summary>\n    /// <param name=\"failure\">Failure context containing the exception and original sender reference</param>\n    /// <remarks>\n    /// <para>This handler is invoked when ExecuteAgentAsync encounters an unhandled exception.\n    /// It ensures the conversation doesn't get stuck by returning a user-friendly error message\n    /// and marking the interaction as completed (IsCompleted = true).</para>\n    /// <para><strong>Error Recovery Strategy:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item>Log the exception for debugging</item>\n    /// <item>Load generic error message from Morgana prompt configuration</item>\n    /// <item>Send fallback response to original sender</item>\n    /// <item>Mark interaction as completed to prevent stuck conversations</item>\n    /// </list>\n    /// </remarks>\n    private async Task HandleAgentFailureAsync(Records.FailureContext failure)\n    {\n        agentLogger.LogError(failure.Failure.Cause, $\"Agent execution failed in {GetType().Name}\");\n\n        Records.Prompt morganaPrompt = await promptResolverService.ResolveAsync(\"Morgana\");\n        List<Records.ErrorAnswer> errorAnswers = morganaPrompt.GetAdditionalProperty<List<Records.ErrorAnswer>>(\"ErrorAnswers\");\n        Records.ErrorAnswer? genericError = errorAnswers.FirstOrDefault(e => string.Equals(e.Name, \"GenericError\", StringComparison.OrdinalIgnoreCase));\n\n        failure.OriginalSender.Tell(new Records.AgentResponse(genericError?.Content ?? \"An internal error occurred.\", true, null));\n    }\n\n    /// <summary>\n    /// Retrieves quick replies that tools may have generated during LLM execution.\n    /// Tools set quick replies via SetPendingQuickReplies() when they want to guide user interactions.\n    /// </summary>\n    /// <returns>List of quick reply buttons from tools, or null if no tools set quick replies</returns>\n    /// <remarks>\n    /// <para><strong>Tool-Driven Quick Replies:</strong></para>\n    /// <para>Tools know their domain data and available operations, making them the best source for\n    /// contextual quick reply suggestions. This method retrieves quick replies from MorganaTool instances.</para>\n    /// <para><strong>Example Flow:</strong></para>\n    /// <code>\n    /// 1. LLM calls \"GetInvoices\" tool\n    /// 2. Tool sets quick replies for guide selection\n    /// 3. Tool returns guide list text\n    /// 4. Agent calls GetQuickRepliesFromContext() after tool execution\n    /// 5. Agent includes quick replies in AgentResponse\n    /// 6. UI displays buttons to user\n    /// </code>\n    /// </remarks>\n    protected List<Records.QuickReply>? GetQuickRepliesFromContext()\n    {\n        #region Utilities\n        List<Records.QuickReply>? GetQuickReplies(string quickRepliesJSON)\n        {\n            try\n            {\n                // Deserialize JSON string to List<QuickReply>\n                List<Records.QuickReply>? quickReplies = JsonSerializer.Deserialize<List<Records.QuickReply>>(quickRepliesJSON);\n                if (quickReplies != null && quickReplies.Any())\n                {\n                    agentLogger.LogInformation($\"Retrieved {quickReplies.Count} quick replies from context\");\n\n                    return quickReplies;\n                }\n            }\n            catch (JsonException ex)\n            {\n                agentLogger.LogError(ex, \"Failed to deserialize quick replies from context\");\n\n                // Clear corrupted data (prevent serialized context to be damaged)\n                aiContextProvider.DropVariable(\"quick_replies\");\n            }\n\n            return null;\n        }\n        #endregion\n\n        // Retrieve quick_replies from context\n        object? ctxQuickReplies = aiContextProvider.GetVariable(\"quick_replies\");\n\n        // We may find them in string format\n        if (ctxQuickReplies is string ctxQuickRepliesJson && !string.IsNullOrEmpty(ctxQuickRepliesJson))\n            return GetQuickReplies(ctxQuickRepliesJson);\n\n        // Or we may find them in JsonElement format\n        if (ctxQuickReplies is JsonElement ctxQuickRepliesJsonElement && ctxQuickRepliesJsonElement.ValueKind == JsonValueKind.String)\n            return GetQuickReplies(ctxQuickRepliesJsonElement.GetString()!);\n\n        return null;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Abstractions/MorganaAgent.cs b/Morgana.Framework/Abstractions/MorganaAgent.cs
--- a/Morgana.Framework/Abstractions/MorganaAgent.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Abstractions/MorganaAgent.cs	(date 1770320991331)
@@ -331,29 +331,44 @@
             List<Records.QuickReply>? quickReplies = GetQuickRepliesFromContext();
             bool hasQuickReplies = quickReplies?.Count > 0;
 
-            // Drop immediately them from context to prevent serialization (they're ephemeral UI hints)
+            // Retrieve rich card from context (if LLM set one via SetRichCard tool)
+            Records.RichCard? richCard = GetRichCardFromContext();
+            bool hasRichCard = richCard != null;
+
+            // Drop quick replies from context to prevent serialization (they're ephemeral UI hints)
             if (hasQuickReplies)
             {
                 aiContextProvider.DropVariable("quick_replies");
                 agentLogger.LogInformation($"Dropped {quickReplies!.Count} quick replies from context (ephemeral data)");
             }
 
+            // Drop rich card from context to prevent serialization (it is ephemeral UI hint)
+            if (hasRichCard)
+            {
+                aiContextProvider.DropVariable("rich_card");
+                agentLogger.LogInformation($"Dropped rich card '{richCard!.Title}' from context (ephemeral data)");
+            }
+
             // Request is completed when no further user engagement has been requested.
             // If agent offers QuickReplies, it MUST remain active to handle clicks
             // Otherwise, clicks would go through Classifier and risk "other" intent fallback
             bool isCompleted = !hasInteractiveToken && !endsWithQuestion && !hasQuickReplies;
 
             agentLogger.LogInformation(
-                $"Agent response analysis: HasINT={hasInteractiveToken}, EndsWithQuestion={endsWithQuestion}, HasQR={hasQuickReplies}, IsCompleted={isCompleted}");
+                $"Agent response analysis: HasINT={hasInteractiveToken}," +
+                $"EndsWithQuestion={endsWithQuestion}," +
+                $"HasQR={hasQuickReplies}," +
+                $"HasRC={hasRichCard}," +
+                $"IsCompleted={isCompleted}");
 
             // Persist updated agent's conversation state
             await persistenceService.SaveAgentConversationAsync(AgentIdentifier, aiAgentSession, isCompleted);
             agentLogger.LogInformation($"Saved conversation state for {AgentIdentifier}");
 
             #if DEBUG
-                senderRef.Tell(new Records.AgentResponse(llmResponseText, isCompleted, quickReplies));
+                senderRef.Tell(new Records.AgentResponse(llmResponseText, isCompleted, quickReplies, richCard));
             #else
-                senderRef.Tell(new Records.AgentResponse(llmResponseText.Replace("#INT#", "", StringComparison.OrdinalIgnoreCase).Trim(), isCompleted, quickReplies));
+                senderRef.Tell(new Records.AgentResponse(llmResponseText.Replace("#INT#", "", StringComparison.OrdinalIgnoreCase).Trim(), isCompleted, quickReplies, richCard));
             #endif
         }
         catch (Exception ex)
@@ -452,4 +467,58 @@
 
         return null;
     }
+
+    /// <summary>
+    /// Retrieves LLM-generated rich card from agent context after tool execution.
+    /// Returns null if no rich card was set via SetRichCard tool.
+    /// </summary>
+    /// <returns>Deserialized RichCard object or null if not present/invalid</returns>
+    /// <remarks>
+    /// <para>This method is called after agent execution completes to extract any rich card
+    /// that the LLM may have generated via the SetRichCard tool during its response generation.</para>
+    /// <para>The rich card JSON is stored in the context under the reserved key "rich_card"
+    /// and is dropped immediately after extraction (ephemeral data, not persisted).</para>
+    /// </remarks>
+    protected Records.RichCard? GetRichCardFromContext()
+    {
+        #region Utilities
+        Records.RichCard? GetRichCard(string richCardJSON)
+        {
+            try
+            {
+                // Deserialize JSON string to RichCard
+                Records.RichCard? richCard = JsonSerializer.Deserialize<Records.RichCard>(
+                    richCardJSON, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
+                if (richCard != null)
+                {
+                    agentLogger.LogInformation($"Retrieved rich card from context");
+
+                    return richCard;
+                }
+            }
+            catch (JsonException ex)
+            {
+                agentLogger.LogError(ex, "Failed to deserialize rich card from context");
+
+                // Clear corrupted data (prevent serialized context to be damaged)
+                aiContextProvider.DropVariable("rich_card");
+            }
+
+            return null;
+        }
+        #endregion
+
+        // Retrieve rich_card from context
+        object? ctxRichCard = aiContextProvider.GetVariable("rich_card");
+
+        // We may find it in string format
+        if (ctxRichCard is string ctxRichCardJson && !string.IsNullOrEmpty(ctxRichCardJson))
+            return GetRichCard(ctxRichCardJson);
+
+        // Or we may find it in JsonElement format
+        if (ctxRichCard is JsonElement ctxRichCardJsonElement && ctxRichCardJsonElement.ValueKind == JsonValueKind.String)
+            return GetRichCard(ctxRichCardJsonElement.GetString()!);
+
+        return null;
+    }
 }
\ No newline at end of file
Index: Morgana.Framework/Actors/RouterActor.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Akka.Actor;\nusing Akka.Event;\nusing Morgana.Framework.Abstractions;\nusing Morgana.Framework.Extensions;\nusing Morgana.Framework.Interfaces;\n\nnamespace Morgana.Framework.Actors;\n\n/// <summary>\n/// Intent-to-agent routing actor that directs requests to specialized agents based on intent classification.\n/// Maintains a registry of intent-to-agent mappings with lazy agent creation.\n/// Also manages cross-agent context broadcasting for shared state updates.\n/// </summary>\n/// <remarks>\n/// This actor uses on-demand agent creation instead of upfront creation to avoid conflicts\n/// during conversation resume when agents may already exist.\n/// It routes requests using Ask pattern with PipeTo for non-blocking communication.\n/// Supports broadcasting context updates from one agent to all other registered agents.\n/// </remarks>\npublic class RouterActor : MorganaActor\n{\n    /// <summary>\n    /// Dictionary mapping intent names to their corresponding agent actor references.\n    /// Populated lazily on first use of each agent.\n    /// </summary>\n    private readonly Dictionary<string, IActorRef> agents = [];\n\n    /// <summary>\n    /// Dictionary mapping agent references to their original senders for streaming chunk forwarding.\n    /// Populated when a request is routed to an agent, cleaned up when response is received.\n    /// </summary>\n    private readonly Dictionary<IActorRef, IActorRef> streamingContexts = [];\n\n    /// <summary>\n    /// Service for discovering agent types from intent names.\n    /// </summary>\n    private readonly IAgentRegistryService agentResolverService;\n\n    /// <summary>\n    /// Initializes a new instance of the RouterActor.\n    /// Does NOT pre-create agents - they are created on-demand when first needed.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier for this conversation</param>\n    /// <param name=\"llmService\">LLM service for AI completions</param>\n    /// <param name=\"promptResolverService\">Service for resolving prompt templates</param>\n    /// <param name=\"agentResolverService\">Service for agent discovery and resolution</param>\n    public RouterActor(\n        string conversationId,\n        ILLMService llmService,\n        IPromptResolverService promptResolverService,\n        IAgentRegistryService agentResolverService) : base(conversationId, llmService, promptResolverService)\n    {\n        this.agentResolverService = agentResolverService;\n\n        // Route classified requests to specialized agents based on intent:\n        // - Validates classification exists and intent is recognized\n        // - Creates agent on-demand if not yet created\n        // - Forwards request to appropriate agent (BillingAgent, ContractAgent, etc.) using Tell\n        // - Receives both streaming chunks and final response via Tell\n        // - Returns error messages for missing/unrecognized intents\n        ReceiveAsync<Records.AgentRequest>(RouteToAgentAsync);\n        Receive<Records.AgentResponse>(HandleAgentResponseDirect);\n        \n        // Forward streaming chunks from agents to supervisor\n        Receive<Records.AgentStreamChunk>(HandleAgentStreamChunk);\n        \n        // Handle agent failures during execution\n        Receive<Records.FailureContext>(HandleAgentFailure);\n\n        // Broadcast context updates from one agent to all other registered agents:\n        // - Used for sharing context variables across agents (e.g., userId from BillingAgent → ContractAgent)\n        // - Excludes source agent from broadcast to avoid self-notification\n        // - Creates agents on-demand if they don't exist yet\n        ReceiveAsync<Records.BroadcastContextUpdate>(HandleBroadcastContextUpdate);\n\n        // Handle agent restoration requests from supervisor\n        ReceiveAsync<Records.RestoreAgentRequest>(HandleRestoreAgentRequestAsync);\n    }\n\n    /// <summary>\n    /// Gets or creates an agent for the specified intent.\n    /// Uses lazy creation pattern to avoid conflicts during conversation resume.\n    /// </summary>\n    /// <param name=\"intent\">Intent name (e.g., \"billing\", \"contract\")</param>\n    /// <returns>Agent actor reference, or null if no agent handles this intent</returns>\n    private async Task<IActorRef?> GetOrCreateAgentForIntent(string intent)\n    {\n        // Check if agent already created and cached\n        if (agents.TryGetValue(intent, out IActorRef? cachedAgent))\n        {\n            actorLogger.Info($\"Using cached agent for intent '{intent}': {cachedAgent.Path}\");\n            return cachedAgent;\n        }\n\n        // Resolve agent type from registry\n        Type? agentType = agentResolverService.ResolveAgentFromIntent(intent);\n        if (agentType == null)\n        {\n            actorLogger.Warning($\"No agent type found for intent '{intent}'\");\n            return null;\n        }\n\n        // Create agent (or get if already exists - handles resume scenario)\n        IActorRef agent = await Context.System.GetOrCreateAgent(agentType, intent, conversationId);\n\n        // Cache for future requests\n        agents[intent] = agent;\n\n        actorLogger.Info($\"Agent created/resolved for intent '{intent}': {agent.Path}\");\n        return agent;\n    }\n\n    /// <summary>\n    /// Routes an agent request to the appropriate specialized agent based on intent classification.\n    /// Creates agent on-demand if not yet created.\n    /// Uses Ask pattern with PipeTo for non-blocking communication, while streaming chunks flow separately.\n    /// </summary>\n    /// <param name=\"req\">Agent request containing classification and message data</param>\n    /// <remarks>\n    /// Returns error messages for missing classification or unrecognized intents.\n    /// Captures original sender before async operations to ensure correct response routing.\n    /// Streaming chunks arrive via separate Tell messages and are forwarded to original sender.\n    /// Includes 60-second timeout for agent processing.\n    /// </remarks>\n    private async Task RouteToAgentAsync(Records.AgentRequest req)\n    {\n        IActorRef originalSender = Sender;\n        Records.Prompt classifierPrompt = await promptResolverService.ResolveAsync(\"Classifier\");\n\n        // Validate classification exists\n        if (req.Classification == null)\n        {\n            originalSender.Tell(new Records.AgentResponse(\n                classifierPrompt.GetAdditionalProperty<string>(\"MissingClassificationError\"), true));\n            return;\n        }\n\n        // Get or create agent for this intent\n        IActorRef? selectedAgent = await GetOrCreateAgentForIntent(req.Classification.Intent);\n\n        // Validate agent exists for this intent\n        if (selectedAgent == null)\n        {\n            originalSender.Tell(new Records.AgentResponse(\n                classifierPrompt.GetAdditionalProperty<string>(\"UnrecognizedIntentError\"), true));\n            return;\n        }\n\n        actorLogger.Info($\"Routing intent '{req.Classification.Intent}' to agent {selectedAgent.Path}\");\n\n        // Store streaming context for chunk and response forwarding\n        streamingContexts[selectedAgent] = originalSender;\n\n        // Route to agent using Tell (not Ask) to support streaming\n        // Both chunks and final response will arrive via Tell and be handled separately\n        selectedAgent.Tell(req);\n    }\n\n    /// <summary>\n    /// Handles agent responses (final message after streaming completes).\n    /// Wraps the response with agent reference and forwards to original sender.\n    /// </summary>\n    /// <param name=\"response\">Agent response from specialized agent</param>\n    private void HandleAgentResponseDirect(Records.AgentResponse response)\n    {\n        IActorRef agentSender = Sender;\n        \n        if (streamingContexts.TryGetValue(agentSender, out IActorRef? originalSender))\n        {\n            actorLogger.Info($\"Received response from agent {agentSender.Path}, \" +\n                             $\"completed: {response.IsCompleted}, \" +\n                             $\"#quickReplies: {response.QuickReplies?.Count ?? 0}\");\n\n            // Clean up streaming context (response received, streaming done)\n            streamingContexts.Remove(agentSender);\n\n            // Forward to supervisor wrapped as ActiveAgentResponse\n            originalSender.Tell(new Records.ActiveAgentResponse(\n                response.Response,\n                response.IsCompleted,\n                agentSender,\n                response.QuickReplies));\n        }\n        else\n        {\n            actorLogger.Warning($\"Received response from unknown agent {agentSender.Path}\");\n        }\n    }\n\n    /// <summary>\n    /// Handles agent execution failures reported via FailureContext.\n    /// Sends error response to supervisor and cleans up streaming context.\n    /// </summary>\n    /// <param name=\"failure\">Failure context from agent</param>\n    private void HandleAgentFailure(Records.FailureContext failure)\n    {\n        IActorRef agentSender = Sender;\n        \n        actorLogger.Error(failure.Failure.Cause, $\"Agent execution failed: {agentSender.Path}\");\n\n        // Check if this failure is from an agent we're routing\n        if (streamingContexts.TryGetValue(agentSender, out IActorRef? originalSender))\n        {\n            actorLogger.Info($\"Forwarding failure to supervisor for agent {agentSender.Path}\");\n            \n            // Send error response wrapped as ActiveAgentResponse so supervisor can handle it\n            originalSender.Tell(new Records.ActiveAgentResponse(\n                \"An error occurred while processing your request. Please try again.\",\n                true, // Mark as completed to reset conversation state\n                agentSender,\n                null));\n\n            // Clean up streaming context\n            streamingContexts.Remove(agentSender);\n        }\n        else\n        {\n            actorLogger.Warning($\"Received failure from unknown agent {agentSender.Path} - no streaming context found\");\n        }\n    }\n\n    /// <summary>\n    /// Handles context update broadcasts from one agent to all other registered agents.\n    /// Creates agents on-demand if they don't exist yet.\n    /// Used for sharing context variables across agents (e.g., userId shared between billing and contract agents).\n    /// </summary>\n    /// <param name=\"msg\">Broadcast message containing source intent and updated context values</param>\n    /// <remarks>\n    /// Excludes the source agent from the broadcast to avoid self-notification.\n    /// Logs the number of agents that received the update.\n    /// </remarks>\n    private async Task HandleBroadcastContextUpdate(Records.BroadcastContextUpdate msg)\n    {\n        actorLogger.Info($\"Broadcasting context update from '{msg.SourceAgentIntent}': {string.Join(\", \", msg.UpdatedValues.Keys)}\");\n\n        int broadcastCount = 0;\n\n        // Get all registered intents and create/get agents for each\n        foreach (string intent in agentResolverService.GetAllIntents())\n        {\n            // Skip source agent\n            if (string.Equals(intent, msg.SourceAgentIntent, StringComparison.OrdinalIgnoreCase))\n                continue;\n\n            // Get or create agent for this intent\n            IActorRef? agent = await GetOrCreateAgentForIntent(intent);\n\n            if (agent != null)\n            {\n                agent.Tell(new Records.ReceiveContextUpdate(msg.SourceAgentIntent, msg.UpdatedValues));\n                broadcastCount++;\n            }\n        }\n\n        actorLogger.Info($\"Context update broadcast complete: {broadcastCount} agent(s) notified\");\n    }\n\n    /// <summary>\n    /// Handles streaming chunks from agents and forwards them to the original sender (supervisor).\n    /// Uses streamingContexts map to find the correct destination.\n    /// Enables real-time progressive response rendering.\n    /// </summary>\n    /// <param name=\"chunk\">Streaming chunk from agent</param>\n    private void HandleAgentStreamChunk(Records.AgentStreamChunk chunk)\n    {\n        // Find the original sender for this agent's stream\n        IActorRef agentSender = Sender;\n        \n        if (streamingContexts.TryGetValue(agentSender, out IActorRef? originalSender))\n        {\n            // Forward chunk to original sender (supervisor)\n            // No logging to avoid spamming logs with partial text\n            originalSender.Tell(chunk);\n        }\n        else\n        {\n            // Fallback: forward to parent (supervisor) - should not happen in normal flow\n            actorLogger.Warning($\"Streaming chunk received from unknown agent {agentSender.Path}, forwarding to parent\");\n            Context.Parent.Tell(chunk);\n        }\n    }\n\n    /// <summary>\n    /// Handles agent restoration requests from ConversationSupervisorActor.\n    /// Resolves and caches the agent, making it immediately available for routing.\n    /// </summary>\n    /// <param name=\"req\">Restoration request with agent intent</param>\n    private async Task HandleRestoreAgentRequestAsync(Records.RestoreAgentRequest req)\n    {\n        IActorRef originalSender = Sender;\n\n        actorLogger.Info($\"Restoring agent for intent '{req.AgentIntent}'\");\n\n        IActorRef? agentRef = await GetOrCreateAgentForIntent(req.AgentIntent);\n\n        if (agentRef != null)\n        {\n            actorLogger.Info($\"Agent restored and cached: {agentRef.Path}\");\n        }\n        else\n        {\n            actorLogger.Warning($\"Could not restore agent for intent '{req.AgentIntent}' - no matching agent type\");\n        }\n\n        originalSender.Tell(new Records.RestoreAgentResponse(req.AgentIntent, agentRef));\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Actors/RouterActor.cs b/Morgana.Framework/Actors/RouterActor.cs
--- a/Morgana.Framework/Actors/RouterActor.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Actors/RouterActor.cs	(date 1770321435291)
@@ -179,7 +179,8 @@
                 response.Response,
                 response.IsCompleted,
                 agentSender,
-                response.QuickReplies));
+                response.QuickReplies,
+                response.RichCard));
         }
         else
         {
@@ -208,6 +209,7 @@
                 "An error occurred while processing your request. Please try again.",
                 true, // Mark as completed to reset conversation state
                 agentSender,
+                null,
                 null));
 
             // Clean up streaming context
Index: ../Cauldron/Messages/RichCard.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Cauldron/Messages/RichCard.cs b/../Cauldron/Messages/RichCard.cs
new file mode 100644
--- /dev/null	(date 1770321940391)
+++ b/../Cauldron/Messages/RichCard.cs	(date 1770321940391)
@@ -0,0 +1,103 @@
+using System.Text.Json.Serialization;
+
+namespace Cauldron.Messages;
+
+/// <summary>
+/// Rich card container for structured visual presentation.
+/// Mirrors Morgana.Framework.Records.RichCard structure.
+/// </summary>
+public class RichCard
+{
+    public required string Title { get; set; }
+    public string? Subtitle { get; set; }
+    public required List<CardComponent> Components { get; set; }
+}
+
+/// <summary>
+/// Base class for all card components.
+/// Uses System.Text.Json polymorphic deserialization.
+/// </summary>
+[JsonPolymorphic(TypeDiscriminatorPropertyName = "type")]
+[JsonDerivedType(typeof(TextBlockComponent), "text_block")]
+[JsonDerivedType(typeof(KeyValueComponent), "key_value")]
+[JsonDerivedType(typeof(DividerComponent), "divider")]
+[JsonDerivedType(typeof(ListComponent), "list")]
+[JsonDerivedType(typeof(SectionComponent), "section")]
+[JsonDerivedType(typeof(GridComponent), "grid")]
+[JsonDerivedType(typeof(BadgeComponent), "badge")]
+public abstract class CardComponent
+{
+}
+
+public class TextBlockComponent : CardComponent
+{
+    public required string Content { get; set; }
+    public TextStyle Style { get; set; } = TextStyle.Normal;
+}
+
+public class KeyValueComponent : CardComponent
+{
+    public required string Key { get; set; }
+    public required string Value { get; set; }
+    public bool Emphasize { get; set; }
+}
+
+public class DividerComponent : CardComponent
+{
+}
+
+public class ListComponent : CardComponent
+{
+    public required List<string> Items { get; set; }
+    public ListStyle Style { get; set; } = ListStyle.Bullet;
+}
+
+public class SectionComponent : CardComponent
+{
+    public required string Title { get; set; }
+    public string? Subtitle { get; set; }
+    public required List<CardComponent> Components { get; set; }
+}
+
+public class GridComponent : CardComponent
+{
+    public int Columns { get; set; }
+    public required List<GridItem> Items { get; set; }
+}
+
+public class GridItem
+{
+    public required string Key { get; set; }
+    public required string Value { get; set; }
+}
+
+public class BadgeComponent : CardComponent
+{
+    public required string Text { get; set; }
+    public BadgeVariant Variant { get; set; } = BadgeVariant.Neutral;
+}
+
+// Enums
+public enum TextStyle
+{
+    Normal,
+    Bold,
+    Muted,
+    Small
+}
+
+public enum ListStyle
+{
+    Bullet,
+    Numbered,
+    Plain
+}
+
+public enum BadgeVariant
+{
+    Success,
+    Warning,
+    Error,
+    Info,
+    Neutral
+}
\ No newline at end of file
Index: ../Cauldron/wwwroot/css/rich-card.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Cauldron/wwwroot/css/rich-card.css b/../Cauldron/wwwroot/css/rich-card.css
new file mode 100644
--- /dev/null	(date 1770322067040)
+++ b/../Cauldron/wwwroot/css/rich-card.css	(date 1770322067040)
@@ -0,0 +1,355 @@
+/* ======================
+   RICH CARD 
+   ====================== */
+
+/* Main card container */
+.rich-card {
+    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
+    border: 2px solid rgba(138, 43, 226, 0.3);
+    border-radius: 12px;
+    padding: 0;
+    margin: 12px 0;
+    box-shadow:
+            0 4px 12px rgba(138, 43, 226, 0.15),
+            0 0 20px rgba(138, 43, 226, 0.1);
+    overflow: hidden;
+    animation: cardAppear 0.3s ease-out;
+}
+
+@keyframes cardAppear {
+    from {
+        opacity: 0;
+        transform: translateY(10px);
+    }
+    to {
+        opacity: 1;
+        transform: translateY(0);
+    }
+}
+
+/* Card header */
+.rich-card-header {
+    background: linear-gradient(135deg, rgba(138, 43, 226, 0.15) 0%, rgba(75, 0, 130, 0.15) 100%);
+    padding: 16px 20px;
+    border-bottom: 1px solid rgba(138, 43, 226, 0.2);
+}
+
+.rich-card-title {
+    margin: 0;
+    font-size: 1.25rem;
+    font-weight: 600;
+    color: #e0e0e0;
+    text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
+}
+
+.rich-card-subtitle {
+    margin: 6px 0 0 0;
+    font-size: 0.9rem;
+    color: rgba(224, 224, 224, 0.7);
+}
+
+/* Card body */
+.rich-card-body {
+    padding: 20px;
+}
+
+/* Text block component */
+.rich-card-text-block {
+    margin: 10px 0;
+    line-height: 1.6;
+    color: #d0d0d0;
+}
+
+.rich-card-text-normal {
+    font-weight: normal;
+}
+
+.rich-card-text-bold {
+    font-weight: 600;
+    color: #e0e0e0;
+}
+
+.rich-card-text-muted {
+    color: rgba(224, 224, 224, 0.6);
+    font-size: 0.9rem;
+}
+
+.rich-card-text-small {
+    font-size: 0.85rem;
+}
+
+/* Key-value component */
+.rich-card-key-value {
+    display: flex;
+    justify-content: space-between;
+    align-items: center;
+    padding: 10px 0;
+    border-bottom: 1px solid rgba(138, 43, 226, 0.1);
+}
+
+.rich-card-key-value:last-child {
+    border-bottom: none;
+}
+
+.rich-card-key {
+    font-weight: 500;
+    color: rgba(224, 224, 224, 0.8);
+    margin-right: 16px;
+}
+
+.rich-card-value {
+    font-weight: 400;
+    color: #e0e0e0;
+    text-align: right;
+}
+
+.rich-card-key-value-emphasized {
+    background: rgba(138, 43, 226, 0.1);
+    padding: 12px 16px;
+    margin: 0 -20px;
+    border-radius: 6px;
+    border: 1px solid rgba(138, 43, 226, 0.2);
+}
+
+.rich-card-key-value-emphasized .rich-card-key {
+    font-weight: 600;
+    font-size: 1.05rem;
+    color: #e0e0e0;
+}
+
+.rich-card-key-value-emphasized .rich-card-value {
+    font-weight: 600;
+    font-size: 1.1rem;
+    color: #b19cd9;
+}
+
+/* Divider component */
+.rich-card-divider {
+    height: 1px;
+    background: linear-gradient(
+            to right,
+            transparent,
+            rgba(138, 43, 226, 0.4) 50%,
+            transparent
+    );
+    margin: 16px 0;
+}
+
+/* List component */
+.rich-card-list {
+    margin: 12px 0;
+    padding-left: 0;
+    color: #d0d0d0;
+}
+
+.rich-card-list-bullet {
+    list-style-type: none;
+    padding-left: 20px;
+}
+
+.rich-card-list-bullet li {
+    position: relative;
+    margin: 8px 0;
+    padding-left: 20px;
+}
+
+.rich-card-list-bullet li::before {
+    content: "✦";
+    position: absolute;
+    left: 0;
+    color: #b19cd9;
+    font-size: 0.8rem;
+}
+
+.rich-card-list-numbered {
+    padding-left: 24px;
+    counter-reset: item;
+}
+
+.rich-card-list-numbered li {
+    margin: 8px 0;
+    counter-increment: item;
+}
+
+.rich-card-list-numbered li::marker {
+    color: #b19cd9;
+    font-weight: 600;
+}
+
+.rich-card-list-plain .rich-card-list-item {
+    margin: 8px 0;
+    padding: 6px 0;
+    border-left: 2px solid rgba(138, 43, 226, 0.3);
+    padding-left: 12px;
+}
+
+/* Section component */
+.rich-card-section {
+    margin: 16px 0;
+    padding: 16px;
+    background: rgba(0, 0, 0, 0.2);
+    border-radius: 8px;
+    border-left: 3px solid rgba(138, 43, 226, 0.4);
+}
+
+.rich-card-section-depth-1 {
+    border-left-color: rgba(138, 43, 226, 0.6);
+}
+
+.rich-card-section-depth-2 {
+    border-left-color: rgba(138, 43, 226, 0.4);
+    margin-left: 12px;
+}
+
+.rich-card-section-depth-3 {
+    border-left-color: rgba(138, 43, 226, 0.3);
+    margin-left: 20px;
+}
+
+.rich-card-section-header {
+    margin-bottom: 12px;
+}
+
+.rich-card-section-title {
+    margin: 0;
+    font-size: 1.1rem;
+    font-weight: 600;
+    color: #e0e0e0;
+    text-shadow: 0 0 8px rgba(138, 43, 226, 0.2);
+}
+
+.rich-card-section-subtitle {
+    margin: 4px 0 0 0;
+    font-size: 0.85rem;
+    color: rgba(224, 224, 224, 0.6);
+}
+
+.rich-card-section-body {
+    padding-left: 8px;
+}
+
+/* Grid component */
+.rich-card-grid {
+    display: grid;
+    gap: 12px;
+    margin: 12px 0;
+}
+
+.rich-card-grid-item {
+    background: rgba(0, 0, 0, 0.2);
+    padding: 12px;
+    border-radius: 6px;
+    border: 1px solid rgba(138, 43, 226, 0.2);
+}
+
+.rich-card-grid-key {
+    font-size: 0.85rem;
+    color: rgba(224, 224, 224, 0.7);
+    margin-bottom: 4px;
+}
+
+.rich-card-grid-value {
+    font-size: 1.1rem;
+    font-weight: 600;
+    color: #e0e0e0;
+}
+
+/* Badge component */
+.rich-card-badge {
+    display: inline-block;
+    padding: 4px 12px;
+    border-radius: 12px;
+    font-size: 0.85rem;
+    font-weight: 600;
+    text-transform: uppercase;
+    letter-spacing: 0.5px;
+}
+
+.rich-card-badge-success {
+    background: rgba(76, 175, 80, 0.2);
+    color: #81c784;
+    border: 1px solid rgba(76, 175, 80, 0.4);
+    box-shadow: 0 0 8px rgba(76, 175, 80, 0.2);
+}
+
+.rich-card-badge-warning {
+    background: rgba(255, 152, 0, 0.2);
+    color: #ffb74d;
+    border: 1px solid rgba(255, 152, 0, 0.4);
+    box-shadow: 0 0 8px rgba(255, 152, 0, 0.2);
+}
+
+.rich-card-badge-error {
+    background: rgba(244, 67, 54, 0.2);
+    color: #e57373;
+    border: 1px solid rgba(244, 67, 54, 0.4);
+    box-shadow: 0 0 8px rgba(244, 67, 54, 0.2);
+}
+
+.rich-card-badge-info {
+    background: rgba(33, 150, 243, 0.2);
+    color: #64b5f6;
+    border: 1px solid rgba(33, 150, 243, 0.4);
+    box-shadow: 0 0 8px rgba(33, 150, 243, 0.2);
+}
+
+.rich-card-badge-neutral {
+    background: rgba(138, 43, 226, 0.2);
+    color: #b19cd9;
+    border: 1px solid rgba(138, 43, 226, 0.4);
+    box-shadow: 0 0 8px rgba(138, 43, 226, 0.2);
+}
+
+/* Unknown component fallback */
+.rich-card-unknown {
+    display: flex;
+    align-items: center;
+    gap: 8px;
+    padding: 12px;
+    background: rgba(255, 152, 0, 0.1);
+    border: 1px dashed rgba(255, 152, 0, 0.4);
+    border-radius: 6px;
+    margin: 8px 0;
+}
+
+.rich-card-unknown-icon {
+    font-size: 1.2rem;
+}
+
+.rich-card-unknown-text {
+    color: #ffb74d;
+    font-size: 0.9rem;
+}
+
+/* Responsive adjustments */
+@media (max-width: 640px) {
+    .rich-card {
+        margin: 8px 0;
+    }
+
+    .rich-card-header {
+        padding: 12px 16px;
+    }
+
+    .rich-card-body {
+        padding: 16px;
+    }
+
+    .rich-card-title {
+        font-size: 1.1rem;
+    }
+
+    .rich-card-grid {
+        grid-template-columns: 1fr !important;
+    }
+
+    .rich-card-key-value {
+        flex-direction: column;
+        align-items: flex-start;
+    }
+
+    .rich-card-value {
+        text-align: left;
+        margin-top: 4px;
+    }
+}
\ No newline at end of file
Index: Morgana.Framework/Abstractions/MorganaTool.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Microsoft.Extensions.Logging;\nusing Morgana.Framework.Providers;\nusing System.Text.Json;\n\nnamespace Morgana.Framework.Abstractions;\n\n/// <summary>\n/// Base class for agent tools that provides context variable access (Get/Set operations).\n/// Tools can read from and write to the agent's conversation context via MorganaAIContextProvider.\n/// </summary>\n/// <remarks>\n/// <para><strong>Purpose:</strong></para>\n/// <para>MorganaTool provides a foundation for building tools that agents can call during LLM interactions.\n/// The most critical feature is context variable management, which allows agents to remember information\n/// across multiple turns and share information with other agents.</para>\n/// <para><strong>Architecture:</strong></para>\n/// <code>\n/// MorganaTool (base class with context access)\n///   ├── GetInvoices (domain-specific tool)\n///   ├── GetContractDetails (domain-specific tool)\n///   └── ... other custom tools\n/// </code>\n/// <para><strong>Context Variable Types:</strong></para>\n/// <list type=\"bullet\">\n/// <item><term>Local variables</term><description>Agent-specific, not shared with other agents</description></item>\n/// <item><term>Shared variables</term><description>Broadcast to all agents via RouterActor for cross-agent coordination</description></item>\n/// </list>\n/// <para><strong>Usage Pattern:</strong></para>\n/// <para>Tools inherit from MorganaTool and use GetContextVariable/SetContextVariable to interact with\n/// conversation context. The LLM decides when to call these operations based on agent prompts.</para>\n/// <para><strong>Example:</strong></para>\n/// <code>\n/// public class GetInvoicesTool : MorganaTool\n/// {\n///     [ProvideToolForIntent(\"billing\")]\n///     public async Task&lt;InvoiceList&gt; GetInvoices(int count)\n///     {\n///         // First, try to get userId from context\n///         object userId = await GetContextVariable(\"userId\");\n///\n///         // If missing, prompt LLM to ask user\n///         // If present, fetch invoices from backend\n///\n///         return invoices;\n///     }\n/// }\n/// </code>\n/// </remarks>\npublic class MorganaTool\n{\n    /// <summary>\n    /// Logger instance for tool-level diagnostics and context operation tracking.\n    /// </summary>\n    protected readonly ILogger toolLogger;\n\n    /// <summary>\n    /// Factory function to retrieve the current MorganaAIContextProvider instance.\n    /// Uses a function to enable lazy evaluation and ensure correct scoping per request.\n    /// </summary>\n    protected readonly Func<MorganaAIContextProvider> getAIContextProvider;\n\n    /// <summary>\n    /// Initializes a new instance of MorganaTool with logging and AI context provider access.\n    /// </summary>\n    /// <param name=\"toolLogger\">Logger instance for tool diagnostics</param>\n    /// <param name=\"getAIContextProvider\">Factory function to retrieve the AI context provider</param>\n    /// <remarks>\n    /// The AI context provider is passed as a Func to ensure each tool call gets the correct\n    /// scoped provider instance for the current conversation and agent.\n    /// </remarks>\n    public MorganaTool(\n        ILogger toolLogger,\n        Func<MorganaAIContextProvider> getAIContextProvider)\n    {\n        this.toolLogger = toolLogger;\n        this.getAIContextProvider = getAIContextProvider;\n    }\n\n    // =========================================================================\n    // CONTEXT SYSTEM TOOLS\n    // =========================================================================\n\n    /// <summary>\n    /// Retrieves a context variable from the agent's conversation context.\n    /// Used by agents (via LLM tool calling) to check if information is already available before asking the user.\n    /// </summary>\n    /// <param name=\"variableName\">Name of the context variable to retrieve (e.g., \"userId\", \"invoiceId\")</param>\n    /// <returns>\n    /// Task containing the variable value if found, or an instructional message if missing.\n    /// The LLM interprets the returned message and decides whether to call SetContextVariable or ask the user.\n    /// </returns>\n    /// <remarks>\n    /// <para><strong>Critical Rule (from SKILL.md):</strong></para>\n    /// <para>\"Before asking for ANY information from the user, ALWAYS attempt to retrieve it from context using GetContextVariable.\n    /// If the tool returns a valid value, USE IT without asking the user. Ask the user ONLY if the tool indicates the information is missing.\"</para>\n    /// <para><strong>Return Values:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item><term>Variable found (HIT)</term><description>Returns the variable value directly</description></item>\n    /// <item><term>Variable not found (MISS)</term><description>Returns instructional message for LLM</description></item>\n    /// </list>\n    /// <para><strong>Example LLM Interaction:</strong></para>\n    /// <code>\n    /// LLM: \"I need the userId to fetch invoices. Let me check context first.\"\n    /// Tool call: GetContextVariable(\"userId\")\n    /// Response: \"P994E\" (HIT)\n    /// LLM: \"Great! I have the userId. Proceeding to fetch invoices...\"\n    ///\n    /// vs.\n    ///\n    /// LLM: \"I need the userId to fetch invoices. Let me check context first.\"\n    /// Tool call: GetContextVariable(\"userId\")\n    /// Response: \"Information userId not available in context: you need to engage SetContextVariable to set it.\" (MISS)\n    /// LLM: \"Could you please provide your customer ID? #INT#\"\n    /// </code>\n    /// <para><strong>Logging:</strong></para>\n    /// <para>Logs HIT/MISS status with variable name and value for debugging context management issues.</para>\n    /// </remarks>\n    public Task<object> GetContextVariable(string variableName)\n    {\n        MorganaAIContextProvider aiContextProvider = getAIContextProvider();\n        object? value = aiContextProvider.GetVariable(variableName);\n\n        if (value != null)\n        {\n            toolLogger.LogInformation(\n                $\"{nameof(MorganaTool)} ({GetType().Name}) HIT variable '{variableName}' from agent context. Value is: {value}\");\n\n            return Task.FromResult(value);\n        }\n\n        toolLogger.LogInformation(\n            $\"{nameof(MorganaTool)} ({GetType().Name}) MISS variable '{variableName}' from agent context.\");\n\n        return Task.FromResult<object>(\n            $\"Information {variableName} not available in context: you need to engage SetContextVariable to set it.\");\n    }\n\n    /// <summary>\n    /// Sets a context variable in the agent's conversation context.\n    /// If the variable is marked as shared (in configuration), the provider automatically broadcasts it to other agents.\n    /// </summary>\n    /// <param name=\"variableName\">Name of the context variable to set (e.g., \"userId\", \"invoiceId\")</param>\n    /// <param name=\"variableValue\">Value to store in the context</param>\n    /// <returns>Task containing a confirmation message for the LLM</returns>\n    /// <remarks>\n    /// <para><strong>Shared vs Local Variables:</strong></para>\n    /// <para>Whether a variable is shared or local is determined by tool configuration in agents.json.\n    /// Tools declare parameters with \"Scope\": \"context\" and \"Shared\": true/false.</para>\n    /// <para><strong>Shared Variable Flow (example: userId):</strong></para>\n    /// <list type=\"number\">\n    /// <item>BillingAgent calls SetContextVariable(\"userId\", \"P994E\")</item>\n    /// <item>MorganaAIContextProvider.SetVariable checks configuration: userId is marked Shared=true</item>\n    /// <item>Provider calls agent's OnSharedContextUpdate callback</item>\n    /// <item>Agent broadcasts to RouterActor via BroadcastContextUpdate</item>\n    /// <item>RouterActor sends ReceiveContextUpdate to all other agents</item>\n    /// <item>ContractAgent and MonkeysAgent receive and merge the userId</item>\n    /// <item>All agents can now use userId without asking the user again</item>\n    /// </list>\n    /// <para><strong>Local Variable Flow (example: invoiceId):</strong></para>\n    /// <list type=\"number\">\n    /// <item>BillingAgent calls SetContextVariable(\"invoiceId\", \"INV-2024-001\")</item>\n    /// <item>MorganaAIContextProvider.SetVariable checks configuration: invoiceId is marked Shared=false</item>\n    /// <item>Variable stored locally, no broadcast occurs</item>\n    /// <item>Only BillingAgent can access this variable</item>\n    /// </list>\n    /// <para><strong>LLM Feedback:</strong></para>\n    /// <para>Returns a confirmation message that the LLM sees, confirming the variable was stored.\n    /// This helps the LLM understand that the information is now available for future tool calls.</para>\n    /// </remarks>\n    public Task<object> SetContextVariable(string variableName, string variableValue)\n    {\n        MorganaAIContextProvider aiContextProvider = getAIContextProvider();\n        aiContextProvider.SetVariable(variableName, variableValue);\n\n        return Task.FromResult<object>(\n            $\"Information {variableName} inserted in context with value: {variableValue}\");\n    }\n\n    // =========================================================================\n    // QUICK REPLY SYSTEM TOOL\n    // =========================================================================\n\n    /// <summary>\n    /// System tool that allows the LLM to set quick reply buttons for the user interface.\n    /// This tool gives the LLM control over when and how to offer guided interaction options.\n    /// </summary>\n    /// <param name=\"quickReplies\">\n    /// JSON string containing an array of quick reply definitions.\n    /// Each quick reply has: id (identifier), label (display text with emoji), value (message to send).\n    /// </param>\n    /// <returns>Confirmation message for the LLM indicating quick replies were set</returns>\n    /// <remarks>\n    /// <para><strong>Purpose:</strong></para>\n    /// <para>SetQuickReplies is a SYSTEM TOOL that the LLM can call when it wants to provide\n    /// guided interaction options to the user. This gives the LLM full control over quick reply\n    /// generation based on conversation context.</para>\n    ///\n    /// <para><strong>LLM Decision Making:</strong></para>\n    /// <para>The LLM decides to call SetQuickReplies when:</para>\n    /// <list type=\"bullet\">\n    /// <item>Presenting multiple options to choose from (guides, invoices, actions)</item>\n    /// <item>Asking a question with predefined answers (yes/no, selections)</item>\n    /// <item>Offering next steps after completing an operation</item>\n    /// <item>Providing navigation options in a multi-step workflow</item>\n    /// </list>\n    ///\n    /// <para><strong>JSON Format Expected:</strong></para>\n    /// <code>\n    /// [\n    ///   {\n    ///     \"id\": \"no-internet\",\n    ///     \"label\": \"\uD83D\uDD34 No Internet Connection\",\n    ///     \"value\": \"Show me the no-internet assistance guide\"\n    ///   },\n    ///   {\n    ///     \"id\": \"slow-speed\",\n    ///     \"label\": \"\uD83D\uDC0C Slow Connection Speed\",\n    ///     \"value\": \"Show me the slow-connection assistance guide\"\n    ///   }\n    /// ]\n    /// </code>\n    ///\n    /// <para><strong>Single Record Design:</strong></para>\n    /// <para>Uses QuickReply with JsonPropertyName attributes.\n    /// Same record serves as both runtime model and JSON DTO - no duplication!</para>\n    ///\n    /// <para><strong>Design Guidelines for LLM:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item><term>Use emoji in labels</term><description>Visual appeal: \"\uD83D\uDD27 Run Diagnostics\" not \"Run Diagnostics\"</description></item>\n    /// <item><term>Action-oriented labels</term><description>\"Show Invoice Details\" not \"Invoice Details\"</description></item>\n    /// <item><term>Natural values</term><description>Value should be what user would naturally type</description></item>\n    /// <item><term>Clear IDs</term><description>Use descriptive IDs like \"invoice-001\" not \"btn1\"</description></item>\n    /// </list>\n    /// </remarks>\n    public Task<object> SetQuickReplies(string quickReplies)\n    {\n        try\n        {\n            // Validate JSON by attempting to parse\n            List<Records.QuickReply>? parsedQuickReplies = JsonSerializer.Deserialize<List<Records.QuickReply>>(quickReplies);\n            if (parsedQuickReplies == null || !parsedQuickReplies.Any())\n            {\n                toolLogger.LogWarning(\"SetQuickReplies called with empty or invalid JSON\");\n                return Task.FromResult<object>(\"Warning: No quick replies were set (empty or invalid data).\");\n            }\n\n            // Store the JSON string of the quick replies under a reserved context variable\n            MorganaAIContextProvider aiContextProvider = getAIContextProvider();\n            aiContextProvider.SetVariable(\"quick_replies\", quickReplies);\n\n            toolLogger.LogInformation($\"LLM set {parsedQuickReplies.Count} quick reply buttons via SetQuickReplies tool\");\n\n            // Return confirmation to LLM\n            return Task.FromResult<object>(\n                $\"Quick reply buttons set successfully. The user will see {parsedQuickReplies.Count} interactive options. \" +\n                $\"Now provide your text response to the user - the quick reply buttons will appear below your message.\");\n        }\n        catch (JsonException ex)\n        {\n            toolLogger.LogError(ex, \"Failed to parse quick replies JSON in SetQuickReplies\");\n            return Task.FromResult<object>(\n                \"Error: Quick replies JSON format is invalid. Expected format: \" +\n                \"[{\\\"id\\\": \\\"option1\\\", \\\"label\\\": \\\"\uD83D\uDD27 Option 1\\\", \\\"value\\\": \\\"User message for option 1\\\"}]\");\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Abstractions/MorganaTool.cs b/Morgana.Framework/Abstractions/MorganaTool.cs
--- a/Morgana.Framework/Abstractions/MorganaTool.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Abstractions/MorganaTool.cs	(date 1770320379300)
@@ -263,4 +263,156 @@
                 "[{\"id\": \"option1\", \"label\": \"🔧 Option 1\", \"value\": \"User message for option 1\"}]");
         }
     }
+
+    // =========================================================================
+    // RICH CARD SYSTEM TOOL
+    // =========================================================================
+
+    /// <summary>
+    /// Sets a rich card for structured visual presentation of complex data.
+    /// LLM calls this tool when presenting invoices, profiles, reports, or any structured information
+    /// that benefits from visual hierarchy instead of plain text.
+    /// </summary>
+    /// <param name="richCardJson">
+    /// JSON string containing the rich card structure with title, subtitle, and components array.
+    /// </param>
+    /// <returns>Confirmation message for the LLM indicating the card was set</returns>
+    /// <remarks>
+    /// <para><strong>Purpose:</strong></para>
+    /// <para>SetRichCard is a SYSTEM TOOL enabling the LLM to present structured data visually.
+    /// Similar to SetQuickReplies but for data presentation rather than user actions.</para>
+    ///
+    /// <para><strong>LLM Decision Making:</strong></para>
+    /// <para>The LLM should call SetRichCard when presenting:</para>
+    /// <list type="bullet">
+    /// <item>Invoices, receipts, financial documents</item>
+    /// <item>User or product profiles</item>
+    /// <item>Structured reports with sections</item>
+    /// <item>Comparisons or side-by-side data</item>
+    /// <item>Any data that benefits from visual organization</item>
+    /// </list>
+    ///
+    /// <para><strong>JSON Format Expected:</strong></para>
+    /// <code>
+    /// {
+    ///   "title": "Invoice #2024-001",
+    ///   "subtitle": "Issued on 15/01/2024",
+    ///   "components": [
+    ///     { "type": "key_value", "key": "Customer", "value": "Acme Corp" },
+    ///     { "type": "divider" },
+    ///     { "type": "section", "title": "Line Items", "components": [
+    ///       { "type": "list", "items": ["Consulting: €800", "Development: €450"], "style": "plain" }
+    ///     ]},
+    ///     { "type": "key_value", "key": "Total", "value": "€1,250.00", "emphasize": true },
+    ///     { "type": "badge", "text": "Paid", "variant": "success" }
+    ///   ]
+    /// }
+    /// </code>
+    ///
+    /// <para><strong>Constraints:</strong></para>
+    /// <list type="bullet">
+    /// <item>Maximum nesting depth: 3 levels (validated before storage)</item>
+    /// <item>Maximum 50 components total (prevents abuse)</item>
+    /// <item>Keep cards focused: 10-20 components recommended</item>
+    /// </list>
+    /// </remarks>
+    public Task<object> SetRichCard(string richCardJson)
+    {
+        try
+        {
+            // Validate JSON by attempting to deserialize
+            Records.RichCard? richCard = JsonSerializer.Deserialize<Records.RichCard>(
+                richCardJson, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
+            );
+
+            if (richCard == null)
+            {
+                toolLogger.LogWarning("SetRichCard called with invalid JSON structure");
+                return Task.FromResult<object>("Error: Rich card JSON structure is invalid.");
+            }
+
+            // Validate depth constraint (max 3 levels)
+            int depth = CalculateMaxDepth(richCard.Components, 1);
+            if (depth > 3)
+            {
+                toolLogger.LogWarning($"SetRichCard called with excessive nesting depth: {depth} (max 3)");
+                return Task.FromResult<object>(
+                    $"Error: Rich card exceeds maximum nesting depth of 3 (found: {depth}). " +
+                    $"Please simplify the card structure.");
+            }
+
+            // Validate component count (max 50 to prevent abuse)
+            int totalComponents = CountComponents(richCard.Components);
+            if (totalComponents > 50)
+            {
+                toolLogger.LogWarning($"SetRichCard called with too many components: {totalComponents} (max 50)");
+                return Task.FromResult<object>(
+                    $"Error: Rich card has too many components: {totalComponents} (max 50). " +
+                    $"Please create a more focused card.");
+            }
+
+            // Store the rich card JSON under a reserved context variable
+            MorganaAIContextProvider aiContextProvider = getAIContextProvider();
+            aiContextProvider.SetVariable("rich_card", richCardJson);
+
+            toolLogger.LogInformation(
+                $"LLM set rich card '{richCard.Title}' with {totalComponents} components " +
+                $"(depth: {depth}) via SetRichCard tool");
+
+            // Return confirmation to LLM
+            return Task.FromResult<object>(
+                $"Rich card set successfully. The user will see a structured visual card titled '{richCard.Title}'. " +
+                $"You can now provide additional context or explanation in text if needed.");
+        }
+        catch (JsonException ex)
+        {
+            toolLogger.LogError(ex, "Failed to parse rich card JSON in SetRichCard");
+            return Task.FromResult<object>(
+                "Error: Rich card JSON format is invalid. Please check the structure and try again.");
+        }
+    }
+
+    /// <summary>
+    /// Calculates the maximum nesting depth of components in a card.
+    /// Used by SetRichCard to enforce 3-level depth constraint.
+    /// </summary>
+    /// <param name="components">List of card components to analyze</param>
+    /// <param name="currentDepth">Current depth level (starts at 1)</param>
+    /// <returns>Maximum depth found in the component tree</returns>
+    private int CalculateMaxDepth(List<Records.CardComponent> components, int currentDepth)
+    {
+        int maxDepth = currentDepth;
+
+        foreach (Records.CardComponent component in components)
+        {
+            if (component is Records.SectionComponent section)
+            {
+                int sectionDepth = CalculateMaxDepth(section.Components, currentDepth + 1);
+                maxDepth = Math.Max(maxDepth, sectionDepth);
+            }
+        }
+
+        return maxDepth;
+    }
+
+    /// <summary>
+    /// Counts total number of components recursively (including nested sections).
+    /// Used by SetRichCard to enforce 50-component limit.
+    /// </summary>
+    /// <param name="components">List of card components to count</param>
+    /// <returns>Total component count including all nested components</returns>
+    private int CountComponents(List<Records.CardComponent> components)
+    {
+        int count = components.Count;
+
+        foreach (Records.CardComponent component in components)
+        {
+            if (component is Records.SectionComponent section)
+            {
+                count += CountComponents(section.Components);
+            }
+        }
+
+        return count;
+    }
 }
\ No newline at end of file
Index: Morgana.SignalR/Messages/SignalRMessage.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using static Morgana.Framework.Records;\n\nnamespace Morgana.SignalR.Messages;\n\n\n/// <summary>\n/// <para>\n/// SignalR message contract for \"ReceiveMessage\" event.\n/// This matches Cauldron.Messages.SignalRMessage schema.\n/// </para>\n/// <para>\n/// CONTRACT VERSION: 1.0<br/>\n/// SYNC WITH: Cauldron\n/// </para>\n/// <para>\n/// BREAKING CHANGES: Any modification to required fields or removal of fields is a breaking change.\n/// SAFE CHANGES: Adding optional fields with default values.\n/// </para>\n/// <para>\n/// ⚠\uFE0F IMPORTANT: This DTO is duplicated in Cauldron frontend (Cauldron.Messages.SignalRMessage).\n/// When making changes, update both versions and ensure backward compatibility.\n/// Test serialization/deserialization compatibility with integration tests.\n/// </para>\n/// </summary>\n/// <remarks>\n/// <para><strong>Contract Sync Policy:</strong></para>\n/// <list type=\"bullet\">\n/// <item>Required fields must match exactly between backend and frontend</item>\n/// <item>Optional fields can be added without breaking compatibility (use default values)</item>\n/// <item>Field removal or type changes are BREAKING and require coordinated deployment</item>\n/// </list>\n/// <para><strong>Wire Format (JSON):</strong></para>\n/// <code>\n/// {\n///   \"conversationId\": \"abc123\",\n///   \"text\": \"Hello! How can I help you today?\",\n///   \"timestamp\": \"2025-01-23T10:30:00Z\",\n///   \"messageType\": \"assistant\",\n///   \"quickReplies\": [\n///     { \"id\": \"billing\", \"label\": \"\uD83D\uDCB3 Billing\", \"value\": \"Show invoices\", \"termination\": false }\n///   ],\n///   \"errorReason\": null,\n///   \"agentName\": \"Morgana (Billing)\",\n///   \"agentCompleted\": true\n/// }\n/// </code>\n/// </remarks>\npublic sealed class SignalRMessage\n{\n    /// <summary>\n    /// Unique identifier of the conversation this message belongs to.\n    /// Used for SignalR group routing and conversation correlation.\n    /// </summary>\n    public required string ConversationId { get; init; }\n\n    /// <summary>\n    /// Message text to display to the user.\n    /// May contain markdown, emojis, or plain text depending on UI renderer capabilities.\n    /// </summary>\n    public required string Text { get; init; }\n\n    /// <summary>\n    /// UTC timestamp when this message was generated by the backend.\n    /// Used for message ordering and display in the UI.\n    /// </summary>\n    public DateTime Timestamp { get; init; }\n\n    /// <summary>\n    /// Type of message for UI rendering and styling.\n    /// Valid values: \"assistant\", \"presentation\", \"system\", \"error\"\n    /// Default: \"assistant\"\n    /// </summary>\n    public string MessageType { get; init; } = \"assistant\";\n\n    /// <summary>\n    /// Optional list of quick reply buttons for user interaction.\n    /// When present, UI should render these as clickable buttons.\n    /// QuickReplies are generated by the LLM and constitute a stable contract.\n    /// Null when no quick replies are available.\n    /// </summary>\n    public List<QuickReply>? QuickReplies { get; init; }\n\n    /// <summary>\n    /// Optional error reason code when MessageType is \"error\".\n    /// Examples: \"TIMEOUT\", \"INVALID_INPUT\", \"SERVICE_UNAVAILABLE\"\n    /// Null for non-error messages.\n    /// </summary>\n    public string? ErrorReason { get; init; }\n\n    /// <summary>\n    /// Name of the agent that generated this message.\n    /// Examples: \"Morgana\", \"Morgana (Billing)\", \"Morgana (Technical Support)\"\n    /// Used for UI theming, avatar selection, and conversation context.\n    /// Default: \"Morgana\"\n    /// </summary>\n    public string AgentName { get; init; } = \"Morgana\";\n\n    /// <summary>\n    /// Indicates whether this specialized agent has completed its task.\n    /// When true, control returns to the base Morgana orchestrator.\n    /// UI should return to default state (purple theme, base avatar, etc.)\n    /// Default: false\n    /// </summary>\n    public bool AgentCompleted { get; init; }\n\n    /// <summary>\n    /// Duration of the eventual fading message which will be generated\n    /// by this SignalR message (depending on its MessageType).\n    /// </summary>\n    public int? FadingMessageDurationSeconds { get; set; } = 10;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.SignalR/Messages/SignalRMessage.cs b/Morgana.SignalR/Messages/SignalRMessage.cs
--- a/Morgana.SignalR/Messages/SignalRMessage.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.SignalR/Messages/SignalRMessage.cs	(date 1770321808916)
@@ -80,6 +80,19 @@
     /// </summary>
     public List<QuickReply>? QuickReplies { get; init; }
 
+    /// <summary>
+    /// Optional rich card for structured visual presentation.
+    /// When present, renders structured data components instead of plain text formatting.
+    /// </summary>
+    /// <remarks>
+    /// <para>Rich cards are generated by agents via the SetRichCard tool when presenting
+    /// complex structured information like invoices, profiles, reports, or comparisons.</para>
+    /// <para>The card contains a title, optional subtitle, and an array of visual components
+    /// (key-value pairs, lists, sections, badges, etc.) that Cauldron renders using specialized
+    /// Razor components.</para>
+    /// </remarks>
+    public RichCard? RichCard { get; set; }
+
     /// <summary>
     /// Optional error reason code when MessageType is "error".
     /// Examples: "TIMEOUT", "INVALID_INPUT", "SERVICE_UNAVAILABLE"
Index: ../Cauldron/Messages/ChatMessage.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>namespace Cauldron.Messages;\n\n/// <summary>\n/// Represents a chat message in the Cauldron UI.\n/// Used to display user messages, agent responses, typing indicators, and error messages.\n/// </summary>\n/// <remarks>\n/// <para><strong>Message Lifecycle:</strong></para>\n/// <list type=\"number\">\n/// <item>User types message → ChatMessage created with Type = User</item>\n/// <item>Typing indicator shown → ChatMessage created with IsTyping = true</item>\n/// <item>Agent responds via SignalR → ChatMessage created with Type = Assistant</item>\n/// <item>Optional quick replies attached → QuickReplies list populated</item>\n/// <item>User clicks quick reply → SelectedQuickReplyId set, all buttons disabled</item>\n/// </list>\n/// <para><strong>Message Types:</strong></para>\n/// <list type=\"bullet\">\n/// <item><term>User</term><description>Message from the user</description></item>\n/// <item><term>Assistant</term><description>Regular response from agent</description></item>\n/// <item><term>Presentation</term><description>Welcome/completion message with special styling</description></item>\n/// <item><term>Error</term><description>Error message with error styling</description></item>\n/// </list>\n/// </remarks>\npublic class ChatMessage\n{\n    /// <summary>\n    /// Unique identifier of the conversation this message belongs to.\n    /// </summary>\n    public string ConversationId { get; set; } = string.Empty;\n\n    /// <summary>\n    /// Message text content displayed to the user.\n    /// </summary>\n    public string Text { get; set; } = string.Empty;\n\n    /// <summary>\n    /// Timestamp when the message was created or received.\n    /// Displayed in HH:mm format in the UI.\n    /// </summary>\n    public DateTime Timestamp { get; set; }\n\n    /// <summary>\n    /// Type of message determining styling and behavior.\n    /// </summary>\n    public MessageType Type { get; set; }\n\n    /// <summary>\n    /// Optional list of quick reply buttons attached to this message.\n    /// Only applicable for assistant messages (typically presentation messages).\n    /// </summary>\n    public List<QuickReply>? QuickReplies { get; set; }\n\n    /// <summary>\n    /// Optional error reason if Type = Error.\n    /// Contains technical error details for debugging.\n    /// </summary>\n    public string? ErrorReason { get; set; }\n\n    /// <summary>\n    /// Name of the agent that generated this message.\n    /// Examples: \"Morgana\", \"Morgana (Billing)\", \"Morgana (Contract)\", ...\n    /// Used to display agent avatar and header color.\n    /// </summary>\n    public string AgentName { get; set; } = \"Morgana\";\n\n    /// <summary>\n    /// Indicates whether the agent has completed its task after this message.\n    /// When true, the UI returns to idle state (header shows \"Morgana\", purple color).\n    /// </summary>\n    public bool AgentCompleted { get; set; } = false;\n\n    /// <summary>\n    /// Tracks which quick reply button was clicked by the user.\n    /// When set, all quick reply buttons are disabled and the selected one shows a checkmark.\n    /// </summary>\n    public string? SelectedQuickReplyId { get; set; }\n\n    /// <summary>\n    /// Gets or sets the message role for CSS styling (\"user\" or \"assistant\").\n    /// Automatically converts between MessageType enum and string role.\n    /// </summary>\n    /// <remarks>\n    /// <para><strong>Conversion Logic:</strong></para>\n    /// <code>\n    /// MessageType.User → \"user\"\n    /// MessageType.Assistant → \"assistant\"\n    /// MessageType.Presentation → \"assistant\"\n    /// MessageType.Error → \"assistant\"\n    /// </code>\n    /// </remarks>\n    public string Role\n    {\n        get => Type switch\n        {\n            MessageType.User => \"user\",\n            _ => \"assistant\"\n        };\n        set => Type = value switch\n        {\n            \"user\" => MessageType.User,\n            _ => MessageType.Assistant\n        };\n    }\n\n    /// <summary>\n    /// Indicates whether this message is a typing indicator.\n    /// When true, displays animated three-dot typing indicator instead of text.\n    /// </summary>\n    /// <remarks>\n    /// Typing indicators are temporary messages removed when the actual agent response arrives.\n    /// </remarks>\n    public bool IsTyping { get; set; }\n\n    /// <summary>\n    /// Indicates whether this message represents an error.\n    /// When true, message displays with error styling (red/warning appearance).\n    /// </summary>\n    public bool IsError { get; set; }\n\n    /// <summary>\n    /// Optional flag indicating that this is the last message of a resumed conversation.\n    /// </summary>\n    public bool? IsLastHistoryMessage { get; init; }\n\n    /// <summary>\n    /// Indicates whether this message is currently being streamed from the backend.\n    /// When true, the message text is progressively updated by the typewriter effect.\n    /// When false, the message is complete and immutable.\n    /// </summary>\n    public bool IsStreaming { get; set; }\n}\n\n/// <summary>\n/// Enumeration of message types for styling and behavior differentiation.\n/// </summary>\npublic enum MessageType\n{\n    /// <summary>\n    /// Message from the user.\n    /// Displayed on the right side with user styling.\n    /// </summary>\n    User,\n\n    /// <summary>\n    /// Regular response from an agent.\n    /// Displayed on the left side with agent avatar and assistant styling.\n    /// </summary>\n    Assistant,\n\n    /// <summary>\n    /// Welcome or completion message with special styling.\n    /// Typically includes quick reply buttons for user interaction.\n    /// </summary>\n    Presentation,\n\n    /// <summary>\n    /// Error message with error styling.\n    /// Displayed when backend errors occur or exceptions are caught.\n    /// </summary>\n    Error\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Cauldron/Messages/ChatMessage.cs b/../Cauldron/Messages/ChatMessage.cs
--- a/../Cauldron/Messages/ChatMessage.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/../Cauldron/Messages/ChatMessage.cs	(date 1770322557521)
@@ -50,6 +50,13 @@
     /// </summary>
     public List<QuickReply>? QuickReplies { get; set; }
 
+    /// <summary>
+    /// Optional rich card for structured visual presentation of complex data.
+    /// When present, renders structured components instead of plain text formatting.
+    /// Rendered between message text and quick replies.
+    /// </summary>
+    public RichCard? RichCard { get; set; }
+
     /// <summary>
     /// Optional error reason if Type = Error.
     /// Contains technical error details for debugging.
Index: Morgana.Framework/Interfaces/ISignalRBridgeService.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>namespace Morgana.Framework.Interfaces;\n\n/// <summary>\n/// Service interface for bridging the actor system with SignalR for real-time client communication.\n/// Abstracts SignalR hub context interactions and provides structured message delivery to conversation groups.\n/// </summary>\n/// <remarks>\n/// <para><strong>Purpose:</strong></para>\n/// <para>This service acts as a bridge between the Akka.NET actor system and SignalR, allowing actors to send\n/// messages to clients without direct knowledge of SignalR implementation details.</para>\n/// <para><strong>Responsibilities:</strong></para>\n/// <list type=\"bullet\">\n/// <item>Format messages according to client protocol (messageType, metadata, quick replies)</item>\n/// <item>Route messages to appropriate SignalR conversation groups</item>\n/// <item>Handle error notifications and delivery failures</item>\n/// <item>Support rich message types (text, presentation, quick replies, agent metadata)</item>\n/// </list>\n/// <para><strong>Usage Pattern:</strong></para>\n/// <para>Injected into actors (particularly ConversationManagerActor and ConversationSupervisorActor)\n/// to send responses back to clients after processing through the actor pipeline.</para>\n/// </remarks>\npublic interface ISignalRBridgeService\n{\n    /// <summary>\n    /// Sends a simple text message to a conversation group via SignalR.\n    /// Basic message delivery without structured metadata or quick replies.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation (SignalR group name)</param>\n    /// <param name=\"text\">Message text to send to clients</param>\n    /// <param name=\"errorReason\">Optional error reason code for error messages (e.g., \"guard_violation\", \"timeout\")</param>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// <para><strong>Use cases:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item>Simple text responses from agents</item>\n    /// <item>Error notifications to clients</item>\n    /// <item>System messages (e.g., \"Processing...\", \"Connection restored\")</item>\n    /// </list>\n    /// <para><strong>Note:</strong> For rich messages with quick replies or agent metadata, use SendStructuredMessageAsync instead.</para>\n    /// </remarks>\n    Task SendMessageToConversationAsync(\n        string conversationId,\n        string text,\n        string? errorReason = null);\n\n    /// <summary>\n    /// Sends a structured message with full metadata to a conversation group via SignalR.\n    /// Supports message types, quick replies, agent identification, and completion status.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation (SignalR group name)</param>\n    /// <param name=\"text\">Message text to send to clients</param>\n    /// <param name=\"messageType\">Type of message for client-side rendering (\"assistant\", \"presentation\", \"system\", \"error\")</param>\n    /// <param name=\"quickReplies\">Optional list of quick reply buttons for user interaction</param>\n    /// <param name=\"errorReason\">Optional error reason code for error messages (e.g., \"llm_error\", \"supervisor_error\")</param>\n    /// <param name=\"agentName\">Optional name of the agent that generated the response (e.g., \"Morgana\", \"Morgana (Billing)\")</param>\n    /// <param name=\"agentCompleted\">Flag indicating if the agent has completed its task (affects UI state, conversation flow)</param>\n    /// <param name=\"originalTimestamp\">Timestamp of the message when created in UI</param>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// <para><strong>Message Types:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item><term>\"assistant\"</term><description>Standard AI response from an agent</description></item>\n    /// <item><term>\"presentation\"</term><description>Initial welcome message with quick replies</description></item>\n    /// <item><term>\"system\"</term><description>System notifications (not AI-generated)</description></item>\n    /// <item><term>\"error\"</term><description>Error messages with errorReason code</description></item>\n    /// </list>\n    /// <para><strong>Quick Replies:</strong></para>\n    /// <para>Interactive buttons displayed to the user for common actions or intent selection.\n    /// Used primarily in presentation messages to guide users to available capabilities.</para>\n    /// <para><strong>Agent Metadata:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item><term>agentName</term><description>Displayed in UI to show which specialized agent is responding</description></item>\n    /// <item><term>agentCompleted</term><description>When true, signals the client that the multi-turn interaction is complete\n    /// and the conversation returns to idle state (affects UI indicators, enables new intent classification)</description></item>\n    /// <item><term>originalTimestamp</term><description>Timestamp of the message when created in UI</description></item>\n    /// </list>\n    /// <para><strong>Example Usage:</strong></para>\n    /// <code>\n    /// // Send presentation with quick replies\n    /// await SendStructuredMessageAsync(\n    ///     conversationId: \"conv-123\",\n    ///     text: \"Welcome! How can I help you?\",\n    ///     messageType: \"presentation\",\n    ///     quickReplies: [new QuickReply(\"billing\", \"\uD83D\uDCC4 View Invoices\", \"Show my invoices\")],\n    ///     agentName: \"Morgana\",\n    ///     agentCompleted: false,\n    ///     originalTimestamp: \"2026-01-23T12:15:00Z\"\n    /// );\n    ///\n    /// // Send agent response with completion\n    /// await SendStructuredMessageAsync(\n    ///     conversationId: \"conv-123\",\n    ///     text: \"Here are your recent invoices...\",\n    ///     messageType: \"assistant\",\n    ///     quickReplies: null,\n    ///     agentName: \"Morgana (Billing)\",\n    ///     agentCompleted: true,  // Billing agent finished, return to idle\n    ///     originalTimestamp: \"2026-01-23T12:15:00Z\"\n    /// );\n    /// </code>\n    /// </remarks>\n    Task SendStructuredMessageAsync(\n        string conversationId,\n        string text,\n        string messageType,\n        List<Records.QuickReply>? quickReplies = null,\n        string? errorReason = null,\n        string? agentName = null,\n        bool agentCompleted = false,\n        DateTime? originalTimestamp = null);\n\n    /// <summary>\n    /// Sends a streaming chunk to a conversation group via SignalR for progressive response rendering.\n    /// Enables real-time display of agent responses as they are generated by the LLM.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation (SignalR group name)</param>\n    /// <param name=\"chunkText\">Partial response text to append to the current message</param>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// <para><strong>Purpose:</strong></para>\n    /// <para>This method enables streaming responses from agents, allowing clients to display partial results\n    /// in real-time as the LLM generates them. This significantly improves perceived latency and user experience.</para>\n    /// <para><strong>Usage Pattern:</strong></para>\n    /// <list type=\"number\">\n    /// <item>Agent begins streaming response via RunStreamingAsync</item>\n    /// <item>Each chunk flows: Agent → Router → Supervisor → Manager → SignalR → Client</item>\n    /// <item>Client appends chunks to current message in UI</item>\n    /// <item>When streaming completes, final AgentResponse is sent with metadata (quick replies, completion status)</item>\n    /// </list>\n    /// <para><strong>Client-side Handler:</strong></para>\n    /// <code>\n    /// connection.on(\"ReceiveStreamChunk\", (chunk) => {\n    ///   // Append chunk to currently displaying message\n    ///   currentMessage.text += chunk;\n    ///   updateUI(currentMessage);\n    /// });\n    /// </code>\n    /// <para><strong>Performance:</strong></para>\n    /// <para>Chunks are sent as fire-and-forget operations without logging to minimize overhead.\n    /// Error handling is intentionally silent to prevent stream interruption on partial delivery failures.</para>\n    /// </remarks>\n    Task SendStreamChunkAsync(\n        string conversationId,\n        string chunkText);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Interfaces/ISignalRBridgeService.cs b/Morgana.Framework/Interfaces/ISignalRBridgeService.cs
--- a/Morgana.Framework/Interfaces/ISignalRBridgeService.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Interfaces/ISignalRBridgeService.cs	(date 1770320035248)
@@ -55,6 +55,7 @@
     /// <param name="agentName">Optional name of the agent that generated the response (e.g., "Morgana", "Morgana (Billing)")</param>
     /// <param name="agentCompleted">Flag indicating if the agent has completed its task (affects UI state, conversation flow)</param>
     /// <param name="originalTimestamp">Timestamp of the message when created in UI</param>
+    /// <param name="richCard">Optional rich card for structured visual presentation of complex data</param>
     /// <returns>Task representing the async send operation</returns>
     /// <remarks>
     /// <para><strong>Message Types:</strong></para>
@@ -107,7 +108,8 @@
         string? errorReason = null,
         string? agentName = null,
         bool agentCompleted = false,
-        DateTime? originalTimestamp = null);
+        DateTime? originalTimestamp = null,
+        Records.RichCard? richCard = null);
 
     /// <summary>
     /// Sends a streaming chunk to a conversation group via SignalR for progressive response rendering.
Index: ../Cauldron/Messages/SignalRMessage.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Cauldron.Messages;\n\n/// <summary>\n/// <para>\n/// SignalR message contract for \"ReceiveMessage\" event.\n/// This matches Morgana.SignalR.Messages.SignalRMessage schema.\n/// </para>\n/// <para>\n/// CONTRACT VERSION: 1.0<br/>\n/// SYNC WITH: Morgana.SignalR\n/// </para>\n/// <para>\n/// BREAKING CHANGES: Any modification to required fields or removal of fields is a breaking change.\n/// SAFE CHANGES: Adding optional fields with default values.\n/// </para>\n/// <para>\n/// ⚠\uFE0F IMPORTANT: This DTO is duplicated in Morgana (Morgana.SignalR.Messages.SignalRMessage).\n/// When making changes, update both versions and ensure backward compatibility.\n/// Test serialization/deserialization compatibility with integration tests.\n/// </para>\n/// </summary>\n/// <remarks>\n/// <para><strong>Contract Sync Policy:</strong></para>\n/// <list type=\"bullet\">\n/// <item>Required fields must match exactly between backend and frontend</item>\n/// <item>Optional fields can be added without breaking compatibility (use default values)</item>\n/// <item>Field removal or type changes are BREAKING and require coordinated deployment</item>\n/// </list>\n/// <para><strong>Wire Format (JSON):</strong></para>\n/// <code>\n/// {\n///   \"conversationId\": \"abc123\",\n///   \"text\": \"Hello! How can I help you today?\",\n///   \"timestamp\": \"2025-01-23T10:30:00Z\",\n///   \"messageType\": \"assistant\",\n///   \"quickReplies\": [\n///     { \"id\": \"billing\", \"label\": \"\uD83D\uDCB3 Billing\", \"value\": \"Show invoices\", \"termination\": false }\n///   ],\n///   \"errorReason\": null,\n///   \"agentName\": \"Morgana (Billing)\",\n///   \"agentCompleted\": true\n/// }\n/// </code>\n/// </remarks>\npublic sealed class SignalRMessage\n{\n    /// <summary>\n    /// Unique identifier of the conversation this message belongs to.\n    /// </summary>\n    public string ConversationId { get; set; } = string.Empty;\n\n    /// <summary>\n    /// Message text to display to the user.\n    /// </summary>\n    public string Text { get; set; } = string.Empty;\n\n    /// <summary>\n    /// UTC timestamp when this message was generated by the backend.\n    /// </summary>\n    public DateTime Timestamp { get; set; }\n\n    /// <summary>\n    /// Type of message for UI rendering and styling.\n    /// Valid values: \"assistant\", \"presentation\", \"system\", \"error\"\n    /// </summary>\n    public string MessageType { get; set; } = \"assistant\";\n\n    /// <summary>\n    /// Optional list of quick reply buttons for user interaction.\n    /// References the existing QuickReply model which is a stable contract from the LLM.\n    /// </summary>\n    public List<QuickReply>? QuickReplies { get; set; }\n\n    /// <summary>\n    /// Optional error reason code when MessageType is \"error\".\n    /// </summary>\n    public string? ErrorReason { get; set; }\n\n    /// <summary>\n    /// Name of the agent that generated this message.\n    /// Examples: \"Morgana\", \"Morgana (Billing)\", \"Morgana (Technical Support)\"\n    /// </summary>\n    public string AgentName { get; set; } = \"Morgana\";\n\n    /// <summary>\n    /// Indicates whether this specialized agent has completed its task.\n    /// When true, UI should return to default Morgana state.\n    /// </summary>\n    public bool AgentCompleted { get; set; }\n\n    /// <summary>\n    /// Duration of the eventual fading message which will be generated\n    /// by this SignalR message (depending on its MessageType).\n    /// </summary>\n    public int? FadingMessageDurationSeconds { get; set; } = 10;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../Cauldron/Messages/SignalRMessage.cs b/../Cauldron/Messages/SignalRMessage.cs
--- a/../Cauldron/Messages/SignalRMessage.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/../Cauldron/Messages/SignalRMessage.cs	(date 1770321879611)
@@ -71,6 +71,19 @@
     /// </summary>
     public List<QuickReply>? QuickReplies { get; set; }
 
+    /// <summary>
+    /// Optional rich card for structured visual presentation.
+    /// When present, renders structured data components instead of plain text formatting.
+    /// </summary>
+    /// <remarks>
+    /// <para>Rich cards are generated by agents via the SetRichCard tool when presenting
+    /// complex structured information like invoices, profiles, reports, or comparisons.</para>
+    /// <para>The card contains a title, optional subtitle, and an array of visual components
+    /// (key-value pairs, lists, sections, badges, etc.) that Cauldron renders using specialized
+    /// Razor components.</para>
+    /// </remarks>
+    public RichCard? RichCard { get; set; }
+
     /// <summary>
     /// Optional error reason code when MessageType is "error".
     /// </summary>
Index: Morgana.Framework/morgana.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"Prompts\": [\n    {\n      \"ID\": \"Morgana\",\n      \"Type\": \"SYSTEM\",\n      \"SubType\": \"AGENT\",\n      \"Target\": \"[TARGET] You are a digital assistant. You listen to user requests, guide them to obtain information and solve doubts or problems through the support scenarios you can handle.\",\n      \"Instructions\": \"[INSTRUCTIONS] Ongoing conversation between you (assistant) and user. Maintain consistency with the history and with the critical rules.\",\n      \"Personality\": \"[PERSONALITY] Your name is Morgana: you are a 'good witch' who uses her magic tomes to formulate potions and spells that help the user with their expressed needs.\\nYou veil a hint of magic and mystery in your manner.\\nYou are a 'young' witch, aware that you might make some mistakes and that you are still learning from your older sisters.\",\n      \"Formatting\": \"[FORMATTING] Prefer clean and readable text formatting. Use simple line breaks and natural structure instead of markdown. Prefer clean lists over heavy formatting. NEVER use ASCII art separators like ===, ---, ~~~, *** or similar characters for visual separation - these break the UI layout. Use simple blank lines or bullet points for structure instead. NEVER terminate with glyphs or emoticons.\",\n      \"Language\": \"en-US\",\n      \"Version\": \"1\",\n      \"AdditionalProperties\": [\n        {\n          \"GlobalPolicies\": [\n            {\n              \"Name\": \"ContextHandling\",\n              \"Description\": \"CRITICAL RULE ABOUT CONTEXT - Before asking for ANY information from the user, you MUST ALWAYS attempt to retrieve it from context using the GetContextVariable tool. If the GetContextVariable tool returns a valid value, USE IT without asking the user. Ask the user ONLY if the GetContextVariable tool indicates that the information is missing.\\n\\nRegarding the SetContextVariable tool, follow EXACTLY the instructions provided in the description of each tool parameter: some parameters explicitly require being saved in context, others don't.\\nNEVER mention to users the existence of 'context': neither directly nor with workarounds or metaphors, they must NEVER know technical details of your operation!\",\n              \"Type\": \"Critical\",\n              \"Priority\": 0\n            },\n            {\n              \"Name\": \"InteractiveToken\",\n              \"Description\": \"CRITICAL RULE ABOUT INTERACTION TOKEN - When you need information from the user, OR you give him a courtesy message inviting to stay, OR you suggest him a list of steps or choices, you MUST end the response with the special token #INT#. For example: 'To help you with this request, could you tell me your identification code? #INT#', 'Tell me if there is anything else I can do for you. #INT#'. Otherwise complete the request and DO NOT insert the #INT# token. In any case, NEVER terminate with glyphs or emoticons. CRITICAL CLARIFICATION: Any phrase that invites, asks, or suggests the user can continue the conversation (like \\\"Let me know!\\\", \\\"Would you like...\\\", \\\"Feel free to ask\\\", \\\"I'm here if you need\\\") REQUIRES #INT#. If you're genuinely ending without expecting further input, do NOT use such inviting phrases: check if the ConversationClosure quick replies are eligible for emission.\",\n              \"Type\": \"Critical\",\n              \"Priority\": 1\n            },\n            {\n              \"Name\": \"ConversationClosure\",\n              \"Description\": \"CRITICAL RULE ABOUT CONVERSATION CLOSURE - When you complete a user request and are about to end your response WITHOUT the #INT# token, you MUST call the SetQuickReplies tool with EXACTLY these two options to let the user control the conversation flow:\\n[\\n  {\\n    \\\"id\\\": \\\"continue_agent\\\",\\n    \\\"label\\\": \\\"\uD83D\uDD2E I still need you\\\",\\n    \\\"value\\\": \\\"I have another question for you\\\"\\n  },\\n  {\\n    \\\"id\\\": \\\"exit_agent\\\",\\n    \\\"label\\\": \\\"✨ We're done, thanks\\\",\\n    \\\"value\\\": \\\"We're done, thanks\\\",\\n    \\\"termination\\\": true\\n  }\\n]\\nThis gives the user explicit control over whether to continue with the current agent or return to the main assistant. Call SetQuickReplies tool BEFORE providing your final response. EXCEPTION: If the user's message clearly indicates they want to END the conversation (expressions of completion, goodbye, thanks for finishing, declining further help, desire to return to Morgana, etc.), do NOT emit these quick replies again - simply acknowledge their goodbye and end the conversation.\",\n              \"Type\": \"Critical\",\n              \"Priority\": 2\n            },\n            {\n              \"Name\": \"ToolUsage\",\n              \"Description\": \"CRITICAL RULE ABOUT TOOL USAGE - Always call the appropriate tools when the user makes a request, even if you have called the same tool earlier in the conversation. Never rely solely on conversation history for data that should be fetched fresh from tools. Follow this simple pattern: it is better \\\"fresh data\\\" from tools over \\\"cached answers\\\" from history!\",\n              \"Type\": \"Critical\",\n              \"Priority\": 3\n            },\n            {\n              \"Name\": \"ToolGrounding\",\n              \"Description\": \"CRITICAL RULE ABOUT TOOL GROUNDING - You can ONLY offer actions that you can EXECUTE through your declared tools. NEVER create quick replies for capabilities you cannot perform. Even if your Target description mentions features conceptually, you can ONLY create quick replies for tools that are actually implemented and callable. If mentioned capabilities lack corresponding tools, explain this limitation to the user instead of creating fake quick replies. Before creating ANY quick reply for a specific action, verify that you have an actual tool to execute it. IMPORTANT: Do not create quick replies based on suggestions or hints in tool output text: that is just for user awareness, not implicit permission to create inferred action buttons.\",\n              \"Type\": \"Critical\",\n              \"Priority\": 4\n            },\n            {\n              \"Name\": \"QuickReplyEscapeOptions\",\n              \"Description\": \"CRITICAL RULE ABOUT QUICK REPLY ESCAPE OPTIONS - When you call SetQuickReplies tool to present options derived from tool results (invoices, guides, contract clauses, etc.), you MUST ALWAYS include EXACTLY these two additional escape options at the END of the quick replies array:\\n[\\n  {\\n    \\\"id\\\": \\\"continue_agent\\\",\\n    \\\"label\\\": \\\"\uD83D\uDCAC Ask me something else\\\",\\n    \\\"value\\\": \\\"I want to ask you something else\\\"\\n  },\\n  {\\n    \\\"id\\\": \\\"exit_agent\\\",\\n    \\\"label\\\": \\\"✨ We're done, thanks\\\",\\n    \\\"value\\\": \\\"We're done, thanks\\\",\\n    \\\"termination\\\": true\\n  }\\n]\\nThese options give users the freedom to switch context or exit, preventing them from being trapped in a list of predefined choices. DO NOT add these escape options to the ConversationClosure quick replies (which already serve as exit mechanism).\",\n              \"Type\": \"Critical\",\n              \"Priority\": 5\n            },\n            {\n              \"Name\": \"ToolParameterContextGuidance\",\n              \"Description\": \"BEFORE INVOKING THIS TOOL: call the GetContextVariable tool to check if the information is already available. Ask the user ONLY if the GetContextVariable tool returns that the information is missing.\",\n              \"Type\": \"Operational\",\n              \"Priority\": 0\n            },\n            {\n              \"Name\": \"ToolParameterRequestGuidance\",\n              \"Description\": \"Use the value directly from the user's request, without going through the GetContextVariable tool.\",\n              \"Type\": \"Operational\",\n              \"Priority\": 1\n            }\n          ],\n          \"ErrorAnswers\": [\n            {\n              \"Name\": \"GenericError\",\n              \"Content\": \"I'm sorry, I had a problem with an ingredient during the potion preparation and I couldn't complete it :(\"\n            },\n            {\n              \"Name\": \"LLMServiceError\",\n              \"Content\": \"I'm sorry, the magic sphere refused to cooperate and didn't want to receive my spell: ((llm_error))\"\n            }\n          ]\n        },\n        {\n          \"Tools\": [\n            {\n              \"Name\": \"GetContextVariable\",\n              \"Description\": \"IMPORTANT: ALWAYS use this tool BEFORE asking for any information from the user. This tool retrieves information that might already be available in the agent's context (for example userId, already provided previously). If this tool returns a value, USE IT. Ask the user ONLY if this tool indicates that the information is missing.\",\n              \"Parameters\": [\n                {\n                  \"Name\": \"variableName\",\n                  \"Description\": \"The name of the variable for which you are requesting read access to the agent's context (for example: userId)\",\n                  \"Required\": true\n                }\n              ]\n            },\n            {\n              \"Name\": \"SetContextVariable\",\n              \"Description\": \"This tool updates the agent's context by inserting the necessary information for continuing the request\",\n              \"Parameters\": [\n                {\n                  \"Name\": \"variableName\",\n                  \"Description\": \"The name of the variable for which you are requesting write access to the agent's context (for example: 'userId')\",\n                  \"Required\": true\n                },\n                {\n                  \"Name\": \"variableValue\",\n                  \"Description\": \"The value of the variable for which you are requesting write access to the agent's context (for example: 'P994E')\",\n                  \"Required\": true\n                }\n              ]\n            },\n            {\n              \"Name\": \"SetQuickReplies\",\n              \"Description\": \"When you present multiple options to the user or ask questions with specific predefined choices (e.g., selecting from a list of guides, invoices, or simple yes/no questions), call the SetQuickReplies tool to create interactive buttons for the user. The tool accepts a JSON array where each quick reply has 3 fields: 'id' (unique identifier), 'label' (display text with emoji for visual appeal, e.g., '\uD83D\uDD34 No Internet Connection'), and 'value' (the complete message that will be sent when clicked, e.g., 'Show me the no-internet assistance guide'). CRITICAL: When using quick replies, your TEXT response should be a brief contextual introduction WITHOUT listing the options themselves - the buttons will show the options visually. For example, instead of listing '1. Invoice A, 2. Invoice B, 3. Invoice C' in your text, write 'I found 3 recent invoices for you. Select one below to view details.' GUIDELINES: Use clear action-oriented labels with emoji, make values natural user messages. DO NOT use quick replies for open-ended questions requiring free-form input. Call SetQuickReplies tool BEFORE providing your text response to the user - the buttons will appear below your message. Also use this tool when ending a conversation (without #INT# token) to provide conversation control quick replies as specified in the ConversationClosure policy. CRITICAL: You can ONLY create quick replies for: (1) Options explicitly derived from tool results you have obtained, (2) Yes/No or predefined choices you are asking about, (3) The two mandatory conversation closure buttons specified in ConversationClosure policy. NEVER invent quick replies for capabilities or actions not available in your declared tools.\",\n              \"Parameters\": [\n                {\n                  \"Name\": \"quickReplies\",\n                  \"Description\": \"JSON string containing an array of quick reply button definitions. Each button must have three fields: 'id' (unique identifier, like for example 'no-internet' or 'invoice-001'), 'label' (display text with emoji for visual appeal, e.g., '\uD83D\uDD34 No Internet Connection' or '\uD83D\uDCC4 Invoice INV-001'), 'value' (the complete natural message that will be sent when the user clicks, e.g., 'Show me the no-internet assistance guide' or 'Show details for invoice INV-001'). Format: [{\\\"id\\\":\\\"option1\\\",\\\"label\\\":\\\"\uD83D\uDD27 Option 1\\\",\\\"value\\\":\\\"User message for option 1\\\"},{\\\"id\\\":\\\"option2\\\",\\\"label\\\":\\\"\uD83D\uDCD6 Option 2\\\",\\\"value\\\":\\\"User message for option 2\\\"}]. Use clear action-oriented labels. Make values natural user messages.\",\n                  \"Required\": true,\n                  \"Scope\": \"context\",\n                  \"Shared\": false\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"ID\": \"Presentation\",\n      \"Type\": \"SYSTEM\",\n      \"SubType\": \"PRESENTATION\",\n      \"Target\": \"[TARGET] You are Morgana, the digital assistant who is about to introduce herself to the user for the first time. You must explain who you are and what you can do, maintaining your magical and welcoming tone.\",\n      \"Instructions\": \"[INSTRUCTIONS AND FORMATTING] Generate an introduction message in JSON format with this EXACT structure (no markdown, no preamble):\\n{\\n  \\\"message\\\": \\\"Your introduction message (2-4 sentences)\\\",\\n  \\\"quickReplies\\\": [\\n    {\\n      \\\"id\\\": \\\"intent_name\\\",\\n      \\\"label\\\": \\\"Emoji + User-friendly label\\\",\\n      \\\"value\\\": \\\"Phrase the user would say to activate this intent\\\"\\n    }\\n  ]\\n}\\n\\nThe available intents are:\\n((intents))\\n\\nInstructions:\\n- The message must reflect your personality (good witch, slightly mysterious)\\n- Each quickReply must have an appropriate emoji and a clear label\\n- The 'value' must be a natural phrase the user would say\\n- Order the quick replies by relevance/frequency of use\\n- DO NOT include the 'other' intent in the quick replies\",\n      \"Language\": \"en-US\",\n      \"Version\": \"1\",\n      \"AdditionalProperties\": [\n        {\n          \"FallbackMessage\": \"✨ Welcome! I am Morgana, your magical digital assistant.\\n\\nTell me traveler, what brings you to me?\"\n        },\n        {\n          \"NoAgentsMessage\": \"✨ Welcome! I am Morgana, your magical digital assistant.\\n\\nAt the moment I don't have configured spells to help you, but my creator can add them soon!\"\n        }\n      ]\n    },\n    {\n      \"ID\": \"Guard\",\n      \"Type\": \"SYSTEM\",\n      \"SubType\": \"ACTOR\",\n      \"Target\": \"[TARGET] You are a language guard. Check if the user's message falls into these categories: spam, phishing, violence, profanity, insults, offensive content\",\n      \"Instructions\": \"[INSTRUCTIONS AND FORMATTING] Respond ONLY with JSON in this exact format (no markdown, no preamble): {\\\"compliant\\\": true/false, \\\"violation\\\": \\\"reason or null\\\"}\",\n      \"Language\": \"en-US\",\n      \"Version\": \"1\",\n      \"AdditionalProperties\": [\n        {\n          \"ProfanityTerms\": [ \"stupid\", \"fuck\", \"idiot\", \"incompetent\", \"inept\", \"dumb\", \"you're useless\" ]\n        },\n        {\n          \"GuardAnswer\": \"((violation)). I ask you to maintain a respectful tone: I'm here to help you.\"\n        },\n        {\n          \"LanguageViolation\": \"Inappropriate language.\"\n        }\n      ]\n    },\n    {\n      \"ID\": \"Classifier\",\n      \"Type\": \"SYSTEM\",\n      \"SubType\": \"ACTOR\",\n      \"Target\": \"[TARGET] You are a request classifier. Classify each user request by determining its intent, i.e. the underlying topic. The intents we know how to handle and their application are these: ((formattedIntents))\",\n      \"Instructions\": \"[INSTRUCTIONS AND FORMATTING] Respond ONLY with JSON in this exact format (no markdown, no preamble): {\\\"intent\\\": \\\"the intent identified among all configured ones\\\", \\\"confidence\\\": number between 0 and 1 expressing the confidence level of the classification}\",\n      \"Language\": \"en-US\",\n      \"Version\": \"1\",\n      \"AdditionalProperties\": [\n        { \"MissingClassificationError\": \"I'm sorry, I don't have enough elements to search in the spell book for the most appropriate one for your request :(\" },\n        { \"UnrecognizedIntentError\": \"I'm sorry, I'm a young witch and I don't know yet the magic formula to help you with this specific request :(\" }\n      ]\n    }\n  ]\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/morgana.json b/Morgana.Framework/morgana.json
--- a/Morgana.Framework/morgana.json	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/morgana.json	(date 1770321733712)
@@ -60,6 +60,12 @@
               "Description": "Use the value directly from the user's request, without going through the GetContextVariable tool.",
               "Type": "Operational",
               "Priority": 1
+            },
+            {
+              "Name": "RichCardUsageGuidance",
+              "Description": "Use SetRichCard when presenting structured data (invoices, profiles, reports, comparisons) that benefits from visual organization. Avoid for simple Q&A or single data points. Cards should be focused (10-20 components) and well-organized with sections for logical grouping. Always accompany cards with brief contextual text.",
+              "Type": "Operational",
+              "Priority": 2
             }
           ],
           "ErrorAnswers": [
@@ -112,6 +118,20 @@
                   "Required": true,
                   "Scope": "context",
                   "Shared": false
+                }
+              ]
+            },
+            {
+              "Name": "SetRichCard",
+              "Description": "Render structured information as a visual card instead of plain text. Use for invoices, profiles, reports, comparisons, or any data benefiting from visual hierarchy. Components: text_block (narrative text with style: normal|bold|muted|small), key_value (label-value pairs with optional emphasize: true|false), divider (visual separator), list (items array with style: bullet|numbered|plain), section (nestable grouping with title/subtitle/components, max depth: 3), grid (columns: 2-4 with key-value items), badge (text with variant: success|warning|error|info|neutral). Keep cards focused (10-20 components recommended). Maximum 50 components total, maximum nesting depth: 3 levels.",
+              "Parameters": [
+                {
+                  "Name": "richCardJson",
+                  "Type": "string",
+                  "Description": "JSON string containing rich card structure with required 'title' (string), optional 'subtitle' (string), and required 'components' (array of component objects). Each component must have a 'type' field matching one of the available component types. Example structure: {\"title\":\"Invoice #001\",\"subtitle\":\"Issued 15/01/2024\",\"components\":[{\"type\":\"key_value\",\"key\":\"Customer\",\"value\":\"Acme Corp\"},{\"type\":\"divider\"},{\"type\":\"badge\",\"text\":\"Paid\",\"variant\":\"success\"}]}",
+                  "Required": true,
+                  "Scope": "context",
+                  "Shared": false
                 }
               ]
             }
Index: Morgana.SignalR/Services/SignalRBridgeService.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Microsoft.AspNetCore.SignalR;\nusing Morgana.Framework.Interfaces;\nusing Morgana.SignalR.Hubs;\nusing Morgana.SignalR.Messages;\nusing static Morgana.Framework.Records;\n\nnamespace Morgana.SignalR.Services;\n\n/// <summary>\n/// Implementation of ISignalRBridgeService that bridges the actor system with SignalR for real-time client communication.\n/// Handles message formatting and delivery to SignalR conversation groups.\n/// </summary>\n/// <remarks>\n/// <para><strong>Architecture Role:</strong></para>\n/// <para>This service is injected into actors (particularly ConversationManagerActor) to enable them to send\n/// messages to clients without direct coupling to SignalR infrastructure.</para>\n/// <para><strong>Message Protocol:</strong></para>\n/// <para>All messages sent via SignalR use the \"ReceiveMessage\" event with a structured JSON payload containing:\n/// conversationId, text, timestamp, messageType, quickReplies, errorReason, agentName, agentCompleted</para>\n/// <para><strong>Group-based Routing:</strong></para>\n/// <para>Messages are sent to SignalR groups named by conversation ID. All clients in a group receive the message,\n/// enabling multi-user scenarios (monitoring, collaboration, customer + agent viewing the same conversation).</para>\n/// </remarks>\npublic class SignalRBridgeService : ISignalRBridgeService\n{\n    private readonly IHubContext<ConversationHub> hubContext;\n    private readonly ILogger logger;\n\n    /// <summary>\n    /// Initializes a new instance of the SignalRBridgeService.\n    /// </summary>\n    /// <param name=\"hubContext\">SignalR hub context for sending messages to clients</param>\n    /// <param name=\"logger\">Logger instance for message delivery diagnostics</param>\n    public SignalRBridgeService(IHubContext<ConversationHub> hubContext, ILogger logger)\n    {\n        this.hubContext = hubContext;\n        this.logger = logger;\n    }\n\n    /// <summary>\n    /// Sends a simple text message to a conversation group via SignalR.\n    /// Delegates to SendStructuredMessageAsync with default parameters.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation (SignalR group name)</param>\n    /// <param name=\"text\">Message text to send to clients</param>\n    /// <param name=\"errorReason\">Optional error reason code for error messages</param>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// This is a convenience method that wraps SendStructuredMessageAsync with:\n    /// - messageType: \"assistant\"\n    /// - agentName: \"Morgana\"\n    /// - agentCompleted: false\n    /// - quickReplies: null\n    /// </remarks>\n    public async Task SendMessageToConversationAsync(string conversationId, string text, string? errorReason = null)\n    {\n        await SendStructuredMessageAsync(conversationId, text, \"assistant\", null, errorReason, \"Morgana\", false);\n    }\n\n    /// <summary>\n    /// Sends a structured message with full metadata to a conversation group via SignalR.\n    /// Formats the message according to the client protocol and delivers to all clients in the conversation group.\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation (SignalR group name)</param>\n    /// <param name=\"text\">Message text to send to clients</param>\n    /// <param name=\"messageType\">Type of message for client-side rendering (\"assistant\", \"presentation\", \"system\", \"error\")</param>\n    /// <param name=\"quickReplies\">Optional list of quick reply buttons for user interaction</param>\n    /// <param name=\"errorReason\">Optional error reason code for error messages</param>\n    /// <param name=\"agentName\">Optional name of the agent that generated the response</param>\n    /// <param name=\"agentCompleted\">Flag indicating if the agent has completed its task</param>\n    /// <param name=\"originalTimestamp\">Timestamp of the message when create at UI level</param>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// <para><strong>Message Structure:</strong></para>\n    /// <para>Creates a StructuredMessage and sends it to the SignalR group with this JSON format:</para>\n    /// <code>\n    /// {\n    ///   \"conversationId\": \"conv-123\",\n    ///   \"text\": \"Message content here\",\n    ///   \"timestamp\": \"2024-01-05T10:30:00Z\",\n    ///   \"messageType\": \"assistant\",\n    ///   \"quickReplies\": [\n    ///     { \"id\": \"billing\", \"label\": \"\uD83D\uDCC4 View Invoices\", \"value\": \"Show my invoices\" }\n    ///   ],\n    ///   \"errorReason\": null,\n    ///   \"agentName\": \"Morgana (Billing)\",\n    ///   \"agentCompleted\": true\n    /// }\n    /// </code>\n    /// <para><strong>Client-side Handler:</strong></para>\n    /// <para>Clients listen for the \"ReceiveMessage\" event:</para>\n    /// <code>\n    /// connection.on(\"ReceiveMessage\", (message) => {\n    ///   console.log(`${message.agentName}: ${message.text}`);\n    ///   if (message.agentCompleted) {\n    ///     // Agent finished, return conversation to idle state\n    ///   }\n    ///   if (message.quickReplies) {\n    ///     // Render quick reply buttons\n    ///   }\n    /// });\n    /// </code>\n    /// <para><strong>Logging:</strong></para>\n    /// <para>Logs message type, conversation ID, agent name, and completion status for diagnostics.</para>\n    /// </remarks>\n    public async Task SendStructuredMessageAsync(\n        string conversationId,\n        string text,\n        string messageType,\n        List<QuickReply>? quickReplies = null,\n        string? errorReason = null,\n        string? agentName = null,\n        bool agentCompleted = false,\n        DateTime? originalTimestamp = null)\n    {\n        logger.LogInformation($\"Sending {messageType} message to conversation {conversationId} via SignalR (agent: {agentName ?? \"Morgana\"}, completed: {agentCompleted})\");\n\n        // Create strongly-typed DTO with contract mapping\n        SignalRMessage message = new SignalRMessage\n        {\n            ConversationId = conversationId,\n            Text = text,\n            Timestamp = originalTimestamp ?? DateTime.UtcNow,\n            MessageType = messageType,\n            QuickReplies = quickReplies,\n            ErrorReason = errorReason,\n            AgentName = agentName ?? \"Morgana\",\n            AgentCompleted = agentCompleted\n        };\n\n        // Send strongly-typed DTO (SignalR serializes to JSON automatically)\n        await hubContext.Clients.Group(conversationId)\n            .SendAsync(\"ReceiveMessage\", message);\n    }\n\n    /// <summary>\n    /// Sends a streaming chunk to a conversation group via SignalR for progressive response rendering.\n    /// Optimized for high-frequency streaming with minimal overhead (no logging, fire-and-forget).\n    /// </summary>\n    /// <param name=\"conversationId\">Unique identifier of the conversation (SignalR group name)</param>\n    /// <param name=\"chunkText\">Partial response text to append to the current message</param>\n    /// <returns>Task representing the async send operation</returns>\n    /// <remarks>\n    /// <para><strong>Streaming Protocol:</strong></para>\n    /// <para>Sends chunks via \"ReceiveStreamChunk\" SignalR event with minimal payload:</para>\n    /// <code>\n    /// {\n    ///   \"text\": \"chunk content here\"\n    /// }\n    /// </code>\n    /// <para><strong>No Logging:</strong></para>\n    /// <para>Intentionally omits logging to avoid spamming logs with hundreds of partial text fragments.\n    /// Only errors are logged if chunk delivery fails.</para>\n    /// <para><strong>Client Expectations:</strong></para>\n    /// <para>Clients should buffer chunks and append them to the current message being displayed.\n    /// The final complete message arrives via the standard \"ReceiveMessage\" event with full metadata.</para>\n    /// </remarks>\n    public async Task SendStreamChunkAsync(string conversationId, string chunkText)\n    {\n        try\n        {\n            // Send chunk with minimal payload (just the text)\n            await hubContext.Clients.Group(conversationId)\n                .SendAsync(\"ReceiveStreamChunk\", chunkText);\n        }\n        catch (Exception ex)\n        {\n            // Log errors but don't propagate - continue streaming\n            logger.LogError(ex, $\"Failed to send stream chunk to conversation {conversationId}\");\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.SignalR/Services/SignalRBridgeService.cs b/Morgana.SignalR/Services/SignalRBridgeService.cs
--- a/Morgana.SignalR/Services/SignalRBridgeService.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.SignalR/Services/SignalRBridgeService.cs	(date 1770320205010)
@@ -1,4 +1,5 @@
 using Microsoft.AspNetCore.SignalR;
+using Morgana.Framework;
 using Morgana.Framework.Interfaces;
 using Morgana.SignalR.Hubs;
 using Morgana.SignalR.Messages;
@@ -69,40 +70,8 @@
     /// <param name="agentName">Optional name of the agent that generated the response</param>
     /// <param name="agentCompleted">Flag indicating if the agent has completed its task</param>
     /// <param name="originalTimestamp">Timestamp of the message when create at UI level</param>
+    /// <param name="richCard">Optional rich card for presentation of structured data</param>
     /// <returns>Task representing the async send operation</returns>
-    /// <remarks>
-    /// <para><strong>Message Structure:</strong></para>
-    /// <para>Creates a StructuredMessage and sends it to the SignalR group with this JSON format:</para>
-    /// <code>
-    /// {
-    ///   "conversationId": "conv-123",
-    ///   "text": "Message content here",
-    ///   "timestamp": "2024-01-05T10:30:00Z",
-    ///   "messageType": "assistant",
-    ///   "quickReplies": [
-    ///     { "id": "billing", "label": "📄 View Invoices", "value": "Show my invoices" }
-    ///   ],
-    ///   "errorReason": null,
-    ///   "agentName": "Morgana (Billing)",
-    ///   "agentCompleted": true
-    /// }
-    /// </code>
-    /// <para><strong>Client-side Handler:</strong></para>
-    /// <para>Clients listen for the "ReceiveMessage" event:</para>
-    /// <code>
-    /// connection.on("ReceiveMessage", (message) => {
-    ///   console.log(`${message.agentName}: ${message.text}`);
-    ///   if (message.agentCompleted) {
-    ///     // Agent finished, return conversation to idle state
-    ///   }
-    ///   if (message.quickReplies) {
-    ///     // Render quick reply buttons
-    ///   }
-    /// });
-    /// </code>
-    /// <para><strong>Logging:</strong></para>
-    /// <para>Logs message type, conversation ID, agent name, and completion status for diagnostics.</para>
-    /// </remarks>
     public async Task SendStructuredMessageAsync(
         string conversationId,
         string text,
@@ -111,9 +80,13 @@
         string? errorReason = null,
         string? agentName = null,
         bool agentCompleted = false,
-        DateTime? originalTimestamp = null)
+        DateTime? originalTimestamp = null,
+        RichCard? richCard = null)
     {
-        logger.LogInformation($"Sending {messageType} message to conversation {conversationId} via SignalR (agent: {agentName ?? "Morgana"}, completed: {agentCompleted})");
+        logger.LogInformation(
+            $"Sending structured message to conversation {conversationId}: " +
+            $"type={messageType}, agent={agentName ?? "Morgana"}, completed={agentCompleted}, " +
+            $"#quickReplies={quickReplies?.Count ?? 0}, hasRichCard={richCard != null}");
 
         // Create strongly-typed DTO with contract mapping
         SignalRMessage message = new SignalRMessage
@@ -125,7 +98,8 @@
             QuickReplies = quickReplies,
             ErrorReason = errorReason,
             AgentName = agentName ?? "Morgana",
-            AgentCompleted = agentCompleted
+            AgentCompleted = agentCompleted,
+            RichCard = richCard
         };
 
         // Send strongly-typed DTO (SignalR serializes to JSON automatically)
Index: Morgana.Framework/Records.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Akka.Actor;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nnamespace Morgana.Framework;\n\n/// <summary>\n/// Central repository of immutable record types (DTOs) used throughout the Morgana framework.\n/// Records are organized by functional area: agent communication, classification, prompts, tools and presentation.\n/// </summary>\n/// <remarks>\n/// <para><strong>Design Philosophy:</strong></para>\n/// <list type=\"bullet\">\n/// <item>Immutable records for thread-safety in actor message passing</item>\n/// <item>Explicit types prevent message routing errors in actor system</item>\n/// <item>JSON serialization support for LLM interactions and configuration loading</item>\n/// <item>Context wrappers preserve sender references across async operations (PipeTo pattern)</item>\n/// </list>\n/// </remarks>\npublic static class Records\n{\n    // ==========================================================================\n    // CONVERSATION LIFECYCLE MESSAGES\n    // ==========================================================================\n\n    /// <summary>\n    /// Final response message sent from ConversationSupervisorActor to ConversationManagerActor after processing a user message.\n    /// Contains the AI response, metadata, agent information, and optional quick reply buttons.\n    /// </summary>\n    /// <param name=\"Response\">AI-generated response text</param>\n    /// <param name=\"Classification\">Intent classification result (e.g., \"billing\", \"contract\")</param>\n    /// <param name=\"Metadata\">Additional metadata from classification (confidence, error codes, etc.)</param>\n    /// <param name=\"AgentName\">Name of the agent that generated the response (e.g., \"Morgana\", \"Morgana (Billing)\")</param>\n    /// <param name=\"AgentCompleted\">Flag indicating if the agent completed its multi-turn interaction</param>\n    /// <param name=\"QuickReplies\">Optional list of quick reply buttons for guided user interactions</param>\n    /// <param name=\"OriginalTimestamp\">Optional timestamp of the message when created at UI level</param>\n    public record ConversationResponse(\n        string Response,\n        string? Classification,\n        Dictionary<string, string>? Metadata,\n        string? AgentName = null,\n        bool AgentCompleted = false,\n        List<QuickReply>? QuickReplies = null,\n        DateTime? OriginalTimestamp = null);\n\n    /// <summary>\n    /// Request to create a new conversation and initialize the actor hierarchy.\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier for the new conversation</param>\n    /// <param name=\"IsRestore\">Flag indicating that the conversation is being created or restored</param>\n    public record CreateConversation(\n        string ConversationId,\n        bool IsRestore);\n\n    /// <summary>\n    /// Request to terminate a conversation and stop all associated actors.\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier of the conversation to terminate</param>\n    public record TerminateConversation(\n        string ConversationId);\n\n    // ==========================================================================\n    // CONVERSATION PERSISTENCE\n    // ==========================================================================\n\n    /// <summary>\n    /// Configuration options for conversation persistence.\n    /// </summary>\n    /// <remarks>\n    /// <para><strong>Configuration Example:</strong></para>\n    /// <code>\n    /// {\n    ///   \"Morgana\": {\n    ///     \"ConversationPersistence\": {\n    ///       \"StoragePath\": \"C:/MorganaData\",\n    ///       \"EncryptionKey\": \"your-base64-encoded-256-bit-key\"\n    ///     }\n    ///   }\n    /// }\n    /// </code>\n    /// <para><strong>Generating an Encryption Key:</strong></para>\n    /// <code>\n    /// // C# code to generate a secure 256-bit key\n    /// using System.Security.Cryptography;\n    /// byte[] key = new byte[32];\n    /// RandomNumberGenerator.Fill(key);\n    /// string base64Key = Convert.ToBase64String(key);\n    /// Console.WriteLine(base64Key);\n    /// </code>\n    /// </remarks>\n    public record ConversationPersistenceOptions\n    {\n        /// <summary>\n        /// Directory path where conversation files will be stored.\n        /// Directory will be created if it doesn't exist.\n        /// </summary>\n        /// <example>C:/MorganaData</example>\n        public string StoragePath { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Base64-encoded 256-bit AES encryption key for conversation data.<br/>\n        /// CRITICAL: Keep this key secure and never commit it to source control.\n        /// </summary>\n        /// <example>3q2+7w8e9r0t1y2u3i4o5p6a7s8d9f0g1h2j3k4l5z6x7c8v9b0n1m2==</example>\n        public string EncryptionKey { get; set; } = string.Empty;\n    }\n\n    /// <summary>\n    /// Request to restore active agent state when resuming a conversation from persistence.\n    /// Sent to ConversationSupervisor after conversation resume to set activeAgent and activeAgentIntent.\n    /// </summary>\n    /// <param name=\"AgentIntent\">Intent of the agent that was last active (e.g., \"billing\", \"contract\")</param>\n    public record RestoreActiveAgent(string AgentIntent);\n\n    /// <summary>\n    /// Request sent to RouterActor to restore/resolve an agent by intent.\n    /// Returns the agent reference if successful, or null if intent is invalid.\n    /// Router will cache the agent for future routing operations.\n    /// </summary>\n    /// <param name=\"AgentIntent\">Intent name to resolve agent for</param>\n    public record RestoreAgentRequest(string AgentIntent);\n\n    /// <summary>\n    /// Response from RouterActor containing the resolved agent reference.\n    /// Null AgentRef indicates the intent could not be resolved to a valid agent.\n    /// </summary>\n    /// <param name=\"AgentIntent\">Original intent requested</param>\n    /// <param name=\"AgentRef\">Resolved agent reference, or null if not found</param>\n    public record RestoreAgentResponse(string AgentIntent, IActorRef? AgentRef);\n\n    /// <summary>\n    /// Chat message record for UI consumption (Cauldron).\n    /// Represents a single message in the conversation history, mapped from Microsoft.Agents.AI.ChatMessage.\n    /// </summary>\n    /// <remarks>\n    /// This record is optimized for Blazor UI rendering and includes UI-specific fields like AgentName, QuickReplies, etc.\n    /// </remarks>\n    public record MorganaChatMessage\n    {\n        /// <summary>\n        /// Unique identifier of the conversation this message belongs to.\n        /// </summary>\n        public required string ConversationId { get; init; }\n\n        /// <summary>\n        /// Message text content displayed to the user.\n        /// Extracted from TextContent blocks in ChatMessage.Content.\n        /// </summary>\n        public required string Text { get; init; }\n\n        /// <summary>\n        /// Timestamp when the message was created or received.\n        /// Mapped from ChatMessage.CreatedAt.\n        /// </summary>\n        public required DateTime Timestamp { get; init; }\n\n        /// <summary>\n        /// Type of message determining styling and behavior.\n        /// Derived from ChatMessage.Role (user/assistant).\n        /// </summary>\n        public required MessageType Type { get; init; }\n\n        /// <summary>\n        /// Gets the message role for CSS styling (\"user\" or \"assistant\").\n        /// </summary>\n        public string Role => Type switch\n        {\n            MessageType.User => \"user\",\n            _ => \"assistant\"\n        };\n\n        /// <summary>\n        /// Name of the agent that generated this message.\n        /// Examples: \"User\", \"Morgana (billing)\", \"Morgana (contract)\", ...\n        /// </summary>\n        public required string AgentName { get; init; }\n\n        /// <summary>\n        /// Indicates whether the agent has completed its task.\n        /// Mapped from SQLite is_active column: true when is_active = 0, false when is_active = 1.\n        /// </summary>\n        public required bool AgentCompleted { get; init; }\n\n        /// <summary>\n        /// Optional list of quick reply buttons attached to this message.\n        /// Reconstructed from SetQuickReplies tool calls when loading conversation history.\n        /// </summary>\n        public List<QuickReply>? QuickReplies { get; init; }\n\n        /// <summary>\n        /// Optional flag indicating that this is the last message of a resumed conversation.\n        /// </summary>\n        public bool? IsLastHistoryMessage { get; init; }\n    }\n\n    /// <summary>\n    /// Enumeration of message types for styling and behavior differentiation.\n    /// </summary>\n    public enum MessageType\n    {\n        /// <summary>\n        /// Message from the user.\n        /// Displayed on the right side with user styling.\n        /// </summary>\n        User,\n\n        /// <summary>\n        /// Regular response from an agent.\n        /// Displayed on the left side with agent avatar and assistant styling.\n        /// </summary>\n        Assistant\n    }\n\n    // ==========================================================================\n    // RATE LIMITING\n    // ==========================================================================\n\n    /// <summary>\n    /// Configuration options for conversation rate limiting.\n    /// </summary>\n    /// <remarks>\n    /// <para><strong>Configuration Example:</strong></para>\n    /// <code>\n    /// {\n    ///   \"Morgana\": {\n    ///     \"RateLimiting\": {\n    ///       \"Enabled\": true,\n    ///       \"MaxMessagesPerMinute\": 5,\n    ///       \"MaxMessagesPerHour\": 30,\n    ///       \"MaxMessagesPerDay\": 100,\n    ///       \"ErrorMessagePerMinute\": \"✋ Whoa there! You're casting spells too quickly...\",\n    ///       \"ErrorMessagePerHour\": \"⏰ You've reached your hourly spell quota...\",\n    ///       \"ErrorMessagePerDay\": \"\uD83C\uDF19 You've exhausted today's magical energy...\",\n    ///       \"ErrorMessageDefault\": \"⚠\uFE0F You're sending messages too quickly...\"\n    ///     }\n    ///   }\n    /// }\n    /// </code>\n    /// </remarks>\n    public record RateLimitOptions\n    {\n        /// <summary>\n        /// Master toggle for rate limiting feature.\n        /// Set to false to disable all rate limiting (useful for development/testing).\n        /// </summary>\n        public bool Enabled { get; set; } = true;\n\n        /// <summary>\n        /// Maximum messages allowed per minute per conversation.\n        /// Prevents burst spam. Set to 0 to disable this check.\n        /// </summary>\n        /// <example>5</example>\n        public int MaxMessagesPerMinute { get; set; } = 5;\n\n        /// <summary>\n        /// Maximum messages allowed per hour per conversation.\n        /// Prevents sustained abuse. Set to 0 to disable this check.\n        /// </summary>\n        /// <example>30</example>\n        public int MaxMessagesPerHour { get; set; } = 30;\n\n        /// <summary>\n        /// Maximum messages allowed per day per conversation.\n        /// Enforces daily quotas. Set to 0 to disable this check.\n        /// </summary>\n        /// <example>100</example>\n        public int MaxMessagesPerDay { get; set; } = 100;\n\n        /// <summary>\n        /// Error message displayed when per-minute limit is exceeded.\n        /// Supports placeholders: {limit} for the actual limit value.\n        /// </summary>\n        /// <example>✋ Whoa there! You're casting spells too quickly. Please wait a moment before trying again.</example>\n        public string ErrorMessagePerMinute { get; set; } = \n            \"✋ Whoa there! You're casting spells too quickly. Please wait a moment before trying again.\";\n\n        /// <summary>\n        /// Error message displayed when per-hour limit is exceeded.\n        /// Supports placeholders: {limit} for the actual limit value.\n        /// </summary>\n        /// <example>⏰ You've reached your hourly spell quota. The magic cauldron needs time to recharge!</example>\n        public string ErrorMessagePerHour { get; set; } = \n            \"⏰ You've reached your hourly spell quota. The magic cauldron needs time to recharge!\";\n\n        /// <summary>\n        /// Error message displayed when per-day limit is exceeded.\n        /// Supports placeholders: {limit} for the actual limit value.\n        /// </summary>\n        /// <example>\uD83C\uDF19 You've exhausted today's magical energy. Return tomorrow for more spells!</example>\n        public string ErrorMessagePerDay { get; set; } = \n            \"\uD83C\uDF19 You've exhausted today's magical energy. Return tomorrow for more spells!\";\n\n        /// <summary>\n        /// Default error message for unknown/generic rate limit violations.\n        /// </summary>\n        /// <example>⚠\uFE0F You're sending messages too quickly. Please slow down.</example>\n        public string ErrorMessageDefault { get; set; } = \n            \"⚠\uFE0F You're sending messages too quickly. Please slow down.\";\n    }\n\n    /// <summary>\n    /// Result of a rate limit check operation.\n    /// </summary>\n    /// <param name=\"IsAllowed\">Whether the request is allowed to proceed</param>\n    /// <param name=\"ViolatedLimit\">Description of which limit was exceeded (null if allowed)</param>\n    /// <param name=\"RetryAfterSeconds\">Suggested wait time in seconds before retrying (null if allowed)</param>\n    public record RateLimitResult(\n        bool IsAllowed,\n        string? ViolatedLimit = null,\n        int? RetryAfterSeconds = null);\n\n    // ==========================================================================\n    // USER MESSAGE HANDLING\n    // ==========================================================================\n\n    /// <summary>\n    /// User message submitted for processing through the conversation pipeline.\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier of the conversation</param>\n    /// <param name=\"Text\">User's message text</param>\n    /// <param name=\"Timestamp\">Timestamp when the message was created</param>\n    public record UserMessage(\n        string ConversationId,\n        string Text,\n        DateTime Timestamp);\n\n    // ==========================================================================\n    // GUARD (CONTENT MODERATION) MESSAGES\n    // ==========================================================================\n\n    /// <summary>\n    /// Request for content moderation check on a user message.\n    /// Sent to GuardActor for two-level filtering (profanity + LLM policy check).\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier of the conversation</param>\n    /// <param name=\"Message\">User message to check for policy violations</param>\n    public record GuardCheckRequest(\n        string ConversationId,\n        string Message);\n\n    /// <summary>\n    /// Result of content moderation check from GuardActor.\n    /// </summary>\n    /// <param name=\"Compliant\">True if message passes policy checks, false if violation detected</param>\n    /// <param name=\"Violation\">Description of policy violation if Compliant is false</param>\n    public record GuardCheckResponse(\n        [property: JsonPropertyName(\"compliant\")] bool Compliant,\n        [property: JsonPropertyName(\"violation\")] string? Violation);\n\n    // ==========================================================================\n    // CLASSIFICATION MESSAGES\n    // ==========================================================================\n\n    /// <summary>\n    /// LLM response from ClassifierActor containing intent classification.\n    /// Deserialized from JSON returned by the LLM.\n    /// </summary>\n    /// <param name=\"Intent\">Classified intent name (e.g., \"billing\", \"contract\", \"other\")</param>\n    /// <param name=\"Confidence\">Confidence score from 0.0 to 1.0</param>\n    public record ClassificationResponse(\n        [property: JsonPropertyName(\"intent\")] string Intent,\n        [property: JsonPropertyName(\"confidence\")] double Confidence);\n\n    /// <summary>\n    /// Internal classification result used by the conversation pipeline.\n    /// Contains the classified intent and additional metadata for routing and diagnostics.\n    /// </summary>\n    /// <param name=\"Intent\">Classified intent name</param>\n    /// <param name=\"Metadata\">\n    /// Additional metadata dictionary (e.g., confidence score, error codes, classification notes)\n    /// </param>\n    public record ClassificationResult(\n        string Intent,\n        Dictionary<string, string> Metadata);\n\n    // ==========================================================================\n    // AGENT REQUEST/RESPONSE MODELS\n    // ==========================================================================\n\n    /// <summary>\n    /// Request message sent to MorganaAgent instances for processing user input.\n    /// Contains the user's message and optional classification result from ClassifierActor.\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier of the conversation</param>\n    /// <param name=\"Content\">User message text to process (null for tool-only interactions)</param>\n    /// <param name=\"Classification\">Optional intent classification result (null for follow-up messages to active agents)</param>\n    public record AgentRequest(\n        string ConversationId,\n        string? Content,\n        ClassificationResult? Classification);\n\n    /// <summary>\n    /// Response message from MorganaAgent instances after processing a request.\n    /// Indicates the agent's response text, completion status, and optional quick reply buttons.\n    /// </summary>\n    /// <param name=\"Response\">Agent's response text (may contain #INT# token for multi-turn interactions)</param>\n    /// <param name=\"IsCompleted\">\n    /// True if agent has completed its task (conversation returns to idle).\n    /// False if agent needs more user input (agent becomes active for follow-up messages).\n    /// </param>\n    /// <param name=\"QuickReplies\">\n    /// Optional list of quick reply buttons to display to the user.\n    /// Agents can provide guided choices for better UX (e.g., contract sections, invoice selection).\n    /// If null, no quick replies are shown.\n    /// </param>\n    /// <remarks>\n    /// <para><strong>Quick Reply Usage:</strong></para>\n    /// <para>Agents can emit quick replies to guide users through complex workflows:</para>\n    /// <code>\n    /// // Billing agent offering invoice options\n    /// new AgentResponse(\n    ///     \"I can help with your invoices.\",\n    ///     IsCompleted: false,\n    ///     QuickReplies: new List&lt;QuickReply&gt; {\n    ///         new(\"diag\", \"\uD83D\uDD27 Show recent invoices\", \"Show me my invoices\"),\n    ///         new(\"guide\", \"\uD83D\uDCD6 Show payment history\", \"Show me history of my payments\")\n    ///     });\n    /// </code>\n    /// <para><strong>Best Practices:</strong></para>\n    /// <list type=\"bullet\">\n    /// <item>Use clear, action-oriented labels with emoji for visual appeal</item>\n    /// <item>Set IsCompleted=false when quick replies represent continuation of workflow</item>\n    /// <item>Quick reply values should be natural user messages that trigger appropriate agent behavior</item>\n    /// </list>\n    /// </remarks>\n    public record AgentResponse(\n        string Response,\n        bool IsCompleted = true,\n        List<QuickReply>? QuickReplies = null);\n\n    /// <summary>\n    /// Response from RouterActor containing both the agent's response and a reference to the agent actor.\n    /// Used to track which agent is handling the request for multi-turn conversation management.\n    /// </summary>\n    /// <param name=\"Response\">Agent's response text</param>\n    /// <param name=\"IsCompleted\">Whether the agent has completed its task</param>\n    /// <param name=\"AgentRef\">Actor reference to the agent that generated this response</param>\n    /// <param name=\"QuickReplies\">Optional list of quick reply buttons from the agent</param>\n    public record ActiveAgentResponse(\n        string Response,\n        bool IsCompleted,\n        IActorRef AgentRef,\n        List<QuickReply>? QuickReplies = null);\n\n    /// <summary>\n    /// Represents a streaming chunk from an agent during real-time response generation.\n    /// Sent incrementally to enable progressive UI rendering.\n    /// </summary>\n    public record AgentStreamChunk(\n        string Text);\n\n    // ==========================================================================\n    // AGENT COMMUNICATION MESSAGES\n    // ==========================================================================\n\n    /// <summary>\n    /// Message sent by an agent to RouterActor to broadcast shared context variables to all other agents.\n    /// Enables cross-agent coordination by sharing information like userId across agents.\n    /// </summary>\n    /// <param name=\"SourceAgentIntent\">Intent name of the agent broadcasting the update (e.g., \"billing\")</param>\n    /// <param name=\"UpdatedValues\">Dictionary of variable names and values to broadcast</param>\n    public record BroadcastContextUpdate(\n        string SourceAgentIntent,\n        Dictionary<string, object> UpdatedValues);\n\n    /// <summary>\n    /// Message sent by RouterActor to agents to notify them of shared context updates from other agents.\n    /// Agents merge these updates into their local context using first-write-wins strategy.\n    /// </summary>\n    /// <param name=\"SourceAgentIntent\">Intent name of the agent that originated the update</param>\n    /// <param name=\"UpdatedValues\">Dictionary of variable names and values to merge</param>\n    public record ReceiveContextUpdate(\n        string SourceAgentIntent,\n        Dictionary<string, object> UpdatedValues);\n\n    // ==========================================================================\n    // HTTP REQUEST/RESPONSE MODELS\n    // ==========================================================================\n\n    /// <summary>\n    /// HTTP request model for starting a new conversation via REST API.\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier for the conversation to create</param>\n    /// <param name=\"InitialContext\">Optional initial context information (reserved for future use)</param>\n    public record StartConversationRequest(\n        string ConversationId,\n        string? InitialContext = null);\n\n    /// <summary>\n    /// HTTP request model for sending a message to a conversation via REST API.\n    /// </summary>\n    /// <param name=\"ConversationId\">Unique identifier of the target conversation</param>\n    /// <param name=\"Text\">Message text from the user</param>\n    /// <param name=\"Metadata\">Optional metadata dictionary (reserved for future use)</param>\n    public record SendMessageRequest(\n        string ConversationId,\n        string Text,\n        Dictionary<string, object>? Metadata = null\n    );\n\n    // ==========================================================================\n    // QUICK REPLY SYSTEM\n    // ==========================================================================\n\n    /// <summary>\n    /// Interactive button displayed to the user for quick action selection.\n    /// Used in presentation messages, agent responses, and JSON deserialization from LLM tool calls.\n    /// </summary>\n    /// <param name=\"Id\">Unique identifier for the quick reply (typically matches intent name or action)</param>\n    /// <param name=\"Label\">Display text shown on the button with emoji (e.g., \"\uD83D\uDCC4 View Invoices\")</param>\n    /// <param name=\"Value\">Message text sent when user clicks the button (e.g., \"Show my invoices\")</param>\n    /// <remarks>\n    /// <para><strong>Dual Purpose:</strong></para>\n    /// <para>This record serves both as a runtime model and JSON serialization DTO:</para>\n    /// <list type=\"bullet\">\n    /// <item><term>Runtime Model</term><description>Used by AgentResponse, ConversationResponse, StructuredMessage</description></item>\n    /// <item><term>JSON DTO</term><description>Deserialized from LLM SetQuickReplies tool calls</description></item>\n    /// </list>\n    /// <para><strong>JSON Format:</strong></para>\n    /// <code>\n    /// {\n    ///   \"id\": \"no-internet\",\n    ///   \"label\": \"\uD83D\uDD34 No Internet Connection\",\n    ///   \"value\": \"Show me the no-internet assistance guide\"\n    /// }\n    /// </code>\n    /// </remarks>\n    public record QuickReply(\n        [property: JsonPropertyName(\"id\")] string Id,\n        [property: JsonPropertyName(\"label\")] string Label,\n        [property: JsonPropertyName(\"value\")] string Value,\n        [property: JsonPropertyName(\"termination\")] bool? Termination=false);\n\n    /// <summary>\n    /// LLM-generated presentation response from ConversationSupervisorActor.\n    /// Contains the welcome message and quick reply buttons for user interaction.\n    /// Deserialized from JSON returned by the LLM when generating presentation messages.\n    /// </summary>\n    /// <param name=\"Message\">Welcome/presentation message text (2-4 sentences)</param>\n    /// <param name=\"QuickReplies\">List of quick reply button definitions</param>\n    public record PresentationResponse(\n        [property: JsonPropertyName(\"message\")] string Message,\n        [property: JsonPropertyName(\"quickReplies\")] List<QuickReply> QuickReplies);\n\n    // ==========================================================================\n    // PRESENTATION FLOW MESSAGES\n    // ==========================================================================\n\n    /// <summary>\n    /// Trigger message to generate and send the initial presentation/welcome message.\n    /// Sent automatically when a conversation is created.\n    /// </summary>\n    public record GeneratePresentationMessage;\n\n    /// <summary>\n    /// Context containing the generated presentation message and available intents.\n    /// Used internally by ConversationSupervisorActor to send presentation via SignalR.\n    /// </summary>\n    /// <param name=\"Message\">Welcome message text (either LLM-generated or fallback)</param>\n    /// <param name=\"Intents\">List of available intent definitions</param>\n    public record PresentationContext(\n        string Message,\n        List<IntentDefinition> Intents)\n    {\n        /// <summary>\n        /// LLM-generated quick replies (takes precedence over Intents if available).\n        /// If null, quick replies are derived from Intents directly.\n        /// </summary>\n        public List<QuickReply>? LLMQuickReplies { get; init; }\n    }\n\n    // ==========================================================================\n    // CONTEXT WRAPPERS FOR BECOME/PIPETO PATTERN\n    // ==========================================================================\n    // These records wrap async operation results with the original sender reference\n    // to ensure correct message routing after async operations complete.\n\n    // --- ConversationSupervisorActor Contexts ---\n\n    /// <summary>\n    /// Processing context maintained throughout the conversation pipeline.\n    /// Captures the original message, sender, and classification result as it flows through states.\n    /// </summary>\n    /// <param name=\"OriginalMessage\">The user message being processed</param>\n    /// <param name=\"OriginalSender\">Actor reference to reply to (typically ConversationManagerActor)</param>\n    /// <param name=\"Classification\">Intent classification result (populated after ClassifierActor processes message)</param>\n    public record ProcessingContext(\n        UserMessage OriginalMessage,\n        IActorRef OriginalSender,\n        ClassificationResult? Classification = null);\n\n    // --- RouterActor Contexts ---\n\n    /// <summary>\n    /// Context wrapper for failure via PipeTo in RouterActor.\n    /// Captures Akka.NET failure state and original sender for proper routing.\n    /// </summary>\n    /// <param name=\"Failure\">Akka.NET failure status</param>\n    /// <param name=\"OriginalSender\">Actor reference to reply to (typically ConversationSupervisorActor)</param>\n    public record FailureContext(\n        Status.Failure Failure,\n        IActorRef OriginalSender);\n\n    // ==========================================================================\n    // INTENT CONFIGURATION RECORDS\n    // ==========================================================================\n\n    /// <summary>\n    /// Intent definition for classification and presentation.\n    /// Defines what intents the system can recognize and how to present them to users.\n    /// </summary>\n    /// <param name=\"Name\">Intent identifier (lowercase, e.g., \"billing\", \"contract\")</param>\n    /// <param name=\"Description\">Intent description for classifier LLM</param>\n    /// <param name=\"Label\">User-facing label with emoji (e.g., \"\uD83D\uDCC4 Billing\") for quick replies</param>\n    /// <param name=\"DefaultValue\">Sample user message for this intent (used in quick reply value)</param>\n    public record IntentDefinition(\n        [property: JsonPropertyName(\"Name\")] string Name,\n        [property: JsonPropertyName(\"Description\")] string Description,\n        [property: JsonPropertyName(\"Label\")] string? Label,\n        [property: JsonPropertyName(\"DefaultValue\")] string? DefaultValue = null);\n\n    // ==========================================================================\n    // INTENT CONFIGURATION RECORDS\n    // ==========================================================================\n\n    /// <summary>\n    /// Collection of intent definitions with utility methods for classification and presentation.\n    /// Provides filtering and formatting capabilities for different use cases.\n    /// </summary>\n    public record IntentCollection\n    {\n        /// <summary>\n        /// List of all intent definitions.\n        /// </summary>\n        public List<IntentDefinition> Intents { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of IntentCollection.\n        /// </summary>\n        /// <param name=\"intents\">List of intent definitions to wrap</param>\n        public IntentCollection(List<IntentDefinition> intents)\n        {\n            Intents = intents;\n        }\n\n        /// <summary>\n        /// Converts intents to a dictionary mapping intent names to descriptions.\n        /// Used by ClassifierActor to format intents for LLM classification prompt.\n        /// </summary>\n        /// <returns>Dictionary with intent name as key and description as value</returns>\n        /// <remarks>\n        /// <para><strong>Usage in ClassifierActor:</strong></para>\n        /// <code>\n        /// IntentCollection intentCollection = new IntentCollection(intents);\n        /// Dictionary&lt;string, string&gt; intentDict = intentCollection.AsDictionary();\n        ///\n        /// // Format for LLM: \"billing (requests to view invoices)|contract (requests to summarize contract)\"\n        /// string formattedIntents = string.Join(\"|\", intentDict.Select(kvp => $\"{kvp.Key} ({kvp.Value})\"));\n        /// </code>\n        /// </remarks>\n        public Dictionary<string, string> AsDictionary()\n        {\n            return Intents.ToDictionary(i => i.Name, i => i.Description);\n        }\n\n        /// <summary>\n        /// Gets intents that should be displayed in presentation quick replies.\n        /// Excludes the \"other\" fallback intent and intents without labels.\n        /// </summary>\n        /// <returns>List of displayable intent definitions</returns>\n        /// <remarks>\n        /// <para><strong>Filtering Rules:</strong></para>\n        /// <list type=\"bullet\">\n        /// <item>Exclude \"other\" intent (special fallback, not user-selectable)</item>\n        /// <item>Exclude intents without Label property (not meant for UI display)</item>\n        /// </list>\n        /// <para><strong>Usage in Presentation:</strong></para>\n        /// <code>\n        /// IntentCollection intentCollection = new IntentCollection(allIntents);\n        /// List&lt;IntentDefinition&gt; displayable = intentCollection.GetDisplayableIntents();\n        ///\n        /// // Convert to quick replies for SignalR\n        /// List&lt;QuickReply&gt; quickReplies = displayable\n        ///     .Select(i => new QuickReply(i.Name, i.Label, i.DefaultValue))\n        ///     .ToList();\n        /// </code>\n        /// </remarks>\n        public List<IntentDefinition> GetDisplayableIntents()\n        {\n            return Intents\n                .Where(i => !string.Equals(i.Name, \"other\", StringComparison.OrdinalIgnoreCase)\n                              && !string.IsNullOrEmpty(i.Label))\n                .ToList();\n        }\n    }\n\n    // ==========================================================================\n    // PROMPT CONFIGURATION RECORDS\n    // ==========================================================================\n\n    /// <summary>\n    /// Root collection of prompts loaded from configuration files (morgana.json, agents.json).\n    /// Used during JSON deserialization.\n    /// </summary>\n    /// <param name=\"Prompts\">Array of prompt definitions</param>\n    public record PromptCollection(\n        Prompt[] Prompts);\n\n    /// <summary>\n    /// Prompt definition containing instructions, personality, and metadata for agents and actors.\n    /// Loaded from morgana.json (framework prompts) or agents.json (domain prompts).\n    /// </summary>\n    /// <param name=\"ID\">\n    /// Unique prompt identifier.\n    /// Framework: \"Morgana\", \"Classifier\", \"Guard\", \"Presentation\"\n    /// Domain: Intent names like \"billing\", \"contract\", \"monkeys\"\n    /// </param>\n    /// <param name=\"Type\">Prompt type (e.g., \"SYSTEM\", \"INTENT\")</param>\n    /// <param name=\"SubType\">Prompt subtype (e.g., \"AGENT\", \"ACTOR\", \"PRESENTATION\")</param>\n    /// <param name=\"Target\">Core prompt text defining role and capabilities</param>\n    /// <param name=\"Instructions\">Behavioral rules and guidelines</param>\n    /// <param name=\"Personality\">Optional tone and character traits</param>\n    /// <param name=\"Language\">Language code (e.g., \"en-US\", \"it-IT\")</param>\n    /// <param name=\"Version\">Prompt version for tracking changes</param>\n    /// <param name=\"AdditionalProperties\">\n    /// List of dictionaries containing additional data like GlobalPolicies, Tools, ErrorAnswers, etc.\n    /// </param>\n    public record Prompt(\n        string ID,\n        string Type,\n        string SubType,\n        string Target,\n        string Instructions,\n        string Formatting,\n        string? Personality,\n        string Language,\n        string Version,\n        List<Dictionary<string, object>> AdditionalProperties)\n    {\n        /// <summary>\n        /// Gets a strongly-typed additional property from the prompt configuration.\n        /// Searches all AdditionalProperties dictionaries for the specified key.\n        /// </summary>\n        /// <typeparam name=\"T\">Type to deserialize the property value into</typeparam>\n        /// <param name=\"additionalPropertyName\">Name of the property to retrieve (e.g., \"Tools\", \"GlobalPolicies\")</param>\n        /// <returns>Deserialized property value</returns>\n        /// <exception cref=\"KeyNotFoundException\">Thrown if property not found in any AdditionalProperties dictionary</exception>\n        /// <remarks>\n        /// <para><strong>Common Additional Properties:</strong></para>\n        /// <list type=\"bullet\">\n        /// <item><term>Tools</term><description>List&lt;ToolDefinition&gt; - Tool configurations for agents</description></item>\n        /// <item><term>GlobalPolicies</term><description>List&lt;GlobalPolicy&gt; - Framework-level behavioral policies</description></item>\n        /// <item><term>ErrorAnswers</term><description>List&lt;ErrorAnswer&gt; - Error message templates</description></item>\n        /// <item><term>ProfanityTerms</term><description>List&lt;string&gt; - Terms for content moderation</description></item>\n        /// <item><term>FallbackMessage</term><description>string - Default presentation message</description></item>\n        /// </list>\n        /// <para><strong>Usage Examples:</strong></para>\n        /// <code>\n        /// Prompt morganaPrompt = await promptResolver.ResolveAsync(\"Morgana\");\n        ///\n        /// // Get global policies\n        /// List&lt;GlobalPolicy&gt; policies = morganaPrompt.GetAdditionalProperty&lt;List&lt;GlobalPolicy&gt;&gt;(\"GlobalPolicies\");\n        ///\n        /// // Get tools\n        /// ToolDefinition[] tools = morganaPrompt.GetAdditionalProperty&lt;ToolDefinition[]&gt;(\"Tools\");\n        ///\n        /// // Get error messages\n        /// List&lt;ErrorAnswer&gt; errors = morganaPrompt.GetAdditionalProperty&lt;List&lt;ErrorAnswer&gt;&gt;(\"ErrorAnswers\");\n        /// </code>\n        /// </remarks>\n        public T GetAdditionalProperty<T>(string additionalPropertyName)\n        {\n            foreach (Dictionary<string, object> additionalProperties in AdditionalProperties)\n            {\n                if (additionalProperties.TryGetValue(additionalPropertyName, out object value))\n                {\n                    JsonElement element = (JsonElement)value;\n                    return element.Deserialize<T>();\n                }\n            }\n            throw new KeyNotFoundException($\"AdditionalProperty with key '{additionalPropertyName}' was not found in the prompt with id='{ID}'\");\n        }\n    }\n\n    /// <summary>\n    /// Global policy definition specifying framework-level behavioral rules.\n    /// Applied to all agents and actors to enforce consistent behavior.\n    /// </summary>\n    /// <param name=\"Name\">Policy name (e.g., \"ContextHandling\", \"InteractiveToken\")</param>\n    /// <param name=\"Description\">Detailed policy description with enforcement rules</param>\n    /// <param name=\"Type\">Policy type (\"Critical\" or \"Operational\")</param>\n    /// <param name=\"Priority\">Priority level (lower number = higher priority)</param>\n    public record GlobalPolicy(\n        string Name,\n        string Description,\n        string Type,\n        int Priority);\n\n    /// <summary>\n    /// Error message template with named identifier.\n    /// Used to provide consistent, user-friendly error messages across the system.\n    /// </summary>\n    /// <param name=\"Name\">Error identifier (e.g., \"GenericError\", \"LLMServiceError\")</param>\n    /// <param name=\"Content\">Error message template (may contain placeholders like ((llm_error)))</param>\n    public record ErrorAnswer(\n        string Name,\n        string Content);\n\n    // ==========================================================================\n    // TOOL CONFIGURATION RECORDS\n    // ==========================================================================\n\n    /// <summary>\n    /// Tool definition specifying a callable tool method with parameters.\n    /// Loaded from agents.json and used by MorganaToolAdapter to create AIFunction instances.\n    /// </summary>\n    /// <param name=\"Name\">Tool method name (must match actual method name in MorganaTool class)</param>\n    /// <param name=\"Description\">Tool description for LLM understanding</param>\n    /// <param name=\"Parameters\">List of tool parameter definitions</param>\n    public record ToolDefinition(\n        string Name,\n        string Description,\n        IReadOnlyList<ToolParameter> Parameters);\n\n    /// <summary>\n    /// Tool parameter definition specifying parameter name, description, and behavior.\n    /// Controls whether parameter comes from context or request, and if it's shared across agents.\n    /// </summary>\n    /// <param name=\"Name\">Parameter name (must match method parameter name)</param>\n    /// <param name=\"Description\">Parameter description for LLM understanding</param>\n    /// <param name=\"Required\">Whether the parameter is required (true) or optional (false)</param>\n    /// <param name=\"Scope\">\n    /// Parameter scope: \"context\" (retrieve via GetContextVariable) or \"request\" (use directly from user input)\n    /// </param>\n    /// <param name=\"Shared\">\n    /// Whether this context variable should be broadcast to other agents.\n    /// Only applies when Scope=\"context\". Default: false.\n    /// </param>\n    public record ToolParameter(\n        string Name,\n        string Description,\n        bool Required,\n        string Scope,\n        bool Shared = false);\n\n    // ==========================================================================\n    // MODEL CONTEXT PROTOCOL\n    // ==========================================================================\n\n    /// <summary>\n    /// MCP server configuration from appsettings.json.\n    /// Defines how to connect to and initialize MCP servers.\n    /// </summary>\n    public record MCPServerConfig(\n        string Name,\n        string Uri,\n        bool Enabled,\n        Dictionary<string, string>? AdditionalSettings = null);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Morgana.Framework/Records.cs b/Morgana.Framework/Records.cs
--- a/Morgana.Framework/Records.cs	(revision e86454808c7970547eb5c2f2eb58ad8596c6af76)
+++ b/Morgana.Framework/Records.cs	(date 1770319862684)
@@ -41,7 +41,8 @@
         string? AgentName = null,
         bool AgentCompleted = false,
         List<QuickReply>? QuickReplies = null,
-        DateTime? OriginalTimestamp = null);
+        DateTime? OriginalTimestamp = null,
+        RichCard? RichCard = null);
 
     /// <summary>
     /// Request to create a new conversation and initialize the actor hierarchy.
@@ -426,7 +427,8 @@
     public record AgentResponse(
         string Response,
         bool IsCompleted = true,
-        List<QuickReply>? QuickReplies = null);
+        List<QuickReply>? QuickReplies = null,
+        RichCard? RichCard = null);
 
     /// <summary>
     /// Response from RouterActor containing both the agent's response and a reference to the agent actor.
@@ -440,7 +442,8 @@
         string Response,
         bool IsCompleted,
         IActorRef AgentRef,
-        List<QuickReply>? QuickReplies = null);
+        List<QuickReply>? QuickReplies = null,
+        RichCard? RichCard = null);
 
     /// <summary>
     /// Represents a streaming chunk from an agent during real-time response generation.
@@ -542,6 +545,185 @@
         [property: JsonPropertyName("message")] string Message,
         [property: JsonPropertyName("quickReplies")] List<QuickReply> QuickReplies);
 
+    // ==========================================================================
+    // RICH CARD SYSTEM
+    // ==========================================================================
+    // Add this section to Morgana.Framework/Records.cs
+
+    /// <summary>
+    /// Rich card container for structured visual presentation of complex data.
+    /// Used to render information (invoices, profiles, reports) with visual hierarchy
+    /// instead of plain text walls.
+    /// </summary>
+    /// <param name="Title">Main title of the card</param>
+    /// <param name="Subtitle">Optional subtitle or secondary information</param>
+    /// <param name="Components">Array of visual components to render</param>
+    /// <remarks>
+    /// <para><strong>Usage:</strong></para>
+    /// <para>LLM generates rich cards via SetRichCard tool when presenting structured data.
+    /// Cards flow through actor pipeline (Agent → Router → Supervisor → Manager → SignalR → Cauldron).</para>
+    /// <para><strong>Constraints:</strong></para>
+    /// <list type="bullet">
+    /// <item>Maximum nesting depth: 3 levels (enforced by SetRichCard tool)</item>
+    /// <item>Maximum 50 components total (prevents abuse)</item>
+    /// <item>Components must be from known dictionary (unknown types fallback to text in Cauldron)</item>
+    /// </list>
+    /// </remarks>
+    public record RichCard(
+        [property: JsonPropertyName("title")] string Title,
+        [property: JsonPropertyName("subtitle")] string? Subtitle,
+        [property: JsonPropertyName("components")] List<CardComponent> Components
+    );
+
+    /// <summary>
+    /// Base class for all card components.
+    /// Uses JSON polymorphic serialization for type discrimination.
+    /// </summary>
+    /// <remarks>
+    /// <para><strong>Component Dictionary:</strong></para>
+    /// <list type="bullet">
+    /// <item><term>text_block</term><description>Free-form narrative text</description></item>
+    /// <item><term>key_value</term><description>Label-value pairs for structured data</description></item>
+    /// <item><term>divider</term><description>Visual separator between sections</description></item>
+    /// <item><term>list</term><description>Bulleted, numbered, or plain item lists</description></item>
+    /// <item><term>section</term><description>Nestable grouping with title/subtitle</description></item>
+    /// <item><term>grid</term><description>2-4 column layout for side-by-side data</description></item>
+    /// <item><term>badge</term><description>Status indicators (success, warning, error, info, neutral)</description></item>
+    /// </list>
+    /// <para><strong>Extensibility:</strong></para>
+    /// <para>Implementers can add new component types by:</para>
+    /// <list type="number">
+    /// <item>Adding new record inheriting from CardComponent</item>
+    /// <item>Adding JsonDerivedType attribute to CardComponent</item>
+    /// <item>Creating corresponding Razor component in Cauldron</item>
+    /// </list>
+    /// </remarks>
+    [JsonPolymorphic(TypeDiscriminatorPropertyName = "type")]
+    [JsonDerivedType(typeof(TextBlockComponent), "text_block")]
+    [JsonDerivedType(typeof(KeyValueComponent), "key_value")]
+    [JsonDerivedType(typeof(DividerComponent), "divider")]
+    [JsonDerivedType(typeof(ListComponent), "list")]
+    [JsonDerivedType(typeof(SectionComponent), "section")]
+    [JsonDerivedType(typeof(GridComponent), "grid")]
+    [JsonDerivedType(typeof(BadgeComponent), "badge")]
+    public abstract record CardComponent;
+
+    /// <summary>
+    /// Free-form text block component for narrative content within cards.
+    /// </summary>
+    /// <param name="Content">Text content (supports multiline)</param>
+    /// <param name="Style">Visual styling for the text</param>
+    public record TextBlockComponent(
+        [property: JsonPropertyName("content")] string Content,
+        [property: JsonPropertyName("style")] TextStyle Style = TextStyle.Normal
+    ) : CardComponent;
+
+    /// <summary>
+    /// Key-value pair component for structured label-value data.
+    /// </summary>
+    /// <param name="Key">Label/field name (e.g., "Cliente", "Totale")</param>
+    /// <param name="Value">Corresponding value (e.g., "Acme Corp", "€1.250,00")</param>
+    /// <param name="Emphasize">True to highlight this pair visually (e.g., bold, larger font)</param>
+    public record KeyValueComponent(
+        [property: JsonPropertyName("key")] string Key,
+        [property: JsonPropertyName("value")] string Value,
+        [property: JsonPropertyName("emphasize")] bool Emphasize = false
+    ) : CardComponent;
+
+    /// <summary>
+    /// Visual divider/separator component.
+    /// Renders as horizontal line to separate logical sections.
+    /// </summary>
+    public record DividerComponent() : CardComponent;
+
+    /// <summary>
+    /// List component for displaying multiple related items.
+    /// </summary>
+    /// <param name="Items">Array of text items to display</param>
+    /// <param name="Style">List presentation style (bullet, numbered, plain)</param>
+    public record ListComponent(
+        [property: JsonPropertyName("items")] List<string> Items,
+        [property: JsonPropertyName("style")] ListStyle Style = ListStyle.Bullet
+    ) : CardComponent;
+
+    /// <summary>
+    /// Section component for logical grouping with nesting support.
+    /// Enables hierarchical organization of card content (max depth: 3).
+    /// </summary>
+    /// <param name="Title">Section title/heading</param>
+    /// <param name="Subtitle">Optional section subtitle</param>
+    /// <param name="Components">Child components within this section (can include nested sections)</param>
+    public record SectionComponent(
+        [property: JsonPropertyName("title")] string Title,
+        [property: JsonPropertyName("subtitle")] string? Subtitle,
+        [property: JsonPropertyName("components")] List<CardComponent> Components
+    ) : CardComponent;
+
+    /// <summary>
+    /// Grid component for side-by-side data presentation.
+    /// </summary>
+    /// <param name="Columns">Number of columns (2-4 recommended)</param>
+    /// <param name="Items">Grid cells with key-value pairs</param>
+    public record GridComponent(
+        [property: JsonPropertyName("columns")] int Columns,
+        [property: JsonPropertyName("items")] List<GridItem> Items
+    ) : CardComponent;
+
+    /// <summary>
+    /// Individual grid cell containing a key-value pair.
+    /// </summary>
+    /// <param name="Key">Label for this grid cell</param>
+    /// <param name="Value">Value for this grid cell</param>
+    public record GridItem(
+        [property: JsonPropertyName("key")] string Key,
+        [property: JsonPropertyName("value")] string Value
+    );
+
+    /// <summary>
+    /// Badge component for status indicators and categorical labels.
+    /// </summary>
+    /// <param name="Text">Badge text (e.g., "Pagata", "In sospeso")</param>
+    /// <param name="Variant">Visual variant determining color/style</param>
+    public record BadgeComponent(
+        [property: JsonPropertyName("text")] string Text,
+        [property: JsonPropertyName("variant")] BadgeVariant Variant = BadgeVariant.Neutral
+    ) : CardComponent;
+
+    // Enums for component styling
+
+    /// <summary>
+    /// Text styling options for TextBlockComponent.
+    /// </summary>
+    public enum TextStyle
+    {
+        [JsonPropertyName("normal")] Normal,
+        [JsonPropertyName("bold")] Bold,
+        [JsonPropertyName("muted")] Muted,
+        [JsonPropertyName("small")] Small
+    }
+
+    /// <summary>
+    /// List presentation styles for ListComponent.
+    /// </summary>
+    public enum ListStyle
+    {
+        [JsonPropertyName("bullet")] Bullet,
+        [JsonPropertyName("numbered")] Numbered,
+        [JsonPropertyName("plain")] Plain
+    }
+
+    /// <summary>
+    /// Badge color variants for BadgeComponent.
+    /// </summary>
+    public enum BadgeVariant
+    {
+        [JsonPropertyName("success")] Success,
+        [JsonPropertyName("warning")] Warning,
+        [JsonPropertyName("error")] Error,
+        [JsonPropertyName("info")] Info,
+        [JsonPropertyName("neutral")] Neutral
+    }
+
     // ==========================================================================
     // PRESENTATION FLOW MESSAGES
     // ==========================================================================
