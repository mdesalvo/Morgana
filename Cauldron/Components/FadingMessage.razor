@* 
    FadingMessage Component - Temporary System Warning Banner
    
    Features:
    - Auto-dismiss after 10 seconds
    - Smooth fade-out animation (last 2 seconds)
    - Self-contained state management
    - Configurable icon based on error reason
    
    Usage:
    <FadingMessage Message="@tempMessage" OnDismissed="@(() => HandleDismiss(tempMessage))" />
*@

@if (isVisible)
{
    <div class="temporary-message-banner @(isFading ? "fading" : "")">
        <span class="banner-icon">
            @GetIcon()
        </span>
        <span class="banner-text">@Message.Text</span>
    </div>
}

@code {
    /// <summary>
    /// The SignalR message to display in the banner.
    /// </summary>
    [Parameter]
    public SignalRMessage Message { get; set; } = null!;

    /// <summary>
    /// Callback invoked when the message is auto-dismissed after duration expires.
    /// Parent component should remove message from its list.
    /// Passes the dismissed message as parameter.
    /// </summary>
    [Parameter]
    public EventCallback<SignalRMessage> OnDismissed { get; set; }

    /// <summary>
    /// Total duration in seconds before auto-dismiss.
    /// Default: 10 seconds (8s visible + 2s fade-out).
    /// </summary>
    [Parameter]
    public int DurationSeconds { get; set; } = 10;

    /// <summary>
    /// Controls banner visibility (for smooth mount/unmount).
    /// </summary>
    private bool isVisible = true;

    /// <summary>
    /// Tracks if banner is in fading state (last 2 seconds before removal).
    /// </summary>
    private bool isFading = false;

    /// <summary>
    /// Cancellation token for cleanup on component disposal.
    /// </summary>
    private CancellationTokenSource? cancellationTokenSource;

    protected override void OnInitialized()
    {
        // Start auto-dismiss timer
        StartAutoDismissTimer();
    }

    /// <summary>
    /// Starts the auto-dismiss timer with fade-out animation.
    /// Timeline: (duration-2)s visible → 2s fading → dismiss
    /// </summary>
    private void StartAutoDismissTimer()
    {
        cancellationTokenSource = new CancellationTokenSource();

        // Calculate visible phase duration (total - 2s fade-out)
        int visibleDuration = Math.Max(1, DurationSeconds - 2) * 1000; // Min 1s
        const int fadeDuration = 2000; // 2 seconds fade-out

        _ = Task.Run(async () =>
        {
            try
            {
                // Phase 1: Visible
                await Task.Delay(visibleDuration, cancellationTokenSource.Token);

                // Phase 2: Trigger fade-out animation
                isFading = true;
                await InvokeAsync(StateHasChanged);

                await Task.Delay(fadeDuration, cancellationTokenSource.Token);

                // Phase 3: Hide and notify parent
                isVisible = false;
                await InvokeAsync(StateHasChanged);

                // Notify parent to remove this specific message from list
                await OnDismissed.InvokeAsync(Message);
            }
            catch (TaskCanceledException)
            {
                // Component disposed before timer completed - cleanup handled
            }
        }, cancellationTokenSource.Token);
    }

    /// <summary>
    /// Gets the appropriate icon based on error reason.
    /// </summary>
    /// <returns>Emoji icon string</returns>
    private string GetIcon()
    {
        return Message.ErrorReason switch
        {
            "rate_limit_exceeded" => "✋",
            _ => "⚠️"
        };
    }

    /// <summary>
    /// Cleanup cancellation token on component disposal.
    /// </summary>
    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }
}