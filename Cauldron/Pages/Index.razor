@page "/"
@using Cauldron.Services
@inject MorganaSignalRService SignalRService
@inject MorganaLandingMessageService LandingMessageService
@inject IConversationStorageService StorageService
@inject IConversationHistoryService HistoryService
@inject NavigationManager NavigationManager
@inject HttpClient Http
@inject IConfiguration Configuration
@implements IAsyncDisposable

<PageTitle>Morgana - Magical AI Assistant</PageTitle>

<div class="chat-container">
    <!-- Header -->
    <div class="chat-header">
        <div class="header-content">

            <img src="images/morgana-avatar.png" 
                 alt="Morgana" 
                 class="header-avatar"
                 style="border: 3px solid @GetAvatarBorderColor(currentAgentName);" />

            <div class="header-info">
                <h1 style="color: @GetAvatarBorderColor(currentAgentName);">@currentAgentName</h1>
                <span class="status @(isConnected ? "online" : "offline")" style="color: @(isConnected ? "#10b981" : "#ef4444");">
                    @(isConnected ? "Online" : "Offline")
                </span>
            </div>

            <button class="new-conversation-btn @(IsNewConversationButtonVisible ? "visible" : "hidden")"
                    @onclick="ShowConfirmModal"
                    title="Start a new conversation with Morgana">
                <span class="btn-icon">‚ú®</span>
                <span class="btn-text">New Conversation</span>
            </button>

        </div>
    </div>

    <!-- Messages Area -->
    <div class="messages-container">

        @* ============ TEMPORARY SYSTEM WARNINGS (always on top) ================================ *@
        @if (temporaryMessages.Any())
        {
            <div class="temporary-messages-container">
                @foreach (SignalRMessage temporaryMessage in temporaryMessages)
                {
                    <FadingMessage Message="@temporaryMessage"
                                   DurationSeconds="@(temporaryMessage.FadingMessageDurationSeconds ?? 10)"
                                   OnDismissed="@HandleMessageDismissed"/>
                }
            </div>
        }
        @* ======================================================================================= *@

        @if (chatMessages.Count == 0)
        {
            <!-- Loading state with magical animation -->
            <!-- Loader visible until first message arrives from backend (presentation or conversation history) -->
            <div class="magical-loader">
                <div class="magic-sparkle-core">
                    <div class="glow-core"></div>
                    <div class="glow-ring ring-1"></div>
                    <div class="glow-ring ring-2"></div>
                    <div class="glow-ring ring-3"></div>
                </div>
                <div class="sparkles-container">
                    <div class="sparkle sp1"></div>
                    <div class="sparkle sp2"></div>
                    <div class="sparkle sp3"></div>
                    <div class="sparkle sp4"></div>
                    <div class="sparkle sp5"></div>
                    <div class="sparkle sp6"></div>
                    <div class="sparkle sp7"></div>
                    <div class="sparkle sp8"></div>
                    <div class="sparkle sp9"></div>
                    <div class="sparkle sp10"></div>
                    <div class="sparkle sp11"></div>
                    <div class="sparkle sp12"></div>
                </div>
                <p class="loading-text">@(landingMessage)</p>
            </div>
        }
        else
        {
            <!-- Message list -->
            @foreach (ChatMessage chatMessage in chatMessages)
            {
                <div class="message @chatMessage.Role">
                    @if (chatMessage.Role == "assistant")
                    {
                        <!-- Agent avatar with dynamic border color -->
                        <img src="images/morgana-avatar.png"
                             alt="@chatMessage.AgentName"
                             class="message-avatar"
                             style="border: 2px solid @GetAvatarBorderColor(chatMessage.AgentName);"/>
                    }
                    <div class="message-bubble @(chatMessage.IsStreaming ? "streaming" : "")">
                        @if (chatMessage.IsTyping)
                        {
                            <!-- Typing indicator (sparkles stars) -->
                            <div class="typing-indicator @(IsSpecializedAgent(chatMessage.AgentName) ? "specialized" : "base")">
                                <span><svg viewBox="0 0 24 24"><path d="M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z"/></svg></span>
                                <span><svg viewBox="0 0 24 24"><path d="M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z"/></svg></span>
                                <span><svg viewBox="0 0 24 24"><path d="M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z"/></svg></span>
                            </div>
                        }
                        else
                        {
                            @* Message content (text) *@
                            <div class="message-text @(chatMessage.Type == MessageType.Presentation ? "completion-text" : "")">
                                @chatMessage.Text
                            </div>
                            
                            @* Rich card (if present) *@
                            @if (chatMessage.RichCard != null)
                            {
                                <RichCard Card="@chatMessage.RichCard" />
                            }

                            @* Quick replies (if present) *@
                            @if (chatMessage is { QuickReplies: { Count: > 0 }, IsStreaming: false })
                            {
                                <QuickReplyButton Replies="@chatMessage.QuickReplies"
                                                  OnSelect="@((reply) => SelectQuickReplyAsync(reply, chatMessage))"
                                                  IsDisabled="@(chatMessage.SelectedQuickReplyId != null || chatMessage.IsLastHistoryMessage == false)"
                                                  SelectedReplyId="@chatMessage.SelectedQuickReplyId"/>
                            }

                            <!-- Message timestamp -->
                            <div class="message-time">@chatMessage.Timestamp.ToString("HH:mm")</div>
                        }
                    </div>
                </div>
            }
        }
    </div>

    <!-- Input Area -->
    <div class="input-container">
        <textarea
            @bind="inputText"
            @bind:event="oninput"
            @onkeyup="HandleKeyPressAsync"
            placeholder="Consult @(currentAgentName)..."
            rows="1"
            disabled="@IsTextareaDisabled"
            class="message-input @(IsSpecializedAgent(currentAgentName) ? "agent" : "morgana")"></textarea>
        <button
            @onclick="SendMessageAsync"
            disabled="@IsSendButtonDisabled"
            class="send-button @(isSending ? "sending" : "") @(IsSpecializedAgent(currentAgentName) ? "agent" : "morgana")">
            <!-- Animated cauldron icon with magical effects -->
            <span class="cauldron-wrapper">
                <span class="cauldron-icon">
                    <span class="cauldron-body @(IsSpecializedAgent(currentAgentName) ? "agent" : "morgana")"></span>
                    <span class="brew-surface"></span>
                    <span class="bubble b1"></span>
                    <span class="bubble b2"></span>
                    <span class="bubble b3"></span>
                    <span class="bubble b4"></span>
                    <span class="steam st1"></span>
                    <span class="steam st2"></span>
                    <span class="steam st3"></span>
                </span>
                <span class="magic-glow"></span>
                <span class="magic-ring"></span>
                <span class="sparkle s1"></span>
                <span class="sparkle s2"></span>
                <span class="sparkle s3"></span>
                <span class="sparkle s4"></span>
                <span class="sparkle s5"></span>
                <span class="sparkle s6"></span>
            </span>
        </button>
    </div>
</div>

<!-- Confirmation Modal for New Conversation -->
<ConfirmModal IsVisible="@showConfirmModal"
              Title="Start New Conversation?"
              Message="This will start a new conversation with Morgana. Your chat history will be lost. Are you sure you want to continue?"
              ConfirmText="Yes, start new"
              CancelText="No, stay here"
              OnConfirm="@ConfirmNewConversationAsync"
              OnCancel="@HideConfirmModal" />

@code {
    // =========================================================================
    // STATE VARIABLES
    // =========================================================================

    /// <summary>
    /// List of all chat messages in the current conversation.
    /// Includes user messages, agent responses, typing indicators, and presentation messages.
    /// </summary>
    private List<ChatMessage> chatMessages = [];

    /// <summary>
    /// List of active temporary system warnings (rate limit errors, etc.).
    /// Rendered as auto-dismissing banners via FadingMessage component.
    /// </summary>
    private List<SignalRMessage> temporaryMessages = [];

    /// <summary>
    /// Current text input from the user (two-way bound to textarea).
    /// </summary>
    private string inputText = string.Empty;

    /// <summary>
    /// Unique identifier for the current conversation.
    /// Generated on conversation start and used for message routing.
    /// </summary>
    private string conversationId = string.Empty;

    /// <summary>
    /// SignalR connection state indicator.
    /// True when connected and ready to receive messages.
    /// </summary>
    private bool isConnected;

    /// <summary>
    /// Message send operation in progress indicator.
    /// True during HTTP POST to prevent duplicate sends.
    /// </summary>
    private bool isSending;

    /// <summary>
    /// Initialization complete indicator.
    /// True after SignalR connection and conversation start succeed.
    /// </summary>
    private bool isInitialized;

    /// <summary>
    /// Controls visibility of the new conversation confirmation modal.
    /// </summary>
    private bool showConfirmModal;

    /// <summary>
    /// Name of the currently active agent.
    /// Updates dynamically when agents take control: "Morgana", "Morgana (Billing)", etc.
    /// Displayed in header and used for avatar border color.
    /// </summary>
    private string currentAgentName = "Morgana";

    /// <summary>
    /// Landing message (waiting for Morgana presentation).
    /// </summary>
    private string landingMessage = string.Empty;

    /// <summary>
    /// Flag to track if storage has been checked (prevents multiple checks on re-renders).
    /// </summary>
    private bool hasCheckedStorage;

    // =========================================================================
    // STREAMING STATE VARIABLES
    // =========================================================================

    /// <summary>
    /// Buffer containing chunks received from backend that haven't been displayed yet.
    /// Used by the typewriter effect to progressively render text.
    /// </summary>
    private string streamingBuffer = string.Empty;

    /// <summary>
    /// Timer for typewriter effect animation.
    /// Fires every 50ms to display next character from streaming buffer.
    /// </summary>
    private Timer? typewriterTimer;

    /// <summary>
    /// Reference to the message currently being streamed.
    /// Null when no streaming is in progress.
    /// </summary>
    private ChatMessage? currentStreamingMessage;

    // =========================================================================
    // LIFECYCLE METHODS
    // =========================================================================

    /// <summary>
    /// Blazor lifecycle method called when component is initialized.
    /// Sets up SignalR connection and subscribes to events.
    /// Note: ProtectedLocalStorage check moved to OnAfterRenderAsync for JavaScript interop availability.
    /// </summary>
    /// <returns>Task representing the async initialization</returns>
    protected override async Task OnInitializedAsync()
    {
        try
        {
            Console.WriteLine("üîµ OnInitializedAsync: Starting...");

            // Initialize landing message
            landingMessage = LandingMessageService.GetRandomLandingMessage();

            // Start SignalR connection
            await SignalRService.StartAsync();
            isConnected = SignalRService.IsConnected;
            Console.WriteLine($"üîµ SignalR connected: {isConnected}");

            // Subscribe to message received events
            SignalRService.OnMessageReceived += HandleMessageReceivedAsync;

            // Subscribe to streaming chunks for progressive rendering
            SignalRService.OnStreamChunkReceived += HandleStreamChunkReceivedAsync;

            // Subscribe to connection state changes
            SignalRService.OnConnectionStateChanged += (connected) =>
            {
                isConnected = connected;
                Console.WriteLine($"üîµ Connection state changed: {connected}");
                InvokeAsync(StateHasChanged);
            };

            Console.WriteLine("üîµ Initialization complete. Checking storage for existing conversation...");

            if (!hasCheckedStorage)
            {
                hasCheckedStorage = true;

                try
                {
                    // Check ProtectedLocalStorage for saved conversation ID
                    string? savedConversationId = await StorageService.GetConversationIdAsync();

                    if (!string.IsNullOrEmpty(savedConversationId))
                    {
                        Console.WriteLine($"üîµ Found saved conversation ID: {savedConversationId}");
                        await ResumeConversationAsync(savedConversationId);
                    }
                    else
                    {
                        Console.WriteLine("üîµ No saved conversation found, starting new");
                        await StartConversationAsync();
                    }

                    isInitialized = true;
                    ClearErrorMessages();  // Clear any previous errors on successful init
                    Console.WriteLine($"üîµ Initialized with conversationId: {conversationId}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"‚ùå Storage check error: {ex.Message}");
                    AddErrorMessage($"Initialization error: {ex.Message}", "initialization_failed", 20);
                }
                finally
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Initialization error: {ex.Message}");
            AddErrorMessage($"Critical initialization error: {ex.Message}", "critical_initialization_failed", 30);
            await InvokeAsync(StateHasChanged);
        }
    }

    // =========================================================================
    // CONVERSATION MANAGEMENT
    // =========================================================================

    /// <summary>
    /// Resumes an existing conversation from ProtectedLocalStorage.
    /// If resume fails (404), automatically falls back to starting a new conversation.
    /// </summary>
    /// <param name="savedConversationId">The conversation ID retrieved from storage</param>
    /// <returns>Task representing the async resume operation</returns>
    /// <remarks>
    /// <para><strong>Resume Flow:</strong></para>
    /// <list type="number">
    /// <item>POST to /api/conversation/{id}/resume</item>
    /// <item>Backend restores actor hierarchy and loads AgentThread from SQLite</item>
    /// <item>Join SignalR group for this conversation</item>
    /// <item>Backend may send welcome-back message via SignalR (optional)</item>
    /// </list>
    /// <para><strong>Fallback Scenarios:</strong></para>
    /// <list type="bullet">
    /// <item><term>404 Not Found</term><description>Conversation expired/deleted ‚Üí Clear storage and start new</description></item>
    /// <item><term>500 Server Error</term><description>Backend error ‚Üí Clear storage and start new</description></item>
    /// <item><term>Network Error</term><description>Connection failure ‚Üí Clear storage and start new</description></item>
    /// </list>
    /// </remarks>
    private async Task ResumeConversationAsync(string savedConversationId)
    {
        try
        {
            Console.WriteLine($"üü° ResumeConversation: Attempting to resume {savedConversationId}");

            // Call Morgana to resume the conversation
            HttpResponseMessage response = await Http.PostAsync(
                $"/api/conversation/{savedConversationId}/resume", null);

            Console.WriteLine($"üü° Resume response status: {response.StatusCode}");

            if (response.IsSuccessStatusCode)
            {
                // Successfully resumed
                ConversationResumeResponse? result = await response.Content
                    .ReadFromJsonAsync<ConversationResumeResponse>();

                conversationId = result?.ConversationId ?? savedConversationId;
                if (string.IsNullOrEmpty(result?.ActiveAgent)
                     || string.Equals(result.ActiveAgent, "Morgana", StringComparison.OrdinalIgnoreCase))
                {
                    currentAgentName = "Morgana";
                }
                else
                {
                    currentAgentName = $"Morgana ({char.ToUpper(result.ActiveAgent[0]) + result.ActiveAgent.Substring(1)})";
                }
                Console.WriteLine($"üü° Conversation resumed: {conversationId}, Active agent: {result?.ActiveAgent}");

                // Join SignalR group
                await SignalRService.JoinConversation(conversationId);

                Console.WriteLine($"üü° Loading conversation history for {conversationId}...");

                try
                {
                    ConversationHistoryResponse? history = await HistoryService.GetHistoryAsync(conversationId);

                    if (history?.Messages is { Length: > 0 })
                    {
                        Console.WriteLine($"üü° Retrieved {history.Messages.Length} messages from history");

                        for (int i = 0; i < history.Messages.Length; i++)
                        {
                            #region Transient Hints
                            if (string.Equals(history.Messages[i].Role, "user", StringComparison.OrdinalIgnoreCase))
                            {
                                // Detect if this user message can be classified as "agent's turn boundary":
                                // it is preceded by "Agent X" message and followed by "Agent Y" message
                                bool isPrecededByAssistantMessage = i > 0 && string.Equals(history.Messages[i-1].Role, "assistant", StringComparison.OrdinalIgnoreCase);
                                bool isFollowedByAssistantMessage = i + 1 < history.Messages.Length && string.Equals(history.Messages[i+1].Role, "assistant", StringComparison.OrdinalIgnoreCase);
                                bool isTurnBoundaryMessage = isPrecededByAssistantMessage 
                                                              && isFollowedByAssistantMessage
                                                              && !string.Equals(history.Messages[i-1].AgentName, history.Messages[i+1].AgentName, StringComparison.OrdinalIgnoreCase);
                                if (isTurnBoundaryMessage)
                                {
                                    // Emit a transient "Agent X has completed" message, which is
                                    // ephemeral and does not participate in the DB conversation
                                    chatMessages.Add(new ChatMessage
                                    {
                                        ConversationId = history.Messages[i].ConversationId,
                                        Text = GetCompletionMessage(history.Messages[i-1].AgentName!),
                                        Role = "assistant",
                                        Timestamp = history.Messages[i].Timestamp.AddMilliseconds(-5),
                                        AgentName = "Morgana",
                                        AgentCompleted = true,
                                        Type = MessageType.Presentation
                                    });
                                }
                            }
                            #endregion

                            chatMessages.Add(history.Messages[i]);
                        }
                        #region Transient Hints
                        // Detect if the last history message can be classified as "agent's turn boundary":
                        // it is an "Agent X" message, but Cauldron is back listening in "Morgana" mode
                        ChatMessage lastHistoryMessage = history.Messages.Last();
                        if (IsSpecializedAgent(lastHistoryMessage.AgentName) && !IsSpecializedAgent(currentAgentName))
                        {
                            // Emit a transient "Agent X has completed" message, which is
                            // ephemeral and does not participate in the DB conversation
                            chatMessages.Add(new ChatMessage
                            {
                                ConversationId = lastHistoryMessage.ConversationId,
                                Text = GetCompletionMessage(lastHistoryMessage.AgentName!),
                                Role = "assistant",
                                Timestamp = lastHistoryMessage.Timestamp.AddMilliseconds(-5),
                                AgentName = "Morgana",
                                AgentCompleted = true,
                                Type = MessageType.Presentation
                            });
                        }
                        #endregion

                        Console.WriteLine($"üü° Conversation history loaded successfully");
                    }
                    else
                    {
                        Console.WriteLine($"‚ö†Ô∏è No history found for conversation {conversationId}");

                        // Add a system message to force UI resume
                        chatMessages.Add(new ChatMessage
                        {
                            ConversationId = conversationId,
                            Text = LandingMessageService.GetRandomResumingMessage(),
                            Role = "assistant",
                            Timestamp = DateTime.UtcNow,
                            AgentName = currentAgentName,
                            Type = MessageType.Assistant
                        });
                    }
                }
                catch (Exception historyEx)
                {
                    Console.WriteLine($"‚ö†Ô∏è Failed to load history: {historyEx.Message}");

                    // Add a system message to force UI resume
                    chatMessages.Add(new ChatMessage
                    {
                        ConversationId = conversationId,
                        Text = LandingMessageService.GetRandomResumingMessage(),
                        Role = "assistant",
                        Timestamp = DateTime.UtcNow,
                        AgentName = currentAgentName,
                        Type = MessageType.Assistant
                    });
                }

                await InvokeAsync(StateHasChanged);

                Console.WriteLine($"üü° Joined SignalR group, waiting for conversation history...");
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                // Conversation not found in backend (expired or deleted)
                Console.WriteLine($"‚ö†Ô∏è Conversation {savedConversationId} not found, starting fresh");
                
                // Clear corrupted/expired storage
                await StorageService.ClearConversationIdAsync();
                
                // Fallback to new conversation
                await StartConversationAsync();
            }
            else
            {
                // Other error (500, etc.)
                string errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"‚ùå Resume error {response.StatusCode}: {errorContent}");
                
                // Clear corrupted/expired storage
                await StorageService.ClearConversationIdAsync();

                // Fallback to new conversation
                await StartConversationAsync();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå ResumeConversation exception: {ex.Message}");
            
            // Clear corrupted/expired storage
            await StorageService.ClearConversationIdAsync();

            // Fallback to new conversation
            await StartConversationAsync();
        }
    }

    /// <summary>
    /// Starts a new conversation with Morgana backend.
    /// Sends POST request to /api/conversation/start, joins SignalR group, saves to storage, and displays presentation message.
    /// </summary>
    /// <returns>Task representing the async conversation start operation</returns>
    /// <remarks>
    /// <para><strong>Flow:</strong></para>
    /// <list type="number">
    /// <item>Generate new conversation ID (GUID)</item>
    /// <item>POST to /api/conversation/start</item>
    /// <item>Extract conversationId from response</item>
    /// <item>Join SignalR conversation group</item>
    /// <item>Save conversationId to ProtectedLocalStorage</item>
    /// <item>Wait for presentation message via SignalR</item>
    /// <item>Display presentation with quick replies</item>
    /// </list>
    /// </remarks>
    private async Task StartConversationAsync()
    {
        try
        {
            Console.WriteLine("üü¢ StartConversation: Calling Morgana...");

            // Generate new conversation ID
            HttpResponseMessage response = await Http.PostAsJsonAsync("/api/conversation/start", new
            {
                conversationId = Guid.NewGuid().ToString("N")
            });

            Console.WriteLine($"üü¢ Morgana Response Status: {response.StatusCode}");

            if (response.IsSuccessStatusCode)
            {
                // Parse response to get conversation ID
                ConversationStartResponse? result = await response.Content.ReadFromJsonAsync<ConversationStartResponse>();
                conversationId = result?.ConversationId ?? string.Empty;

                Console.WriteLine($"üü¢ Conversation started: {conversationId}");

                // Join SignalR group for this conversation
                await SignalRService.JoinConversation(conversationId);

                // Save conversation ID to ProtectedLocalStorage
                await StorageService.SaveConversationIdAsync(conversationId);
                Console.WriteLine($"üü¢ Conversation ID saved to protected storage");

                Console.WriteLine($"üü¢ Waiting for presentation message...");
                // Presentation message will arrive via SignalR OnMessageReceived event
            }
            else
            {
                string errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"‚ùå Morgana error: {errorContent}");
                AddErrorMessage($"Failed to start conversation: {response.StatusCode}", "conversation_start_http_error", 12);
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå StartConversation exception: {ex.Message}");
            AddErrorMessage($"Connection error: {ex.Message}", "conversation_start_exception", 20);
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Clears the saved conversation ID and refreshes the page to start a new conversation.
    /// Triggered by the "+ New Conversation" button.
    /// </summary>
    /// <returns>Task representing the async new conversation operation</returns>
    private async Task ClearConversationAsync()
    {
        try
        {
            Console.WriteLine($"üÜï {nameof(ClearConversationAsync)}: Clearing storage and refreshing...");
            
            // Clear saved conversation ID from ProtectedLocalStorage
            await StorageService.ClearConversationIdAsync();
            
            // Force page reload to trigger OnInitializedAsync with fresh state
            NavigationManager.NavigateTo("/", forceLoad: true);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå {nameof(ClearConversationAsync)} exception: {ex.Message}");
            AddErrorMessage($"Error starting new conversation: {ex.Message}", "new_conversation_failed", 12);
            await InvokeAsync(StateHasChanged);
        }
    }

    // =========================================================================
    // MESSAGE HANDLING
    // =========================================================================

    /// <summary>
    /// Sends a user message to Morgana backend via REST API.
    /// Adds user message and typing indicator to UI, then waits for agent response via SignalR.
    /// </summary>
    /// <returns>Task representing the async send operation</returns>
    /// <remarks>
    /// <para><strong>Flow:</strong></para>
    /// <list type="number">
    /// <item>Validate input text</item>
    /// <item>Add user message to messages list</item>
    /// <item>Add typing indicator to messages list</item>
    /// <item>Update UI</item>
    /// <item>POST to /api/conversation/{conversationId}/message</item>
    /// <item>Wait for response via SignalR (async)</item>
    /// <item>HandleMessageReceived removes typing indicator and adds agent response</item>
    /// </list>
    /// <para><strong>Error Handling:</strong></para>
    /// <para>On HTTP error or exception, typing indicator is removed and error message displayed.</para>
    /// </remarks>
    private async Task SendMessageAsync()
    {
        // Validate input
        if (string.IsNullOrWhiteSpace(inputText) || isSending || !isConnected)
            return;

        string messageText = inputText.Trim();
        inputText = string.Empty;
        isSending = true;

        // Add user message to UI
        chatMessages.Add(new ChatMessage
        {
            ConversationId = conversationId,
            Text = messageText,
            Role = "user",
            Timestamp = DateTime.UtcNow
        });

        // Add typing indicator
        chatMessages.Add(new ChatMessage
        {
            ConversationId = conversationId,
            Role = "assistant",
            IsTyping = true,
            AgentName = currentAgentName,
            Timestamp = DateTime.UtcNow
        });

        StateHasChanged();

        try
        {
            // Send message to backend
            HttpResponseMessage response = await Http.PostAsJsonAsync($"/api/conversation/{conversationId}/message", new
            {
                conversationId = conversationId,
                text = messageText
            });

            Console.WriteLine($"üü° Message sent, response status: {response.StatusCode}");

            if (!response.IsSuccessStatusCode)
            {
                Console.WriteLine($"‚ùå SendMessage failed: {response.StatusCode}");
    
                // Remove typing indicator
                ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);
                if (typingMessage != null)
                {
                    chatMessages.Remove(typingMessage);

                    // Add temporary error banner (visible immediately, auto-dismiss after 10s)
                    AddErrorMessage($"Message not sent: {response.StatusCode}. Please try again.", "send_message_http_error");

                    // Add permanent error to chat history for debugging
                    chatMessages.Add(new ChatMessage
                    {
                        ConversationId = conversationId,
                        Text = "Sorry, an error occurred. Please try again.",
                        Role = "assistant",
                        Timestamp = DateTime.UtcNow,
                        IsError = true,
                        AgentName = currentAgentName,
                        Type = MessageType.Error
                    });

                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå SendMessage exception: {ex.Message}");

            // Remove typing indicator
            ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);
            if (typingMessage != null)
            {
                chatMessages.Remove(typingMessage);

                // Add temporary error banner (visible immediately, auto-dismiss after 10s)
                AddErrorMessage($"Connection error: {ex.Message}. Please try again.", "send_message_exception");

                // Add permanent error to chat history for debugging
                chatMessages.Add(new ChatMessage
                {
                    ConversationId = conversationId,
                    Text = $"Connection error: {ex.Message}",
                    Role = "assistant",
                    Timestamp = DateTime.UtcNow,
                    IsError = true,
                    AgentName = currentAgentName,
                    Type = MessageType.Error
                });

                await InvokeAsync(StateHasChanged);
            }
        }
        finally
        {
            isSending = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Handles incoming messages from SignalR with strongly-typed DTO.
    /// Removes typing indicator, updates agent state, and adds message to UI.
    /// </summary>
    /// <param name="signalrMessage">Strongly-typed SignalR message DTO containing all message data</param>
    /// <returns>Task representing the async message handling</returns>
    /// <remarks>
    /// <para><strong>Agent Lifecycle:</strong></para>
    /// <list type="bullet">
    /// <item><term>Agent Active</term><description>message.AgentCompleted = false, header shows agent name</description></item>
    /// <item><term>Agent Completed</term><description>message.AgentCompleted = true, header returns to "Morgana"</description></item>
    /// </list>
    /// </remarks>
    private async Task HandleMessageReceivedAsync(SignalRMessage signalrMessage)
    {
        try
        {
            Console.WriteLine($"üü£ Message received for conversation: {signalrMessage.ConversationId}");
            Console.WriteLine($"üü£ Agent: {signalrMessage.AgentName}, Completed: {signalrMessage.AgentCompleted}");
            Console.WriteLine($"üü£ QuickReplies count: {signalrMessage.QuickReplies?.Count ?? 0}");

            #region Temporary Messages
            if (string.Equals(signalrMessage.MessageType, "system_warning", StringComparison.OrdinalIgnoreCase)
                 || string.Equals(signalrMessage.MessageType, "error", StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine($"‚ö†Ô∏è Temporary message received: {signalrMessage.MessageType}-{signalrMessage.ErrorReason}");

                temporaryMessages.Add(signalrMessage);
                await InvokeAsync(StateHasChanged);

                return;
            }
            #endregion

            // Verify message is for this conversation
            if (conversationId != signalrMessage.ConversationId)
            {
                Console.WriteLine("‚ö†Ô∏è Message for different conversation, ignoring");
                return;
            }

            // If streaming is active, finalize it with the complete message
            if (currentStreamingMessage != null)
            {
                Console.WriteLine("üé¨ Streaming complete - finalizing message");

                // DON'T flush buffer immediately - let typewriter finish naturally
                // The timer will continue draining the buffer at typewriter speed

                // Just add metadata (text will complete via typewriter)
                currentStreamingMessage.QuickReplies = signalrMessage.QuickReplies;
                currentStreamingMessage.RichCard = signalrMessage.RichCard;
                currentStreamingMessage.AgentName = signalrMessage.AgentName ?? "Morgana";
                
                // Mark as no longer streaming (removes cursor when typewriter finishes)
                currentStreamingMessage.IsStreaming = false;

                // DON'T stop streaming timer yet - let it finish draining buffer
                // Timer will auto-stop when buffer is empty (check TypewriterTick)

                // Update header
                if (!string.IsNullOrEmpty(signalrMessage.AgentName))
                {
                    currentAgentName = signalrMessage.AgentName;
                    Console.WriteLine($"üé® Header updated: {currentAgentName}");
                }

                if (signalrMessage.AgentCompleted)
                {
                    currentAgentName = "Morgana";
                    Console.WriteLine($"üé® Header reset to: {currentAgentName}");
                }

                // If agent completed and is specialized, add completion message
                if (signalrMessage.AgentCompleted && IsSpecializedAgent(signalrMessage.AgentName))
                {
                    chatMessages.Add(new ChatMessage
                    {
                        ConversationId = signalrMessage.ConversationId,
                        Text = GetCompletionMessage(signalrMessage.AgentName!),
                        Role = "assistant",
                        Timestamp = signalrMessage.Timestamp.AddMilliseconds(5),
                        AgentName = "Morgana",
                        AgentCompleted = true,
                        Type = MessageType.Presentation
                    });
                }

                await InvokeAsync(StateHasChanged);
                return;
            }

            // Normal message handling (non-streaming path)
            // Remove typing indicator
            ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);
            if (typingMessage != null)
                chatMessages.Remove(typingMessage);

            // Update header with current agent name
            if (!string.IsNullOrEmpty(signalrMessage.AgentName))
            {
                currentAgentName = signalrMessage.AgentName;
                Console.WriteLine($"üé® Header updated: {currentAgentName} ‚Üí Color: {GetAvatarBorderColor(currentAgentName)}");
            }

            // If agent has completed, return header to Morgana
            if (signalrMessage.AgentCompleted)
            {
                currentAgentName = "Morgana";
                Console.WriteLine($"üé® Header reset to: {currentAgentName} ‚Üí Color: {GetAvatarBorderColor(currentAgentName)}");
            }

            // Add main agent message
            chatMessages.Add(new ChatMessage
            {
                ConversationId = signalrMessage.ConversationId,
                Text = signalrMessage.Text,
                Role = "assistant",
                Timestamp = signalrMessage.Timestamp,
                QuickReplies = signalrMessage.QuickReplies,
                AgentName = signalrMessage.AgentName ?? "Morgana",
                AgentCompleted = false,
                RichCard = signalrMessage.RichCard
            });

            // If agent completed and is specialized, add completion message from Morgana
            if (signalrMessage.AgentCompleted && IsSpecializedAgent(signalrMessage.AgentName))
            {
                chatMessages.Add(new ChatMessage
                {
                    ConversationId = signalrMessage.ConversationId,
                    Text = GetCompletionMessage(signalrMessage.AgentName!),
                    Role = "assistant",
                    Timestamp = signalrMessage.Timestamp.AddMilliseconds(5),
                    AgentName = "Morgana",
                    AgentCompleted = true,
                    Type = MessageType.Presentation
                });
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Error in HandleMessageReceived: {ex.Message}");
        }
    }

    /// <summary>
    /// Callback invoked when FadingMessage component auto-dismisses.
    /// Removes the message from the temporary messages list.
    /// </summary>
    /// <param name="message">The message to remove</param>
    private void HandleMessageDismissed(SignalRMessage message)
    {
        Console.WriteLine($"üóëÔ∏è Dismissing temporary message: {message.MessageType}");
        temporaryMessages.Remove(message);
        StateHasChanged();
    }

    // =========================================================================
    // STREAMING HANDLERS
    // =========================================================================

    /// <summary>
    /// Handles incoming streaming chunks from SignalR.
    /// Starts streaming mode if needed and buffers chunks for typewriter effect.
    /// </summary>
    /// <param name="chunkText">Partial response text to append</param>
    /// <returns>Task representing the async chunk handling</returns>
    /// <remarks>
    /// <para><strong>Streaming Flow:</strong></para>
    /// <list type="number">
    /// <item>First chunk: Remove typing indicator, create streaming message, start typewriter timer</item>
    /// <item>Subsequent chunks: Append to streaming buffer</item>
    /// <item>Typewriter timer: Progressively displays buffered text</item>
    /// <item>Final message: HandleMessageReceivedAsync stops streaming and adds complete message</item>
    /// </list>
    /// </remarks>
    private async Task HandleStreamChunkReceivedAsync(string chunkText)
    {
        try
        {
            // First chunk - initialize streaming
            if (currentStreamingMessage == null)
            {
                // Remove typing indicator
                ChatMessage? typingMessage = chatMessages.LastOrDefault(m => m.IsTyping);
                if (typingMessage != null)
                    chatMessages.Remove(typingMessage);

                // Create new streaming message
                currentStreamingMessage = new ChatMessage
                {
                    ConversationId = conversationId,
                    Text = string.Empty,
                    Role = "assistant",
                    Timestamp = DateTime.UtcNow,
                    AgentName = currentAgentName,
                    IsStreaming = true
                };

                chatMessages.Add(currentStreamingMessage);

                // Start typewriter timer (fires every configurable N milliseconds by consuming configurable K characters)
                int.TryParse(Configuration["Morgana:StreamingResponse:TypewriterTickMilliseconds"], out int typewriterTickMilliseconds);
                if (typewriterTickMilliseconds <= 0)
                    typewriterTickMilliseconds = 25;
                int.TryParse(Configuration["Morgana:StreamingResponse:TypewriterTickChars"], out int typewriterTickChars);
                if (typewriterTickChars <= 0)
                    typewriterTickChars = 1;
                typewriterTimer?.Dispose();
                typewriterTimer = new Timer(TypewriterTick, typewriterTickChars, 0, typewriterTickMilliseconds);

                await InvokeAsync(StateHasChanged);
            }

            // Append chunk to buffer
            streamingBuffer += chunkText;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Error in HandleStreamChunkReceived: {ex.Message}");
        }
    }

    /// <summary>
    /// Timer callback for typewriter effect.
    /// Consumes K characters from the streaming buffer every configurable N milliseconds.
    /// Auto-stops when buffer is empty and streaming is complete.
    /// </summary>
    /// <param name="timerParameters">Timer input parameters (int: the number of characters to be consumed)</param>
    private void TypewriterTick(object? timerParameters)
    {
        if (currentStreamingMessage == null)
            return;

        // If buffer is empty
        if (string.IsNullOrEmpty(streamingBuffer))
        {
            // If streaming is complete (IsStreaming = false), cleanup and stop
            if (!currentStreamingMessage.IsStreaming)
            {
                Console.WriteLine("‚úÖ Typewriter finished - buffer empty and streaming complete");
                StopStreaming();
            }
            // Otherwise, just wait for more chunks
            return;
        }

        // Extract next N characters from buffer
        int charsToTake = Math.Min((int)timerParameters!, streamingBuffer.Length);
        string nextChars = streamingBuffer[..charsToTake];
        streamingBuffer = streamingBuffer[charsToTake..];

        // Append to streaming message
        currentStreamingMessage.Text += nextChars;

        // Update UI
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Stops streaming mode and cleans up resources.
    /// Called when final complete message arrives via HandleMessageReceivedAsync.
    /// </summary>
    private void StopStreaming()
    {
        typewriterTimer?.Dispose();
        typewriterTimer = null;
        streamingBuffer = string.Empty;
        currentStreamingMessage = null;
    }

    // =========================================================================
    // UI INTERACTION HANDLERS
    // =========================================================================

    /// <summary>
    /// Handles keyboard events in textarea (Enter to send, Shift+Enter for newline).
    /// </summary>
    /// <param name="e">Keyboard event args</param>
    /// <returns>Task representing the async key handling</returns>
    private async Task HandleKeyPressAsync(KeyboardEventArgs e)
    {
        // Send message on Enter (without Shift)
        if (e is { Key: "Enter", ShiftKey: false })
        {
            await SendMessageAsync();
        }
    }

    /// <summary>
    /// Handles quick reply button selection.
    /// Marks the selected reply, disables all buttons, and sends the reply value as user message.
    /// </summary>
    /// <param name="reply">Selected quick reply definition</param>
    /// <param name="message">Message containing the quick replies</param>
    /// <returns>Task representing the async selection handling</returns>
    private async Task SelectQuickReplyAsync(QuickReply reply, ChatMessage message)
    {
        // Prevent multiple selections
        if (message.SelectedQuickReplyId != null)
            return;

        Console.WriteLine($"üü° Quick reply selected: {reply.Label}");

        // Mark as selected and update UI
        message.SelectedQuickReplyId = reply.Id;
        StateHasChanged();

        // Visual feedback delay
        await Task.Delay(250);

        // Send the quick reply value as user message
        inputText = reply.Value;
        await SendMessageAsync();
    }

    /// <summary>
    /// Shows the confirmation modal for starting a new conversation.
    /// </summary>
    private void ShowConfirmModal()
    {
        showConfirmModal = true;
        StateHasChanged();
    }

    /// <summary>
    /// Hides the confirmation modal without taking action.
    /// </summary>
    private void HideConfirmModal()
    {
        showConfirmModal = false;
        StateHasChanged();
    }

    /// <summary>
    /// Handles the confirmation action - hides modal and starts new conversation.
    /// </summary>
    private async Task ConfirmNewConversationAsync()
    {
        showConfirmModal = false;
        StateHasChanged();
        await ClearConversationAsync();
    }

    // =========================================================================
    // UI STATE HELPERS
    // =========================================================================

    /// <summary>
    /// Checks if there are any unselected quick replies in the tail of message list.
    /// </summary>
    /// <returns>True if any message has ending quick replies that haven't been selected yet</returns>
    private bool HasActiveQuickReplies() =>
        chatMessages.Any(m => m is { QuickReplies: not null, SelectedQuickReplyId: null, IsLastHistoryMessage: true });

    /// <summary>
    /// Checks if there are any rich cards in the tail of message list.
    /// </summary>
    /// <returns>True if any message has ending rich card</returns>
    private bool HasActiveRichCard() =>
        chatMessages.Any(m => m is { RichCard: not null, IsLastHistoryMessage: true });

    /// <summary>
    /// Gets a value indicating whether the send button should be disabled.
    /// Disabled when: not connected, sending in progress, empty input, not initialized, has active quick replies, or typing indicator present.
    /// </summary>
    private bool IsSendButtonDisabled =>
        !isConnected ||
        isSending ||
        string.IsNullOrWhiteSpace(inputText) ||
        !isInitialized ||
        HasActiveQuickReplies() ||
        chatMessages.Any(m => m.IsTyping);

    /// <summary>
    /// Gets a value indicating whether the new conversation button should be visible.
    /// </summary>
    private bool IsNewConversationButtonVisible =>
        isConnected
         && isInitialized
         && hasCheckedStorage
         && !string.IsNullOrWhiteSpace(conversationId)
         && chatMessages.Count > 0;

    /// <summary>
    /// Gets a value indicating whether the textarea should be disabled.
    /// Disabled when: not connected, sending in progress, not initialized, has active quick replies, or typing indicator present.
    /// </summary>
    private bool IsTextareaDisabled =>
        !isConnected ||
        isSending ||
        !isInitialized ||
        HasActiveQuickReplies() ||
        chatMessages.Any(m => m.IsTyping);

    // =========================================================================
    // CLEANUP
    // =========================================================================

    /// <summary>
    /// Disposes component resources.
    /// Unsubscribes from SignalR events and stops connection.
    /// </summary>
    /// <returns>ValueTask representing the async dispose operation</returns>
    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from events
        SignalRService.OnMessageReceived -= HandleMessageReceivedAsync;
        SignalRService.OnStreamChunkReceived -= HandleStreamChunkReceivedAsync;

        // Clean up streaming resources
        typewriterTimer?.Dispose();
        
        // Stop SignalR connection
        await SignalRService.StopAsync();
    }

    // =========================================================================
    // HELPER METHODS
    // =========================================================================

    /// <summary>
    /// Determines if an agent name represents a specialized agent (not base Morgana).
    /// Specialized agents have names with parentheses, e.g., "Morgana (Billing)".
    /// </summary>
    /// <param name="agentName">Agent name to check</param>
    /// <returns>True if specialized agent, false if base Morgana</returns>
    private bool IsSpecializedAgent(string? agentName)
    {
        return agentName != null && agentName.Contains("(") && agentName.Contains(")");
    }

    /// <summary>
    /// Gets the CSS color variable for the avatar border based on agent type.
    /// </summary>
    /// <param name="agentName">Name of the current agent</param>
    /// <returns>
    /// "var(--secondary-color)" (pink) for specialized agents,
    /// "var(--primary-color)" (purple) for base Morgana
    /// </returns>
    private string GetAvatarBorderColor(string? agentName)
    {
        // Pink for specialized agents, purple for base Morgana
        return IsSpecializedAgent(agentName ?? "Morgana") ? "var(--secondary-color)" : "var(--primary-color)";
    }

    /// <summary>
    /// Gets the completion message to display when an agent finishes its task.
    /// Uses configured template from appsettings or default message.
    /// </summary>
    /// <param name="agentName">Name of the agent that completed</param>
    /// <returns>Formatted completion message</returns>
    private string GetCompletionMessage(string agentName)
    {
        string template = Configuration["Morgana:AgentExitMessage"] ?? "{0} has completed its spell. I'm back to you!";
        return string.Format(template, agentName);
    }

    /// <summary>
    /// Adds a temporary error message displayed as FadingMessage banner.
    /// Auto-dismisses after configurable N seconds with fade-out animation.
    /// </summary>
    /// <param name="text">Error message text (‚ö†Ô∏è emoji will be prepended)</param>
    /// <param name="errorReason">Specific error reason for debugging/icon selection</param>
    /// <param name="fadingMessageDurationSeconds">Optional duration of the fading message that will be displayed</param>
    private void AddErrorMessage(string text, string errorReason, int? fadingMessageDurationSeconds=10)
    {
        temporaryMessages.Add(new SignalRMessage
        {
            ConversationId = conversationId,
            Text = text,
            Timestamp = DateTime.UtcNow,
            MessageType = "error",
            ErrorReason = errorReason,
            FadingMessageDurationSeconds = fadingMessageDurationSeconds
        });
    }

    /// <summary>
    /// Removes all error-type temporary messages.
    /// Called on successful operations to clear previous errors.
    /// </summary>
    private void ClearErrorMessages()
    {
        temporaryMessages.RemoveAll(m => string.Equals(m.MessageType, "error", StringComparison.OrdinalIgnoreCase));
    }
}