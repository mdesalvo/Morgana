@page "/"
@using Morgana.Web.Messages
@using Morgana.Web.Services
@inject MorganaSignalRService SignalRService
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<PageTitle>Morgana - AI Assistant</PageTitle>

<div class="chat-container">
    <!-- Header -->
    <div class="chat-header">
        <div class="header-content">
            <img src="images/morgana-avatar.png" alt="Morgana" class="header-avatar" />
            <div class="header-info">
                <h1>Morgana</h1>
                <span class="status @(isConnected ? "online" : "offline")">
                    @(isConnected ? "Online" : "Offline")
                </span>
            </div>
        </div>
    </div>

    <!-- Messages Area -->
    <div class="messages-container" @ref="messagesContainer">
        @if (!isInitialized)
        {
            <div class="welcome-message">
                <div class="spinner"></div>
                <p>Inizializzazione in corso...</p>
            </div>
        }
        else if (messages.Count == 0)
        {
            <div class="welcome-message">
                <img src="images/morgana-avatar.png" alt="Morgana" class="welcome-avatar" />
                <h2>Benvenuto! Sono Morgana üßô‚Äç‚ôÄÔ∏è</h2>
                <p>Come posso aiutarti oggi?</p>
            </div>
        }
        else
        {
            @foreach (ChatMessage message in messages)
            {
                <div class="message @message.Role">
                    @if (message.Role == "assistant")
                    {
                        <img src="images/morgana-avatar.png" alt="Morgana" class="message-avatar" />
                    }
                    <div class="message-bubble">
                        @if (message.IsTyping)
                        {
                            <div class="typing-indicator">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        }
                        else
                        {
                            <div class="message-text">@message.Text</div>
                            <div class="message-time">@message.Timestamp.ToString("HH:mm")</div>
                        }
                    </div>
                </div>
            }
        }
    </div>

    <!-- Input Area -->
    <div class="input-container">
        <textarea 
            @ref="textareaRef"
            @bind="inputText" 
            @bind:event="oninput"
            @bind:after="OnInputChange"
            @onkeyup="HandleKeyPress"
            @onfocus="OnTextareaFocus"
            placeholder="Scrivi un messaggio..."
            rows="1"
            disabled="@IsTextareaDisabled"
            class="message-input"
        ></textarea>
        <button 
            @onclick="SendMessage" 
            disabled="@IsButtonDisabled"
            class="send-button @(isSending ? "sending" : "")">
            <span class="cauldron-wrapper">
                <span class="cauldron-icon">
                    <span class="cauldron-body"></span>
                    <span class="brew-surface"></span>
                    <span class="bubble b1"></span>
                    <span class="bubble b2"></span>
                    <span class="bubble b3"></span>
                    <span class="bubble b4"></span>
                    <span class="steam st1"></span>
                    <span class="steam st2"></span>
                    <span class="steam st3"></span>
                </span>
                <span class="magic-glow"></span>
                <span class="magic-ring"></span>
                <span class="sparkle s1"></span>
                <span class="sparkle s2"></span>
                <span class="sparkle s3"></span>
                <span class="sparkle s4"></span>
                <span class="sparkle s5"></span>
                <span class="sparkle s6"></span>
            </span>
        </button>
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-banner">
            ‚ö†Ô∏è @errorMessage
        </div>
    }
</div>

@code {
    private ElementReference messagesContainer;
    private ElementReference textareaRef;
    private List<ChatMessage> messages = new();
    private string inputText = string.Empty;
    private string conversationId = string.Empty;
    private bool isConnected = false;
    private bool isSending = false;
    private bool isInitialized = false;
    private string errorMessage = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            Console.WriteLine("üîµ OnInitializedAsync: Starting...");

            await SignalRService.StartAsync();
            isConnected = SignalRService.IsConnected;
            Console.WriteLine($"üîµ SignalR connected: {isConnected}");

            SignalRService.OnMessageReceived += async (conversationId, text, timestamp) => 
            {
                await HandleMessageReceived(conversationId, text, timestamp);
            };
            SignalRService.OnConnectionStateChanged += (connected) =>
            {
                isConnected = connected;
                Console.WriteLine($"üîµ Connection state changed: {connected}");
                InvokeAsync(StateHasChanged); // Necessario: callback da thread diverso
            };

            await StartConversation();
            isInitialized = true;
            errorMessage = string.Empty;
            Console.WriteLine($"üîµ Initialized with conversationId: {conversationId}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Initialization error: {ex.Message}");
            errorMessage = $"Errore di inizializzazione: {ex.Message}";
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task StartConversation()
    {
        try
        {
            Console.WriteLine("üü¢ StartConversation: Calling Morgana...");

            HttpResponseMessage response = await Http.PostAsJsonAsync("/api/conversation/start", new
            {
                conversationId = Guid.NewGuid().ToString("N")
            });

            Console.WriteLine($"üü¢ Morgana Response Status: {response.StatusCode}");

            if (response.IsSuccessStatusCode)
            {
                ConversationStartResponse? result = await response.Content.ReadFromJsonAsync<ConversationStartResponse>();
                conversationId = result?.ConversationId ?? string.Empty;

                Console.WriteLine($"üü¢ ConversationId received: {conversationId}");

                if (string.IsNullOrEmpty(conversationId))
                    throw new Exception("ConversationId is empty!");

                await SignalRService.JoinConversation(conversationId);

                Console.WriteLine($"üü¢ Joined SignalR group: {conversationId}");
            }
            else
            {
                string errorContent = await response.Content.ReadAsStringAsync();
                throw new Exception($"Morgana error: {response.StatusCode} - {errorContent}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error starting conversation: {ex.Message}");
            errorMessage = $"Impossibile avviare la conversazione: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(inputText) || isSending || string.IsNullOrEmpty(conversationId))
        {
            Console.WriteLine($"‚ùå SendMessage blocked: inputText={inputText}, isSending={isSending}, conversationId={conversationId}");
            return;
        }

        string messageText = inputText.Trim();
        inputText = string.Empty;
        errorMessage = string.Empty;
        isSending = true;
        
        StateHasChanged();

        Console.WriteLine($"üü° Sending message: '{messageText}' to conversation: {conversationId}");

        messages.Add(new ChatMessage
        {
            ConversationId = conversationId,
            Text = messageText,
            Role = "user",
            Timestamp = DateTime.Now
        });

        messages.Add(new ChatMessage
        {
            ConversationId = conversationId,
            Role = "assistant",
            IsTyping = true,
            Timestamp = DateTime.Now
        });

        StateHasChanged(); // Necessario: abbiamo modificato messages

        try
        {
            HttpResponseMessage response = await Http.PostAsJsonAsync($"/api/conversation/{conversationId}/message", new
            {
                conversationId = conversationId,
                text = messageText
            });

            Console.WriteLine($"üü° Message sent, response status: {response.StatusCode}");

            if (!response.IsSuccessStatusCode)
            {
                string errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"‚ùå Morgana error: {errorContent}");
                
                ChatMessage? typingMessage = messages.LastOrDefault(m => m.IsTyping);
                if (typingMessage != null)
                {
                    messages.Remove(typingMessage);
                    messages.Add(new ChatMessage
                    {
                        ConversationId = conversationId,
                        Text = "Mi dispiace, si √® verificato un errore. Riprova.",
                        Role = "assistant",
                        Timestamp = DateTime.Now,
                        IsError = true
                    });
                    StateHasChanged(); // Necessario: abbiamo modificato messages
                }
                
                errorMessage = $"Errore nell'invio: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå SendMessage exception: {ex.Message}");

            ChatMessage? typingMessage = messages.LastOrDefault(m => m.IsTyping);
            if (typingMessage != null)
            {
                messages.Remove(typingMessage);
                messages.Add(new ChatMessage
                {
                    ConversationId = conversationId,
                    Text = $"Errore di connessione: {ex.Message}",
                    Role = "assistant",
                    Timestamp = DateTime.Now,
                    IsError = true
                });

                errorMessage = $"Errore: {ex.Message}";
                StateHasChanged(); // Necessario: abbiamo modificato messages ed errorMessage
            }
        }
        finally
        {
            isSending = false;
            StateHasChanged(); // Necessario: aggiorna lo stato del pulsante
        }
    }

    private async Task HandleMessageReceived(string conversationId, string text, DateTime timestamp)
    {
        try
        {
            Console.WriteLine($"üü£ Message received for conversation: {conversationId}");

            if (this.conversationId != conversationId)
            {
                Console.WriteLine($"‚ö†Ô∏è Message for different conversation, ignoring");
                return;
            }

            ChatMessage? typingMessage = messages.LastOrDefault(m => m.IsTyping);
            if (typingMessage != null)
            {
                messages.Remove(typingMessage);
            }

            messages.Add(new ChatMessage
            {
                ConversationId = conversationId,
                Text = text,
                Role = "assistant",
                Timestamp = timestamp
            });

            await InvokeAsync(StateHasChanged); // Necessario: callback da SignalR (thread diverso)
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Error in HandleMessageReceived: {ex.Message}");
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private void OnInputChange()
    {
        // StateHasChanged viene gi√† chiamato automaticamente da @bind:after
        // Questa funzione esiste solo come hook se servisse logica aggiuntiva
    }

    private void OnTextareaFocus()
    {
        StateHasChanged();
    }

    private bool IsButtonDisabled => 
        !isConnected || 
        isSending || 
        string.IsNullOrWhiteSpace(inputText) || 
        !isInitialized || 
        messages.Any(m => m.IsTyping);

    private bool IsTextareaDisabled => 
        !isConnected || 
        isSending || 
        !isInitialized || 
        messages.Any(m => m.IsTyping);

    public async ValueTask DisposeAsync()
    {
        SignalRService.OnMessageReceived -= async (conversationId, text, timestamp) => 
        {
            await HandleMessageReceived(conversationId, text, timestamp);
        };
        await SignalRService.StopAsync();
    }
}